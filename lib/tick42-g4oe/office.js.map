{"version":3,"sources":["webpack://Glue4Office/webpack/universalModuleDefinition","webpack://Glue4Office/webpack/bootstrap","webpack://Glue4Office/./node_modules/@glue42/core/dist/core.es.js","webpack://Glue4Office/./node_modules/callback-registry/lib/index.js","webpack://Glue4Office/./node_modules/shortid/index.js","webpack://Glue4Office/./node_modules/shortid/lib/alphabet.js","webpack://Glue4Office/./node_modules/shortid/lib/decode.js","webpack://Glue4Office/./node_modules/shortid/lib/encode.js","webpack://Glue4Office/./node_modules/shortid/lib/index.js","webpack://Glue4Office/./node_modules/shortid/lib/is-valid.js","webpack://Glue4Office/./node_modules/shortid/lib/random/random-byte-browser.js","webpack://Glue4Office/./node_modules/shortid/lib/random/random-from-seed.js","webpack://Glue4Office/./node_modules/shortid/lib/util/cluster-worker-id-browser.js","webpack://Glue4Office/./node_modules/ws/browser.js","webpack://Glue4Office/./src/config.ts","webpack://Glue4Office/./src/excel/const.ts","webpack://Glue4Office/./src/excel/excel.ts","webpack://Glue4Office/./src/excel/main.ts","webpack://Glue4Office/./src/excel/sheet.ts","webpack://Glue4Office/./src/excel/utils.ts","webpack://Glue4Office/./src/glue4office.ts","webpack://Glue4Office/./src/index.ts","webpack://Glue4Office/./src/main.ts","webpack://Glue4Office/./src/outlook/dictionaries/ChunkDataDictionary.ts","webpack://Glue4Office/./src/outlook/dictionaries/CreateItemDictionary.ts","webpack://Glue4Office/./src/outlook/dictionaries/GetAttachmentDictionary.ts","webpack://Glue4Office/./src/outlook/dictionaries/GetItemAsMsgDictionary.ts","webpack://Glue4Office/./src/outlook/dictionaries/TrackEmailDictionary.ts","webpack://Glue4Office/./src/outlook/dictionaries/TrackItemDictionary.ts","webpack://Glue4Office/./src/outlook/helpers/createItem.ts","webpack://Glue4Office/./src/outlook/helpers/index.ts","webpack://Glue4Office/./src/outlook/helpers/methodNames.ts","webpack://Glue4Office/./src/outlook/helpers/validations.ts","webpack://Glue4Office/./src/outlook/items/AttachmentImplementation.ts","webpack://Glue4Office/./src/outlook/items/EmailImplementation.ts","webpack://Glue4Office/./src/outlook/items/Manager.ts","webpack://Glue4Office/./src/outlook/items/TaskImplementation.ts","webpack://Glue4Office/./src/outlook/main.ts","webpack://Glue4Office/./src/outlook/methods/createEmail.ts","webpack://Glue4Office/./src/outlook/methods/createLocalEmail.ts","webpack://Glue4Office/./src/outlook/methods/createTask.ts","webpack://Glue4Office/./src/outlook/methods/getAttachment.ts","webpack://Glue4Office/./src/outlook/methods/handleTrackingItems.ts","webpack://Glue4Office/./src/outlook/methods/itemFromJSON.ts","webpack://Glue4Office/./src/outlook/registerAgmMethods.ts","webpack://Glue4Office/./src/outlook/registerEventListeners.ts","webpack://Glue4Office/./src/outlook/types.ts","webpack://Glue4Office/./src/version.ts","webpack://Glue4Office/./src/word/const.ts","webpack://Glue4Office/./src/word/document.ts","webpack://Glue4Office/./src/word/main.ts","webpack://Glue4Office/./src/word/utils.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;;AAEA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;;AAEA;AACA,iDAAiD,QAAQ;AACzD,wCAAwC,QAAQ;AAChD,wDAAwD,QAAQ;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK,EAAE;AACP,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK,EAAE;AACP,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK,EAAE;AACP,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK,EAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,aAAa,EAAE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,0BAA0B,sCAAsC,EAAE;AAClE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,8BAA8B,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,+FAA+F,2DAA2D,EAAE;AAC5J;AACA;AACA,+FAA+F,2DAA2D,EAAE;AAC5J;AACA;AACA,+FAA+F,2DAA2D,EAAE;AAC5J;AACA;AACA,kGAAkG,8DAA8D,EAAE;AAClK;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,kEAAkE,+CAA+C,EAAE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB,EAAE;AAChF;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,+CAA+C;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C,kCAAkC,EAAE;AACnF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAA4C;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,mBAAO,CAAC,wCAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+EAA+E,EAAE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qCAAqC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,kBAAkB,YAAY,EAAE;AAChC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8EAA8E;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;AAOA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kCAAkC,EAAE;AACjF,2CAA2C,gCAAgC,EAAE;AAC7E,4CAA4C,kCAAkC,EAAE;AAChF;AACA;AACA,8CAA8C,kCAAkC,EAAE;AAClF,SAAS;AACT;AACA;AACA;AACA,8CAA8C,gCAAgC,EAAE;AAChF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,uCAAuC,sCAAsC,EAAE;AAC/E,wCAAwC,uCAAuC,EAAE;AACjF,2CAA2C,0CAA0C,EAAE;AACvF;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gCAAgC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,wCAAwC,EAAE;AACxG;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+EAA+E;AAChH,iCAAiC,+EAA+E;AAChH,gCAAgC,6EAA6E;AAC7G,0BAA0B,iEAAiE;AAC3F,yBAAyB,+DAA+D;AACxF,2BAA2B,mEAAmE;AAC9F,6BAA6B,uEAAuE;AACpG,4BAA4B,qEAAqE;AACjG,2BAA2B,mEAAmE;AAC9F,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,wDAAwD;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oDAAoD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yCAAyC,EAAE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sFAAsF;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,2DAA2D,EAAE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,wCAAwC,EAAE;AACxG;AACA;AACA;AACA;AACA;AACA,+DAA+D,wCAAwC,EAAE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iCAAiC;AAC1E;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB;AACvB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,mBAAmB;AACxH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8FAA8F,4BAA4B,EAAE;AAC5H;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC,mDAAmD,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI,GAAG,oBAAoB;AACxD;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,SAAS,IAAI,GAAG,oBAAoB;AACpC;AACA,8CAA8C,uBAAuB,0BAA0B,EAAE,GAAG,gCAAgC;AACpI,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,0BAA0B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0BAA0B;AAC7E;AACA;AACA,+BAA+B,uCAAuC;AACtE;AACA;AACA,+BAA+B,4DAA4D;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS,IAAI,GAAG,oBAAoB;AACpC;AACA,8CAA8C,UAAU,0BAA0B,sBAAsB,GAAG,gCAAgC;AAC3I,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa,EAAE,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uCAAuC,EAAE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qBAAqB,kBAAkB,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,mCAAmC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,mCAAmC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,0CAA0C;AACxH;AACA;AACA;AACA,0BAA0B,UAAU,aAAa,WAAW;AAC5D;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,mBAAmB,qBAAqB,mBAAmB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,qCAAqC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qBAAqB,kBAAkB,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qBAAqB,kBAAkB,EAAE;AAClD;AACA;AACA,qBAAqB,UAAU,aAAa;AAC5C;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU,aAAa;AAC5C,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA,wFAAwF,qCAAqC;AAC7H;AACA;AACA;AACA,oFAAoF,0BAA0B;AAC9G;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,oDAAoD,uCAAuC,EAAE,aAAa,EAAE;AAC1L;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,0CAA0C,sBAAsB,EAAE;AAClE,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,iCAAiC;AACvD,SAAS;AACT;AACA;AACA;AACA,sBAAsB,iCAAiC;AACvD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,sBAAsB,0BAA0B,WAAW,EAAE,kPAAkP,EAAE;AAC9W;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,0FAA0F,6CAA6C,EAAE;AACzI;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB,EAAE;AACnB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,8CAA8C,sDAAsD,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8CAA8C,oDAAoD,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kCAAkC,EAAE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,4DAA4D,mBAAmB;AAC/E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,2BAA2B,4CAA4C;AACvE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,0BAA0B,0CAA0C,EAAE;AACtE;AACA;AACA,KAAK;AACL;AACA,0BAA0B,oCAAoC,EAAE;AAChE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,wDAAwD,uCAAuC,EAAE;AACjG,uDAAuD,sCAAsC,EAAE;AAC/F,yDAAyD,wCAAwC,EAAE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,+CAA+C,qEAAqE,EAAE;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uCAAuC,EAAE;AAC5F;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,kCAAkC,EAAE;AAC9F;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,+DAA+D,EAAE;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,4BAA4B,EAAE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kFAAkF,GAAG,oFAAoF;AAChN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,+BAA+B,YAAY,mCAAmC,EAAE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,mBAAmB,EAAE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mCAAmC,YAAY,yBAAyB;AACxE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8CAA8C,UAAU,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uEAAuE,qCAAqC;AAC5G;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uCAAuC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,GAAG,qEAAqE,EAAE,GAAG,kCAAkC;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,+CAA+C,8BAA8B;AAC7E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B,EAAE;AACvE,sCAAsC,+DAA+D,EAAE;AACvG,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,gBAAgB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,2DAA2D,wCAAwC,EAAE;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+CAA+C;AACpF,oCAAoC,kCAAkC,EAAE;AACxE,uCAAuC,0CAA0C,EAAE;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,gCAAgC,6CAA6C,EAAE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mCAAmC,EAAE;AACtF,mDAAmD,qCAAqC,EAAE;AAC1F,oDAAoD,6CAA6C,EAAE;AACnG,sDAAsD,+CAA+C,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uCAAuC;AAC9E,gCAAgC,qCAAqC,EAAE;AACvE,mCAAmC,yCAAyC,EAAE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,qCAAqC;AAC9G;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,iEAAiE,iCAAiC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8CAA8C,qFAAqF;AACnI;AACA;AACA,gDAAgD,+EAA+E;AAC/H,2FAA2F,8CAA8C,EAAE;AAC3I;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,6CAA6C,sBAAsB,EAAE;AACrE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0EAA0E,8CAA8C,EAAE;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,aAAa;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mFAAmF,EAAE;AAChH,2BAA2B,8BAA8B,EAAE;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEe,uEAAQ,EAAC;AACxB;;;;;;;;;;;;;AChsNa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACrFa;AACb,iBAAiB,mBAAO,CAAC,wDAAa;;;;;;;;;;;;;ACDzB;;AAEb,qBAAqB,mBAAO,CAAC,wFAA2B;;AAExD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjGa;AACb,eAAe,mBAAO,CAAC,0DAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AChBa;;AAEb,iBAAiB,mBAAO,CAAC,sFAAsB;;AAE/C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AClBa;;AAEb,eAAe,mBAAO,CAAC,0DAAY;AACnC,aAAa,mBAAO,CAAC,sDAAU;AAC/B,aAAa,mBAAO,CAAC,sDAAU;AAC/B,cAAc,mBAAO,CAAC,0DAAY;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,mBAAO,CAAC,8FAA0B;;AAExD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnGa;AACb,eAAe,mBAAO,CAAC,0DAAY;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,SA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","file":"office.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Glue4Office\"] = factory();\n\telse\n\t\troot[\"Glue4Office\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\n\nvar MetricTypes = {\r\n    STRING: 1,\r\n    NUMBER: 2,\r\n    TIMESTAMP: 3,\r\n    OBJECT: 4\r\n};\n\nfunction getMetricTypeByValue(metric) {\r\n    if (metric.type === MetricTypes.TIMESTAMP) {\r\n        return \"timestamp\";\r\n    }\r\n    else if (metric.type === MetricTypes.NUMBER) {\r\n        return \"number\";\r\n    }\r\n    else if (metric.type === MetricTypes.STRING) {\r\n        return \"string\";\r\n    }\r\n    else if (metric.type === MetricTypes.OBJECT) {\r\n        return \"object\";\r\n    }\r\n    return \"unknown\";\r\n}\r\nfunction getTypeByValue(value) {\r\n    if (value.constructor === Date) {\r\n        return \"timestamp\";\r\n    }\r\n    else if (typeof value === \"number\") {\r\n        return \"number\";\r\n    }\r\n    else if (typeof value === \"string\") {\r\n        return \"string\";\r\n    }\r\n    else if (typeof value === \"object\") {\r\n        return \"object\";\r\n    }\r\n    else {\r\n        return \"string\";\r\n    }\r\n}\r\nfunction serializeMetric(metric) {\r\n    var serializedMetrics = {};\r\n    var type = getMetricTypeByValue(metric);\r\n    if (type === \"object\") {\r\n        var values = Object.keys(metric.value).reduce(function (memo, key) {\r\n            var innerType = getTypeByValue(metric.value[key]);\r\n            if (innerType === \"object\") {\r\n                var composite = defineNestedComposite(metric.value[key]);\r\n                memo[key] = {\r\n                    type: \"object\",\r\n                    description: \"\",\r\n                    context: {},\r\n                    composite: composite,\r\n                };\r\n            }\r\n            else {\r\n                memo[key] = {\r\n                    type: innerType,\r\n                    description: \"\",\r\n                    context: {},\r\n                };\r\n            }\r\n            return memo;\r\n        }, {});\r\n        serializedMetrics.composite = values;\r\n    }\r\n    serializedMetrics.name = normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name);\r\n    serializedMetrics.type = type;\r\n    serializedMetrics.description = metric.description;\r\n    serializedMetrics.context = {};\r\n    return serializedMetrics;\r\n}\r\nfunction defineNestedComposite(values) {\r\n    return Object.keys(values).reduce(function (memo, key) {\r\n        var type = getTypeByValue(values[key]);\r\n        if (type === \"object\") {\r\n            memo[key] = {\r\n                type: \"object\",\r\n                description: \"\",\r\n                context: {},\r\n                composite: defineNestedComposite(values[key]),\r\n            };\r\n        }\r\n        else {\r\n            memo[key] = {\r\n                type: type,\r\n                description: \"\",\r\n                context: {},\r\n            };\r\n        }\r\n        return memo;\r\n    }, {});\r\n}\r\nfunction normalizeMetricName(name) {\r\n    if (typeof name !== \"undefined\" && name.length > 0 && name[0] !== \"/\") {\r\n        return \"/\" + name;\r\n    }\r\n    else {\r\n        return name;\r\n    }\r\n}\r\nfunction getMetricValueByType(metric) {\r\n    var type = getMetricTypeByValue(metric);\r\n    if (type === \"timestamp\") {\r\n        return Date.now();\r\n    }\r\n    else {\r\n        return publishNestedComposite(metric.value);\r\n    }\r\n}\r\nfunction publishNestedComposite(values) {\r\n    if (typeof values !== \"object\") {\r\n        return values;\r\n    }\r\n    return Object.keys(values).reduce(function (memo, key) {\r\n        var value = values[key];\r\n        if (typeof value === \"object\" && value.constructor !== Date) {\r\n            memo[key] = publishNestedComposite(value);\r\n        }\r\n        else if (value.constructor === Date) {\r\n            memo[key] = new Date(value).getTime();\r\n        }\r\n        else if (value.constructor === Boolean) {\r\n            memo[key] = value.toString();\r\n        }\r\n        else {\r\n            memo[key] = value;\r\n        }\r\n        return memo;\r\n    }, {});\r\n}\r\nfunction flatten(arr) {\r\n    return arr.reduce(function (flat, toFlatten) {\r\n        return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);\r\n    }, []);\r\n}\r\nfunction getHighestState(arr) {\r\n    return arr.sort(function (a, b) {\r\n        if (!a.state) {\r\n            return 1;\r\n        }\r\n        if (!b.state) {\r\n            return -1;\r\n        }\r\n        return b.state - a.state;\r\n    })[0];\r\n}\r\nfunction aggregateDescription(arr) {\r\n    var msg = \"\";\r\n    arr.forEach(function (m, idx, a) {\r\n        var path = m.path.join(\".\");\r\n        if (idx === a.length - 1) {\r\n            msg += path + \".\" + m.name + \": \" + m.description;\r\n        }\r\n        else {\r\n            msg += path + \".\" + m.name + \": \" + m.description + \",\";\r\n        }\r\n    });\r\n    if (msg.length > 100) {\r\n        return msg.slice(0, 100) + \"...\";\r\n    }\r\n    else {\r\n        return msg;\r\n    }\r\n}\r\nfunction composeMsgForRootStateMetric(system) {\r\n    var aggregatedState = system.root.getAggregateState();\r\n    var merged = flatten(aggregatedState);\r\n    var highestState = getHighestState(merged);\r\n    var aggregateDesc = aggregateDescription(merged);\r\n    return {\r\n        description: aggregateDesc,\r\n        value: highestState.state,\r\n    };\r\n}\n\nfunction gw3 (connection, config) {\r\n    var _this = this;\r\n    if (!connection || typeof connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n    var joinPromise;\r\n    var session;\r\n    var init = function (repo) {\r\n        var resolveReadyPromise;\r\n        joinPromise = new Promise(function (resolve) {\r\n            resolveReadyPromise = resolve;\r\n        });\r\n        session = connection.domain(\"metrics\");\r\n        session.onJoined(function (reconnect) {\r\n            if (!reconnect && resolveReadyPromise) {\r\n                resolveReadyPromise();\r\n                resolveReadyPromise = undefined;\r\n            }\r\n            var rootStateMetric = {\r\n                name: \"/State\",\r\n                type: \"object\",\r\n                composite: {\r\n                    Description: {\r\n                        type: \"string\",\r\n                        description: \"\",\r\n                    },\r\n                    Value: {\r\n                        type: \"number\",\r\n                        description: \"\",\r\n                    },\r\n                },\r\n                description: \"System state\",\r\n                context: {},\r\n            };\r\n            var defineRootMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [rootStateMetric],\r\n            };\r\n            session.send(defineRootMetricsMsg);\r\n            if (reconnect) {\r\n                replayRepo(repo);\r\n            }\r\n        });\r\n        session.join({\r\n            system: config.system,\r\n            service: config.service,\r\n            instance: config.instance\r\n        });\r\n    };\r\n    var replayRepo = function (repo) {\r\n        replaySystem(repo.root);\r\n    };\r\n    var replaySystem = function (system) {\r\n        createSystem(system);\r\n        system.metrics.forEach(function (m) {\r\n            createMetric(m);\r\n        });\r\n        system.subSystems.forEach(function (ss) {\r\n            replaySystem(ss);\r\n        });\r\n    };\r\n    var createSystem = function (system) { return __awaiter(_this, void 0, void 0, function () {\r\n        var metric, createMetricsMsg;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (system.parent === undefined) {\r\n                        return [2];\r\n                    }\r\n                    return [4, joinPromise];\r\n                case 1:\r\n                    _a.sent();\r\n                    metric = {\r\n                        name: normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n                        type: \"object\",\r\n                        composite: {\r\n                            Description: {\r\n                                type: \"string\",\r\n                                description: \"\",\r\n                            },\r\n                            Value: {\r\n                                type: \"number\",\r\n                                description: \"\",\r\n                            },\r\n                        },\r\n                        description: \"System state\",\r\n                        context: {},\r\n                    };\r\n                    createMetricsMsg = {\r\n                        type: \"define\",\r\n                        metrics: [metric],\r\n                    };\r\n                    session.send(createMetricsMsg);\r\n                    return [2];\r\n            }\r\n        });\r\n    }); };\r\n    var updateSystem = function (system, state) { return __awaiter(_this, void 0, void 0, function () {\r\n        var shadowedUpdateMetric, stateObj, rootMetric;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4, joinPromise];\r\n                case 1:\r\n                    _a.sent();\r\n                    shadowedUpdateMetric = {\r\n                        type: \"publish\",\r\n                        values: [{\r\n                                name: normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n                                value: {\r\n                                    Description: state.description,\r\n                                    Value: state.state,\r\n                                },\r\n                                timestamp: Date.now(),\r\n                            }],\r\n                    };\r\n                    session.send(shadowedUpdateMetric);\r\n                    stateObj = composeMsgForRootStateMetric(system);\r\n                    rootMetric = {\r\n                        type: \"publish\",\r\n                        peer_id: connection.peerId,\r\n                        values: [{\r\n                                name: \"/State\",\r\n                                value: {\r\n                                    Description: stateObj.description,\r\n                                    Value: stateObj.value,\r\n                                },\r\n                                timestamp: Date.now(),\r\n                            }],\r\n                    };\r\n                    session.send(rootMetric);\r\n                    return [2];\r\n            }\r\n        });\r\n    }); };\r\n    var createMetric = function (metric) { return __awaiter(_this, void 0, void 0, function () {\r\n        var metricClone, m, createMetricsMsg;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    metricClone = cloneMetric(metric);\r\n                    return [4, joinPromise];\r\n                case 1:\r\n                    _a.sent();\r\n                    m = serializeMetric(metricClone);\r\n                    createMetricsMsg = {\r\n                        type: \"define\",\r\n                        metrics: [m],\r\n                    };\r\n                    session.send(createMetricsMsg);\r\n                    if (typeof metricClone.value !== \"undefined\") {\r\n                        updateMetricCore(metricClone);\r\n                    }\r\n                    return [2];\r\n            }\r\n        });\r\n    }); };\r\n    var updateMetric = function (metric) { return __awaiter(_this, void 0, void 0, function () {\r\n        var metricClone;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    metricClone = cloneMetric(metric);\r\n                    return [4, joinPromise];\r\n                case 1:\r\n                    _a.sent();\r\n                    updateMetricCore(metricClone);\r\n                    return [2];\r\n            }\r\n        });\r\n    }); };\r\n    var updateMetricCore = function (metric) {\r\n        if (canUpdate()) {\r\n            var value = getMetricValueByType(metric);\r\n            var publishMetricsMsg = {\r\n                type: \"publish\",\r\n                values: [{\r\n                        name: normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name),\r\n                        value: value,\r\n                        timestamp: Date.now(),\r\n                    }],\r\n            };\r\n            return session.sendFireAndForget(publishMetricsMsg);\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n    var cloneMetric = function (metric) {\r\n        var metricClone = __assign({}, metric);\r\n        if (typeof metric.value === \"object\" && metric.value !== null) {\r\n            metricClone.value = __assign({}, metric.value);\r\n        }\r\n        return metricClone;\r\n    };\r\n    var canUpdate = function () {\r\n        var _a;\r\n        try {\r\n            var func = (_a = config.canUpdateMetric) !== null && _a !== void 0 ? _a : (function () { return true; });\r\n            return func();\r\n        }\r\n        catch (_b) {\r\n            return true;\r\n        }\r\n    };\r\n    return {\r\n        init: init,\r\n        createSystem: createSystem,\r\n        updateSystem: updateSystem,\r\n        createMetric: createMetric,\r\n        updateMetric: updateMetric,\r\n    };\r\n}\n\nvar Helpers = {\r\n    validate: function (definition, parent, transport) {\r\n        if (definition === null || typeof definition !== \"object\") {\r\n            throw new Error(\"Missing definition\");\r\n        }\r\n        if (parent === null || typeof parent !== \"object\") {\r\n            throw new Error(\"Missing parent\");\r\n        }\r\n        if (transport === null || typeof transport !== \"object\") {\r\n            throw new Error(\"Missing transport\");\r\n        }\r\n    },\r\n};\n\nvar BaseMetric = (function () {\r\n    function BaseMetric(definition, system, transport, value, type) {\r\n        this.definition = definition;\r\n        this.system = system;\r\n        this.transport = transport;\r\n        this.value = value;\r\n        this.type = type;\r\n        this.path = [];\r\n        Helpers.validate(definition, system, transport);\r\n        this.path = system.path.slice(0);\r\n        this.path.push(system.name);\r\n        this.name = definition.name;\r\n        this.description = definition.description;\r\n        transport.createMetric(this);\r\n    }\r\n    Object.defineProperty(BaseMetric.prototype, \"repo\", {\r\n        get: function () {\r\n            var _a;\r\n            return (_a = this.system) === null || _a === void 0 ? void 0 : _a.repo;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseMetric.prototype, \"id\", {\r\n        get: function () { return this.system.path + \"/\" + name; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    BaseMetric.prototype.update = function (newValue) {\r\n        this.value = newValue;\r\n        return this.transport.updateMetric(this);\r\n    };\r\n    return BaseMetric;\r\n}());\n\nvar NumberMetric = (function (_super) {\r\n    __extends(NumberMetric, _super);\r\n    function NumberMetric(definition, system, transport, value) {\r\n        return _super.call(this, definition, system, transport, value, MetricTypes.NUMBER) || this;\r\n    }\r\n    NumberMetric.prototype.incrementBy = function (num) {\r\n        this.update(this.value + num);\r\n    };\r\n    NumberMetric.prototype.increment = function () {\r\n        this.incrementBy(1);\r\n    };\r\n    NumberMetric.prototype.decrement = function () {\r\n        this.incrementBy(-1);\r\n    };\r\n    NumberMetric.prototype.decrementBy = function (num) {\r\n        this.incrementBy(num * -1);\r\n    };\r\n    return NumberMetric;\r\n}(BaseMetric));\n\nvar ObjectMetric = (function (_super) {\r\n    __extends(ObjectMetric, _super);\r\n    function ObjectMetric(definition, system, transport, value) {\r\n        return _super.call(this, definition, system, transport, value, MetricTypes.OBJECT) || this;\r\n    }\r\n    ObjectMetric.prototype.update = function (newValue) {\r\n        this.mergeValues(newValue);\r\n        return this.transport.updateMetric(this);\r\n    };\r\n    ObjectMetric.prototype.mergeValues = function (values) {\r\n        var _this = this;\r\n        return Object.keys(this.value).forEach(function (k) {\r\n            if (typeof values[k] !== \"undefined\") {\r\n                _this.value[k] = values[k];\r\n            }\r\n        });\r\n    };\r\n    return ObjectMetric;\r\n}(BaseMetric));\n\nvar StringMetric = (function (_super) {\r\n    __extends(StringMetric, _super);\r\n    function StringMetric(definition, system, transport, value) {\r\n        return _super.call(this, definition, system, transport, value, MetricTypes.STRING) || this;\r\n    }\r\n    return StringMetric;\r\n}(BaseMetric));\n\nvar TimestampMetric = (function (_super) {\r\n    __extends(TimestampMetric, _super);\r\n    function TimestampMetric(definition, system, transport, value) {\r\n        return _super.call(this, definition, system, transport, value, MetricTypes.TIMESTAMP) || this;\r\n    }\r\n    TimestampMetric.prototype.now = function () {\r\n        this.update(new Date());\r\n    };\r\n    return TimestampMetric;\r\n}(BaseMetric));\n\nfunction system(name, repo, protocol, parent, description) {\r\n    if (!repo) {\r\n        throw new Error(\"Repository is required\");\r\n    }\r\n    if (!protocol) {\r\n        throw new Error(\"Transport is required\");\r\n    }\r\n    var _transport = protocol;\r\n    var _name = name;\r\n    var _description = description || \"\";\r\n    var _repo = repo;\r\n    var _parent = parent;\r\n    var _path = _buildPath(parent);\r\n    var _state = {};\r\n    var id = _arrayToString(_path, \"/\") + name;\r\n    var root = repo.root;\r\n    var _subSystems = [];\r\n    var _metrics = [];\r\n    function subSystem(nameSystem, descriptionSystem) {\r\n        if (!nameSystem || nameSystem.length === 0) {\r\n            throw new Error(\"name is required\");\r\n        }\r\n        var match = _subSystems.filter(function (s) { return s.name === nameSystem; });\r\n        if (match.length > 0) {\r\n            return match[0];\r\n        }\r\n        var _system = system(nameSystem, _repo, _transport, me, descriptionSystem);\r\n        _subSystems.push(_system);\r\n        return _system;\r\n    }\r\n    function setState(state, stateDescription) {\r\n        _state = { state: state, description: stateDescription };\r\n        _transport.updateSystem(me, _state);\r\n    }\r\n    function stringMetric(definition, value) {\r\n        return _getOrCreateMetric(definition, MetricTypes.STRING, value, function (metricDef) { return new StringMetric(metricDef, me, _transport, value); });\r\n    }\r\n    function numberMetric(definition, value) {\r\n        return _getOrCreateMetric(definition, MetricTypes.NUMBER, value, function (metricDef) { return new NumberMetric(metricDef, me, _transport, value); });\r\n    }\r\n    function objectMetric(definition, value) {\r\n        return _getOrCreateMetric(definition, MetricTypes.OBJECT, value, function (metricDef) { return new ObjectMetric(metricDef, me, _transport, value); });\r\n    }\r\n    function timestampMetric(definition, value) {\r\n        return _getOrCreateMetric(definition, MetricTypes.TIMESTAMP, value, function (metricDef) { return new TimestampMetric(metricDef, me, _transport, value); });\r\n    }\r\n    function _getOrCreateMetric(metricObject, expectedType, value, createMetric) {\r\n        var metricDef = { name: \"\" };\r\n        if (typeof metricObject === \"string\") {\r\n            metricDef = { name: metricObject };\r\n        }\r\n        else {\r\n            metricDef = metricObject;\r\n        }\r\n        var matching = _metrics.filter(function (shadowedMetric) { return shadowedMetric.name === metricDef.name; });\r\n        if (matching.length > 0) {\r\n            var existing = matching[0];\r\n            if (existing.type !== expectedType) {\r\n                throw new Error(\"A metric named \" + metricDef.name + \" is already defined with different type.\");\r\n            }\r\n            if (typeof value !== \"undefined\") {\r\n                existing\r\n                    .update(value)\r\n                    .catch(function () { });\r\n            }\r\n            return existing;\r\n        }\r\n        var metric = createMetric(metricDef);\r\n        _metrics.push(metric);\r\n        return metric;\r\n    }\r\n    function _buildPath(shadowedSystem) {\r\n        if (!shadowedSystem || !shadowedSystem.parent) {\r\n            return [];\r\n        }\r\n        var path = _buildPath(shadowedSystem.parent);\r\n        path.push(shadowedSystem.name);\r\n        return path;\r\n    }\r\n    function _arrayToString(path, separator) {\r\n        return ((path && path.length > 0) ? path.join(separator) : \"\");\r\n    }\r\n    function getAggregateState() {\r\n        var aggState = [];\r\n        if (Object.keys(_state).length > 0) {\r\n            aggState.push({\r\n                name: _name,\r\n                path: _path,\r\n                state: _state.state,\r\n                description: _state.description,\r\n            });\r\n        }\r\n        _subSystems.forEach(function (shadowedSubSystem) {\r\n            var result = shadowedSubSystem.getAggregateState();\r\n            if (result.length > 0) {\r\n                aggState.push.apply(aggState, result);\r\n            }\r\n        });\r\n        return aggState;\r\n    }\r\n    var me = {\r\n        get name() {\r\n            return _name;\r\n        },\r\n        get description() {\r\n            return _description;\r\n        },\r\n        get repo() {\r\n            return _repo;\r\n        },\r\n        get parent() {\r\n            return _parent;\r\n        },\r\n        path: _path,\r\n        id: id,\r\n        root: root,\r\n        get subSystems() {\r\n            return _subSystems;\r\n        },\r\n        get metrics() {\r\n            return _metrics;\r\n        },\r\n        subSystem: subSystem,\r\n        getState: function () {\r\n            return _state;\r\n        },\r\n        setState: setState,\r\n        stringMetric: stringMetric,\r\n        timestampMetric: timestampMetric,\r\n        objectMetric: objectMetric,\r\n        numberMetric: numberMetric,\r\n        getAggregateState: getAggregateState,\r\n    };\r\n    _transport.createSystem(me);\r\n    return me;\r\n}\n\nvar Repository = (function () {\r\n    function Repository(options, protocol) {\r\n        protocol.init(this);\r\n        this.root = system(\"\", this, protocol);\r\n        this.addSystemMetrics(this.root, options.clickStream || options.clickStream === undefined);\r\n    }\r\n    Repository.prototype.addSystemMetrics = function (rootSystem, useClickStream) {\r\n        if (typeof navigator !== \"undefined\") {\r\n            rootSystem.stringMetric(\"UserAgent\", navigator.userAgent);\r\n        }\r\n        if (useClickStream && typeof document !== \"undefined\") {\r\n            var clickStream_1 = rootSystem.subSystem(\"ClickStream\");\r\n            var documentClickHandler = function (e) {\r\n                if (!e.target) {\r\n                    return;\r\n                }\r\n                var target = e.target;\r\n                clickStream_1.objectMetric(\"LastBrowserEvent\", {\r\n                    type: \"click\",\r\n                    timestamp: new Date(),\r\n                    target: {\r\n                        className: e.target ? target.className : \"\",\r\n                        id: target.id,\r\n                        type: \"<\" + target.tagName.toLowerCase() + \">\",\r\n                        href: target.href || \"\",\r\n                    },\r\n                });\r\n            };\r\n            clickStream_1.objectMetric(\"Page\", {\r\n                title: document.title,\r\n                page: window.location.href,\r\n            });\r\n            if (document.addEventListener) {\r\n                document.addEventListener(\"click\", documentClickHandler);\r\n            }\r\n            else {\r\n                document.attachEvent(\"onclick\", documentClickHandler);\r\n            }\r\n        }\r\n        var startTime = rootSystem.stringMetric(\"StartTime\", (new Date()).toString());\r\n        var urlMetric = rootSystem.stringMetric(\"StartURL\", \"\");\r\n        var appNameMetric = rootSystem.stringMetric(\"AppName\", \"\");\r\n        if (typeof window !== \"undefined\") {\r\n            if (typeof window.location !== \"undefined\") {\r\n                var startUrl = window.location.href;\r\n                urlMetric.update(startUrl);\r\n            }\r\n            if (typeof window.glue42gd !== \"undefined\") {\r\n                appNameMetric.update(window.glue42gd.appName);\r\n            }\r\n        }\r\n    };\r\n    return Repository;\r\n}());\n\nvar NullProtocol = (function () {\r\n    function NullProtocol() {\r\n    }\r\n    NullProtocol.prototype.init = function (repo) {\r\n    };\r\n    NullProtocol.prototype.createSystem = function (system) {\r\n        return Promise.resolve();\r\n    };\r\n    NullProtocol.prototype.updateSystem = function (metric, state) {\r\n        return Promise.resolve();\r\n    };\r\n    NullProtocol.prototype.createMetric = function (metric) {\r\n        return Promise.resolve();\r\n    };\r\n    NullProtocol.prototype.updateMetric = function (metric) {\r\n        return Promise.resolve();\r\n    };\r\n    return NullProtocol;\r\n}());\n\nvar PerfTracker = (function () {\r\n    function PerfTracker(api, initialPublishTimeout, publishInterval) {\r\n        this.api = api;\r\n        this.lastCount = 0;\r\n        this.initialPublishTimeout = 10 * 1000;\r\n        this.publishInterval = 60 * 1000;\r\n        this.initialPublishTimeout = initialPublishTimeout !== null && initialPublishTimeout !== void 0 ? initialPublishTimeout : this.initialPublishTimeout;\r\n        this.publishInterval = publishInterval !== null && publishInterval !== void 0 ? publishInterval : this.publishInterval;\r\n        this.scheduleCollection();\r\n        this.system = this.api.subSystem(\"performance\", \"Performance data published by the web application\");\r\n    }\r\n    PerfTracker.prototype.scheduleCollection = function () {\r\n        var _this = this;\r\n        setTimeout(function () {\r\n            _this.collect();\r\n            setInterval(function () {\r\n                _this.collect();\r\n            }, _this.publishInterval);\r\n        }, this.initialPublishTimeout);\r\n    };\r\n    PerfTracker.prototype.collect = function () {\r\n        try {\r\n            this.collectMemory();\r\n            this.collectEntries();\r\n        }\r\n        catch (_a) {\r\n        }\r\n    };\r\n    PerfTracker.prototype.collectMemory = function () {\r\n        var memory = window.performance.memory;\r\n        this.system.stringMetric(\"memory\", JSON.stringify({\r\n            totalJSHeapSize: memory.totalJSHeapSize,\r\n            usedJSHeapSize: memory.usedJSHeapSize\r\n        }));\r\n    };\r\n    PerfTracker.prototype.collectEntries = function () {\r\n        var allEntries = window.performance.getEntries();\r\n        if (allEntries.length <= this.lastCount) {\r\n            return;\r\n        }\r\n        this.lastCount = allEntries.length;\r\n        var jsonfiedEntries = allEntries.map(function (i) { return i.toJSON(); });\r\n        this.system.stringMetric(\"entries\", JSON.stringify(jsonfiedEntries));\r\n    };\r\n    return PerfTracker;\r\n}());\n\nvar metrics = (function (options) {\r\n    var protocol;\r\n    if (!options.connection || typeof options.connection !== \"object\") {\r\n        protocol = new NullProtocol();\r\n    }\r\n    else {\r\n        protocol = gw3(options.connection, options);\r\n    }\r\n    var repo = new Repository(options, protocol);\r\n    var rootSystem = repo.root;\r\n    if (!options.disableAutoAppSystem) {\r\n        rootSystem = rootSystem.subSystem(\"App\");\r\n    }\r\n    var api = addFAVSupport(rootSystem);\r\n    initPerf(api, options.pagePerformanceMetrics);\r\n    return api;\r\n});\r\nvar perf;\r\nfunction initPerf(api, config) {\r\n    var _a, _b;\r\n    if (typeof window === \"undefined\") {\r\n        return;\r\n    }\r\n    var perfConfig = (_b = (_a = window === null || window === void 0 ? void 0 : window.glue42gd) === null || _a === void 0 ? void 0 : _a.metrics) === null || _b === void 0 ? void 0 : _b.pagePerformanceMetrics;\r\n    if (perfConfig) {\r\n        config = perfConfig;\r\n    }\r\n    if (config === null || config === void 0 ? void 0 : config.enabled) {\r\n        perf = new PerfTracker(api, config.initialPublishTimeout, config.publishInterval);\r\n    }\r\n}\r\nfunction addFAVSupport(system) {\r\n    var reportingSystem = system.subSystem(\"reporting\");\r\n    var def = {\r\n        name: \"features\"\r\n    };\r\n    var featureMetric;\r\n    var featureMetricFunc = function (name, action, payload) {\r\n        if (typeof name === \"undefined\" || name === \"\") {\r\n            throw new Error(\"name is mandatory\");\r\n        }\r\n        else if (typeof action === \"undefined\" || action === \"\") {\r\n            throw new Error(\"action is mandatory\");\r\n        }\r\n        else if (typeof payload === \"undefined\" || payload === \"\") {\r\n            throw new Error(\"payload is mandatory\");\r\n        }\r\n        if (!featureMetric) {\r\n            featureMetric = reportingSystem.objectMetric(def, { name: name, action: action, payload: payload });\r\n        }\r\n        else {\r\n            featureMetric.update({\r\n                name: name,\r\n                action: action,\r\n                payload: payload\r\n            });\r\n        }\r\n    };\r\n    system.featureMetric = featureMetricFunc;\r\n    return system;\r\n}\n\nfunction createRegistry(options) {\r\n    if (options && options.errorHandling\r\n        && typeof options.errorHandling !== \"function\"\r\n        && options.errorHandling !== \"log\"\r\n        && options.errorHandling !== \"silent\"\r\n        && options.errorHandling !== \"throw\") {\r\n        throw new Error(\"Invalid options passed to createRegistry. Prop errorHandling should be [\\\"log\\\" | \\\"silent\\\" | \\\"throw\\\" | (err) => void], but \" + typeof options.errorHandling + \" was passed\");\r\n    }\r\n    var _userErrorHandler = options && typeof options.errorHandling === \"function\" && options.errorHandling;\r\n    var callbacks = {};\r\n    function add(key, callback, replayArgumentsArr) {\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey) {\r\n            callbacksForKey = [];\r\n            callbacks[key] = callbacksForKey;\r\n        }\r\n        callbacksForKey.push(callback);\r\n        if (replayArgumentsArr) {\r\n            setTimeout(function () {\r\n                replayArgumentsArr.forEach(function (replayArgument) {\r\n                    var _a;\r\n                    if ((_a = callbacks[key]) === null || _a === void 0 ? void 0 : _a.includes(callback)) {\r\n                        try {\r\n                            if (Array.isArray(replayArgument)) {\r\n                                callback.apply(undefined, replayArgument);\r\n                            }\r\n                            else {\r\n                                callback.apply(undefined, [replayArgument]);\r\n                            }\r\n                        }\r\n                        catch (err) {\r\n                            _handleError(err, key);\r\n                        }\r\n                    }\r\n                });\r\n            }, 0);\r\n        }\r\n        return function () {\r\n            var allForKey = callbacks[key];\r\n            if (!allForKey) {\r\n                return;\r\n            }\r\n            allForKey = allForKey.reduce(function (acc, element, index) {\r\n                if (!(element === callback && acc.length === index)) {\r\n                    acc.push(element);\r\n                }\r\n                return acc;\r\n            }, []);\r\n            if (allForKey.length === 0) {\r\n                delete callbacks[key];\r\n            }\r\n            else {\r\n                callbacks[key] = allForKey;\r\n            }\r\n        };\r\n    }\r\n    function execute(key) {\r\n        var argumentsArr = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            argumentsArr[_i - 1] = arguments[_i];\r\n        }\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey || callbacksForKey.length === 0) {\r\n            return [];\r\n        }\r\n        var results = [];\r\n        callbacksForKey.forEach(function (callback) {\r\n            try {\r\n                var result = callback.apply(undefined, argumentsArr);\r\n                results.push(result);\r\n            }\r\n            catch (err) {\r\n                results.push(undefined);\r\n                _handleError(err, key);\r\n            }\r\n        });\r\n        return results;\r\n    }\r\n    function _handleError(exceptionArtifact, key) {\r\n        var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);\r\n        if (_userErrorHandler) {\r\n            _userErrorHandler(errParam);\r\n            return;\r\n        }\r\n        var msg = \"[ERROR] callback-registry: User callback for key \\\"\" + key + \"\\\" failed: \" + errParam.stack;\r\n        if (options) {\r\n            switch (options.errorHandling) {\r\n                case \"log\":\r\n                    return console.error(msg);\r\n                case \"silent\":\r\n                    return;\r\n                case \"throw\":\r\n                    throw new Error(msg);\r\n            }\r\n        }\r\n        console.error(msg);\r\n    }\r\n    function clear() {\r\n        callbacks = {};\r\n    }\r\n    function clearKey(key) {\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey) {\r\n            return;\r\n        }\r\n        delete callbacks[key];\r\n    }\r\n    return {\r\n        add: add,\r\n        execute: execute,\r\n        clear: clear,\r\n        clearKey: clearKey\r\n    };\r\n}\r\ncreateRegistry.default = createRegistry;\r\nvar lib = createRegistry;\n\nvar InProcTransport = (function () {\r\n    function InProcTransport(settings, logger) {\r\n        var _this = this;\r\n        this.registry = lib();\r\n        this.gw = settings.facade;\r\n        this.gw.connect(function (_client, message) {\r\n            _this.messageHandler(message);\r\n        }).then(function (client) {\r\n            _this.client = client;\r\n        });\r\n    }\r\n    Object.defineProperty(InProcTransport.prototype, \"isObjectBasedTransport\", {\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    InProcTransport.prototype.sendObject = function (msg) {\r\n        if (this.client) {\r\n            this.client.send(msg);\r\n            return Promise.resolve(undefined);\r\n        }\r\n        else {\r\n            return Promise.reject(\"not connected\");\r\n        }\r\n    };\r\n    InProcTransport.prototype.send = function (_msg) {\r\n        return Promise.reject(\"not supported\");\r\n    };\r\n    InProcTransport.prototype.onMessage = function (callback) {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    };\r\n    InProcTransport.prototype.onConnectedChanged = function (callback) {\r\n        callback(true);\r\n    };\r\n    InProcTransport.prototype.close = function () {\r\n        return Promise.resolve();\r\n    };\r\n    InProcTransport.prototype.open = function () {\r\n        return Promise.resolve();\r\n    };\r\n    InProcTransport.prototype.name = function () {\r\n        return \"in-memory\";\r\n    };\r\n    InProcTransport.prototype.reconnect = function () {\r\n        return Promise.resolve();\r\n    };\r\n    InProcTransport.prototype.messageHandler = function (msg) {\r\n        this.registry.execute(\"onMessage\", msg);\r\n    };\r\n    return InProcTransport;\r\n}());\n\nvar SharedWorkerTransport = (function () {\r\n    function SharedWorkerTransport(workerFile, logger) {\r\n        var _this = this;\r\n        this.logger = logger;\r\n        this.registry = lib();\r\n        this.worker = new SharedWorker(workerFile);\r\n        this.worker.port.onmessage = function (e) {\r\n            _this.messageHandler(e.data);\r\n        };\r\n    }\r\n    Object.defineProperty(SharedWorkerTransport.prototype, \"isObjectBasedTransport\", {\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    SharedWorkerTransport.prototype.sendObject = function (msg) {\r\n        this.worker.port.postMessage(msg);\r\n        return Promise.resolve();\r\n    };\r\n    SharedWorkerTransport.prototype.send = function (_msg) {\r\n        return Promise.reject(\"not supported\");\r\n    };\r\n    SharedWorkerTransport.prototype.onMessage = function (callback) {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    };\r\n    SharedWorkerTransport.prototype.onConnectedChanged = function (callback) {\r\n        callback(true);\r\n    };\r\n    SharedWorkerTransport.prototype.close = function () {\r\n        return Promise.resolve();\r\n    };\r\n    SharedWorkerTransport.prototype.open = function () {\r\n        return Promise.resolve();\r\n    };\r\n    SharedWorkerTransport.prototype.name = function () {\r\n        return \"shared-worker\";\r\n    };\r\n    SharedWorkerTransport.prototype.reconnect = function () {\r\n        return Promise.resolve();\r\n    };\r\n    SharedWorkerTransport.prototype.messageHandler = function (msg) {\r\n        this.registry.execute(\"onMessage\", msg);\r\n    };\r\n    return SharedWorkerTransport;\r\n}());\n\nvar Utils = (function () {\r\n    function Utils() {\r\n    }\r\n    Utils.getGDMajorVersion = function () {\r\n        if (typeof window === \"undefined\") {\r\n            return undefined;\r\n        }\r\n        if (!window.glueDesktop) {\r\n            return undefined;\r\n        }\r\n        if (!window.glueDesktop.version) {\r\n            return undefined;\r\n        }\r\n        var ver = Number(window.glueDesktop.version.substr(0, 1));\r\n        return isNaN(ver) ? undefined : ver;\r\n    };\r\n    Utils.isNode = function () {\r\n        if (typeof Utils._isNode !== \"undefined\") {\r\n            return Utils._isNode;\r\n        }\r\n        if (typeof window !== \"undefined\") {\r\n            Utils._isNode = false;\r\n            return false;\r\n        }\r\n        try {\r\n            Utils._isNode = Object.prototype.toString.call(global.process) === \"[object process]\";\r\n        }\r\n        catch (e) {\r\n            Utils._isNode = false;\r\n        }\r\n        return Utils._isNode;\r\n    };\r\n    return Utils;\r\n}());\n\nvar PromiseWrapper = (function () {\r\n    function PromiseWrapper() {\r\n        var _this = this;\r\n        this.rejected = false;\r\n        this.resolved = false;\r\n        this.promise = new Promise(function (resolve, reject) {\r\n            _this.resolve = function (t) {\r\n                _this.resolved = true;\r\n                resolve(t);\r\n            };\r\n            _this.reject = function (err) {\r\n                _this.rejected = true;\r\n                reject(err);\r\n            };\r\n        });\r\n    }\r\n    PromiseWrapper.delay = function (time) {\r\n        return new Promise(function (resolve) { return setTimeout(resolve, time); });\r\n    };\r\n    Object.defineProperty(PromiseWrapper.prototype, \"ended\", {\r\n        get: function () {\r\n            return this.rejected || this.resolved;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return PromiseWrapper;\r\n}());\n\nvar timers = {};\r\nfunction getAllTimers() {\r\n    return timers;\r\n}\r\nfunction timer (timerName) {\r\n    var existing = timers[timerName];\r\n    if (existing) {\r\n        return existing;\r\n    }\r\n    var marks = [];\r\n    function now() {\r\n        return new Date().getTime();\r\n    }\r\n    var startTime = now();\r\n    mark(\"start\", startTime);\r\n    var endTime;\r\n    var period;\r\n    function stop() {\r\n        endTime = now();\r\n        mark(\"end\", endTime);\r\n        period = endTime - startTime;\r\n        return period;\r\n    }\r\n    function mark(name, time) {\r\n        var currentTime = time !== null && time !== void 0 ? time : now();\r\n        var diff = 0;\r\n        if (marks.length > 0) {\r\n            diff = currentTime - marks[marks.length - 1].time;\r\n        }\r\n        marks.push({ name: name, time: currentTime, diff: diff });\r\n    }\r\n    var timerObj = {\r\n        get startTime() {\r\n            return startTime;\r\n        },\r\n        get endTime() {\r\n            return endTime;\r\n        },\r\n        get period() {\r\n            return period;\r\n        },\r\n        stop: stop,\r\n        mark: mark,\r\n        marks: marks\r\n    };\r\n    timers[timerName] = timerObj;\r\n    return timerObj;\r\n}\n\nvar WebSocketConstructor = Utils.isNode() ? require(\"ws\") : window.WebSocket;\r\nvar WS = (function () {\r\n    function WS(settings, logger) {\r\n        this.startupTimer = timer(\"connection\");\r\n        this._running = true;\r\n        this._registry = lib();\r\n        this.wsRequests = [];\r\n        this.settings = settings;\r\n        this.logger = logger;\r\n        if (!this.settings.ws) {\r\n            throw new Error(\"ws is missing\");\r\n        }\r\n    }\r\n    WS.prototype.onMessage = function (callback) {\r\n        return this._registry.add(\"onMessage\", callback);\r\n    };\r\n    WS.prototype.send = function (msg, options) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.waitForSocketConnection(function () {\r\n                var _a;\r\n                try {\r\n                    (_a = _this.ws) === null || _a === void 0 ? void 0 : _a.send(msg);\r\n                    resolve();\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            }, reject);\r\n        });\r\n    };\r\n    WS.prototype.open = function () {\r\n        var _this = this;\r\n        this.logger.info(\"opening ws...\");\r\n        this._running = true;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.waitForSocketConnection(resolve, reject);\r\n        });\r\n    };\r\n    WS.prototype.close = function () {\r\n        this._running = false;\r\n        if (this.ws) {\r\n            this.ws.close();\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n    WS.prototype.onConnectedChanged = function (callback) {\r\n        return this._registry.add(\"onConnectedChanged\", callback);\r\n    };\r\n    WS.prototype.name = function () {\r\n        return \"ws \" + this.settings.ws;\r\n    };\r\n    WS.prototype.reconnect = function () {\r\n        var _a;\r\n        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();\r\n        var pw = new PromiseWrapper();\r\n        this.waitForSocketConnection(function () {\r\n            pw.resolve();\r\n        });\r\n        return pw.promise;\r\n    };\r\n    WS.prototype.waitForSocketConnection = function (callback, failed) {\r\n        var _a;\r\n        failed = failed !== null && failed !== void 0 ? failed : (function () { });\r\n        if (!this._running) {\r\n            failed(\"wait for socket on \" + this.settings.ws + \" failed - socket closed by user\");\r\n            return;\r\n        }\r\n        if (((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) === 1) {\r\n            callback();\r\n            return;\r\n        }\r\n        this.wsRequests.push({ callback: callback, failed: failed });\r\n        if (this.wsRequests.length > 1) {\r\n            return;\r\n        }\r\n        this.openSocket();\r\n    };\r\n    WS.prototype.openSocket = function (retryInterval, retriesLeft) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            var _this = this;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        this.startupTimer.mark(\"opening-socket\");\r\n                        if (retryInterval === undefined) {\r\n                            retryInterval = this.settings.reconnectInterval;\r\n                        }\r\n                        if (retriesLeft !== undefined) {\r\n                            if (retriesLeft === 0) {\r\n                                this.notifyForSocketState(\"wait for socket on \" + this.settings.ws + \" failed - no more retries left\");\r\n                                return [2];\r\n                            }\r\n                            this.logger.debug(\"will retry \" + retriesLeft + \" more times (every \" + retryInterval + \" ms)\");\r\n                        }\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 3, , 4]);\r\n                        return [4, this.initiateSocket()];\r\n                    case 2:\r\n                        _b.sent();\r\n                        this.startupTimer.mark(\"socket-initiated\");\r\n                        this.notifyForSocketState();\r\n                        return [3, 4];\r\n                    case 3:\r\n                        _a = _b.sent();\r\n                        setTimeout(function () {\r\n                            var retries = retriesLeft === undefined ? undefined : retriesLeft - 1;\r\n                            _this.openSocket(retryInterval, retries);\r\n                        }, retryInterval);\r\n                        return [3, 4];\r\n                    case 4: return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    WS.prototype.initiateSocket = function () {\r\n        var _this = this;\r\n        var pw = new PromiseWrapper();\r\n        this.logger.debug(\"initiating ws to \" + this.settings.ws + \"...\");\r\n        this.ws = new WebSocketConstructor(this.settings.ws || \"\");\r\n        this.ws.onerror = function (err) {\r\n            var reason = \"\";\r\n            try {\r\n                reason = JSON.stringify(err);\r\n            }\r\n            catch (error) {\r\n                var seen_1 = new WeakSet();\r\n                var replacer = function (key, value) {\r\n                    if (typeof value === \"object\" && value !== null) {\r\n                        if (seen_1.has(value)) {\r\n                            return;\r\n                        }\r\n                        seen_1.add(value);\r\n                    }\r\n                    return value;\r\n                };\r\n                reason = JSON.stringify(err, replacer);\r\n            }\r\n            pw.reject(\"error\");\r\n            _this.notifyStatusChanged(false, reason);\r\n        };\r\n        this.ws.onclose = function (err) {\r\n            _this.logger.info(\"ws closed \" + err);\r\n            pw.reject(\"closed\");\r\n            _this.notifyStatusChanged(false);\r\n        };\r\n        this.ws.onopen = function () {\r\n            var _a;\r\n            _this.startupTimer.mark(\"ws-opened\");\r\n            _this.logger.info(\"ws opened \" + ((_a = _this.settings.identity) === null || _a === void 0 ? void 0 : _a.application));\r\n            pw.resolve();\r\n            _this.notifyStatusChanged(true);\r\n        };\r\n        this.ws.onmessage = function (message) {\r\n            _this._registry.execute(\"onMessage\", message.data);\r\n        };\r\n        return pw.promise;\r\n    };\r\n    WS.prototype.notifyForSocketState = function (error) {\r\n        this.wsRequests.forEach(function (wsRequest) {\r\n            if (error) {\r\n                if (wsRequest.failed) {\r\n                    wsRequest.failed(error);\r\n                }\r\n            }\r\n            else {\r\n                wsRequest.callback();\r\n            }\r\n        });\r\n        this.wsRequests = [];\r\n    };\r\n    WS.prototype.notifyStatusChanged = function (status, reason) {\r\n        this._registry.execute(\"onConnectedChanged\", status, reason);\r\n    };\r\n    return WS;\r\n}());\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nvar randomFromSeed = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed$1(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nvar alphabet_1 = {\n    characters: characters,\n    seed: setSeed$1,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n\nvar crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto\n\nfunction randomByte() {\n    if (!crypto || !crypto.getRandomValues) {\n        return Math.floor(Math.random() * 256) & 0x30;\n    }\n    var dest = new Uint8Array(1);\n    crypto.getRandomValues(dest);\n    return dest[0] & 0x30;\n}\n\nvar randomByteBrowser = randomByte;\n\nfunction encode(lookup, number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByteBrowser() );\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nvar encode_1 = encode;\n\n/**\n * Decode the id to get the version and worker\n * Mainly for debugging and testing.\n * @param id - the shortid-generated id.\n */\nfunction decode(id) {\n    var characters = alphabet_1.shuffled();\n    return {\n        version: characters.indexOf(id.substr(0, 1)) & 0x0f,\n        worker: characters.indexOf(id.substr(1, 1)) & 0x0f\n    };\n}\n\nvar decode_1 = decode;\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var characters = alphabet_1.characters();\n    var len = id.length;\n    for(var i = 0; i < len;i++) {\n        if (characters.indexOf(id[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvar isValid = isShortId;\n\nvar lib$1 = createCommonjsModule(function (module) {\n\n\n\n\n\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1459707606518;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 6;\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId =  0;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + encode_1(alphabet_1.lookup, version);\n    str = str + encode_1(alphabet_1.lookup, clusterWorkerId);\n    if (counter > 0) {\n        str = str + encode_1(alphabet_1.lookup, counter);\n    }\n    str = str + encode_1(alphabet_1.lookup, seconds);\n\n    return str;\n}\n\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet_1.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet_1.characters(newCharacters);\n    }\n\n    return alphabet_1.shuffled();\n}\n\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.decode = decode_1;\nmodule.exports.isValid = isValid;\n});\nvar lib_1 = lib$1.generate;\nvar lib_2 = lib$1.seed;\nvar lib_3 = lib$1.worker;\nvar lib_4 = lib$1.characters;\nvar lib_5 = lib$1.decode;\nvar lib_6 = lib$1.isValid;\n\nvar shortid = lib$1;\n\nfunction domainSession (domain, connection, logger, successMessages, errorMessages) {\r\n    if (domain == null) {\r\n        domain = \"global\";\r\n    }\r\n    successMessages = successMessages || [\"success\"];\r\n    errorMessages = errorMessages || [\"error\"];\r\n    var isJoined = false;\r\n    var tryReconnecting = false;\r\n    var _latestOptions;\r\n    var _connectionOn = false;\r\n    var callbacks = lib();\r\n    connection.disconnected(handleConnectionDisconnected);\r\n    connection.loggedIn(handleConnectionLoggedIn);\r\n    connection.on(\"success\", function (msg) { return handleSuccessMessage(msg); });\r\n    connection.on(\"error\", function (msg) { return handleErrorMessage(msg); });\r\n    connection.on(\"result\", function (msg) { return handleSuccessMessage(msg); });\r\n    if (successMessages) {\r\n        successMessages.forEach(function (sm) {\r\n            connection.on(sm, function (msg) { return handleSuccessMessage(msg); });\r\n        });\r\n    }\r\n    if (errorMessages) {\r\n        errorMessages.forEach(function (sm) {\r\n            connection.on(sm, function (msg) { return handleErrorMessage(msg); });\r\n        });\r\n    }\r\n    var requestsMap = {};\r\n    function join(options) {\r\n        _latestOptions = options;\r\n        return new Promise(function (resolve, reject) {\r\n            if (isJoined) {\r\n                resolve();\r\n                return;\r\n            }\r\n            var joinPromise;\r\n            if (domain === \"global\") {\r\n                joinPromise = _connectionOn ? Promise.resolve({}) : Promise.reject(\"not connected to gateway\");\r\n            }\r\n            else {\r\n                logger.debug(\"joining domain \" + domain);\r\n                var joinMsg = {\r\n                    type: \"join\",\r\n                    destination: domain,\r\n                    domain: \"global\",\r\n                    options: options,\r\n                };\r\n                joinPromise = send(joinMsg);\r\n            }\r\n            joinPromise\r\n                .then(function () {\r\n                handleJoined();\r\n                resolve();\r\n            })\r\n                .catch(function (err) {\r\n                logger.debug(\"error joining \" + domain + \" domain: \" + JSON.stringify(err));\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    function leave() {\r\n        if (domain === \"global\") {\r\n            return Promise.resolve();\r\n        }\r\n        logger.debug(\"stopping session \" + domain + \"...\");\r\n        var leaveMsg = {\r\n            type: \"leave\",\r\n            destination: domain,\r\n            domain: \"global\",\r\n        };\r\n        tryReconnecting = false;\r\n        return send(leaveMsg).then(function () {\r\n            isJoined = false;\r\n            callbacks.execute(\"onLeft\");\r\n        });\r\n    }\r\n    function handleJoined() {\r\n        logger.debug(\"did join \" + domain);\r\n        isJoined = true;\r\n        var wasReconnect = tryReconnecting;\r\n        tryReconnecting = false;\r\n        callbacks.execute(\"onJoined\", wasReconnect);\r\n    }\r\n    function handleConnectionDisconnected() {\r\n        _connectionOn = false;\r\n        logger.debug(\"connection is down\");\r\n        isJoined = false;\r\n        tryReconnecting = true;\r\n        callbacks.execute(\"onLeft\", { disconnected: true });\r\n    }\r\n    function handleConnectionLoggedIn() {\r\n        _connectionOn = true;\r\n        if (tryReconnecting) {\r\n            logger.debug(\"connection is now up - trying to reconnect...\");\r\n            join(_latestOptions);\r\n        }\r\n    }\r\n    function onJoined(callback) {\r\n        if (isJoined) {\r\n            callback(false);\r\n        }\r\n        return callbacks.add(\"onJoined\", callback);\r\n    }\r\n    function onLeft(callback) {\r\n        if (!isJoined) {\r\n            callback();\r\n        }\r\n        return callbacks.add(\"onLeft\", callback);\r\n    }\r\n    function handleErrorMessage(msg) {\r\n        if (domain !== msg.domain) {\r\n            return;\r\n        }\r\n        var requestId = msg.request_id;\r\n        if (!requestId) {\r\n            return;\r\n        }\r\n        var entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n        entry.error(msg);\r\n    }\r\n    function handleSuccessMessage(msg) {\r\n        if (msg.domain !== domain) {\r\n            return;\r\n        }\r\n        var requestId = msg.request_id;\r\n        if (!requestId) {\r\n            return;\r\n        }\r\n        var entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n        entry.success(msg);\r\n    }\r\n    function getNextRequestId() {\r\n        return shortid();\r\n    }\r\n    function send(msg, tag, options) {\r\n        options = options || {};\r\n        msg.request_id = msg.request_id || getNextRequestId();\r\n        msg.domain = msg.domain || domain;\r\n        if (!options.skipPeerId) {\r\n            msg.peer_id = connection.peerId;\r\n        }\r\n        var requestId = msg.request_id;\r\n        return new Promise(function (resolve, reject) {\r\n            requestsMap[requestId] = {\r\n                success: function (successMsg) {\r\n                    delete requestsMap[requestId];\r\n                    successMsg._tag = tag;\r\n                    resolve(successMsg);\r\n                },\r\n                error: function (errorMsg) {\r\n                    logger.warn(\"GW error - \" + JSON.stringify(errorMsg) + \" for request \" + JSON.stringify(msg));\r\n                    delete requestsMap[requestId];\r\n                    errorMsg._tag = tag;\r\n                    reject(errorMsg);\r\n                },\r\n            };\r\n            connection\r\n                .send(msg, options)\r\n                .catch(function (err) {\r\n                requestsMap[requestId].error({ err: err });\r\n            });\r\n        });\r\n    }\r\n    function sendFireAndForget(msg) {\r\n        msg.request_id = msg.request_id ? msg.request_id : getNextRequestId();\r\n        msg.domain = msg.domain || domain;\r\n        msg.peer_id = connection.peerId;\r\n        return connection.send(msg);\r\n    }\r\n    return {\r\n        join: join,\r\n        leave: leave,\r\n        onJoined: onJoined,\r\n        onLeft: onLeft,\r\n        send: send,\r\n        sendFireAndForget: sendFireAndForget,\r\n        on: function (type, callback) {\r\n            connection.on(type, function (msg) {\r\n                if (msg.domain !== domain) {\r\n                    return;\r\n                }\r\n                try {\r\n                    callback(msg);\r\n                }\r\n                catch (e) {\r\n                    logger.error(\"Callback  failed: \" + e + \" \\n \" + e.stack + \" \\n msg was: \" + JSON.stringify(msg), e);\r\n                }\r\n            });\r\n        },\r\n        loggedIn: function (callback) { return connection.loggedIn(callback); },\r\n        connected: function (callback) { return connection.connected(callback); },\r\n        disconnected: function (callback) { return connection.disconnected(callback); },\r\n        get peerId() {\r\n            return connection.peerId;\r\n        },\r\n        get domain() {\r\n            return domain;\r\n        },\r\n    };\r\n}\n\nvar GW3ProtocolImpl = (function () {\r\n    function GW3ProtocolImpl(connection, settings, logger) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        this.settings = settings;\r\n        this.logger = logger;\r\n        this.protocolVersion = 3;\r\n        this.datePrefix = \"#T42_DATE#\";\r\n        this.datePrefixLen = this.datePrefix.length;\r\n        this.dateMinLen = this.datePrefixLen + 1;\r\n        this.datePrefixFirstChar = this.datePrefix[0];\r\n        this.registry = lib();\r\n        this._isLoggedIn = false;\r\n        this.shouldTryLogin = true;\r\n        this.initialLogin = true;\r\n        this.initialLoginAttempts = 3;\r\n        this.sessions = [];\r\n        connection.disconnected(function () {\r\n            _this.handleDisconnected();\r\n        });\r\n        this.ping();\r\n    }\r\n    Object.defineProperty(GW3ProtocolImpl.prototype, \"isLoggedIn\", {\r\n        get: function () {\r\n            return this._isLoggedIn;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    GW3ProtocolImpl.prototype.processStringMessage = function (message) {\r\n        var _this = this;\r\n        var msg = JSON.parse(message, function (key, value) {\r\n            if (typeof value !== \"string\") {\r\n                return value;\r\n            }\r\n            if (value.length < _this.dateMinLen) {\r\n                return value;\r\n            }\r\n            if (value[0] !== _this.datePrefixFirstChar) {\r\n                return value;\r\n            }\r\n            if (value.substring(0, _this.datePrefixLen) !== _this.datePrefix) {\r\n                return value;\r\n            }\r\n            try {\r\n                var milliseconds = parseInt(value.substring(_this.datePrefixLen, value.length), 10);\r\n                if (isNaN(milliseconds)) {\r\n                    return value;\r\n                }\r\n                return new Date(milliseconds);\r\n            }\r\n            catch (ex) {\r\n                return value;\r\n            }\r\n        });\r\n        return {\r\n            msg: msg,\r\n            msgType: msg.type,\r\n        };\r\n    };\r\n    GW3ProtocolImpl.prototype.createStringMessage = function (message) {\r\n        var oldToJson = Date.prototype.toJSON;\r\n        try {\r\n            var datePrefix_1 = this.datePrefix;\r\n            Date.prototype.toJSON = function () {\r\n                return datePrefix_1 + this.getTime();\r\n            };\r\n            var result = JSON.stringify(message);\r\n            return result;\r\n        }\r\n        finally {\r\n            Date.prototype.toJSON = oldToJson;\r\n        }\r\n    };\r\n    GW3ProtocolImpl.prototype.processObjectMessage = function (message) {\r\n        if (!message.type) {\r\n            throw new Error(\"Object should have type property\");\r\n        }\r\n        return {\r\n            msg: message,\r\n            msgType: message.type,\r\n        };\r\n    };\r\n    GW3ProtocolImpl.prototype.createObjectMessage = function (message) {\r\n        return message;\r\n    };\r\n    GW3ProtocolImpl.prototype.login = function (config, reconnect) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var authentication, token, e_1, _a, helloMsg, sendOptions, welcomeMsg, msg, token, _b, err_1;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        this.logger.debug(\"logging in...\");\r\n                        this.loginConfig = config;\r\n                        if (!this.loginConfig) {\r\n                            this.loginConfig = { username: \"\", password: \"\" };\r\n                        }\r\n                        this.shouldTryLogin = true;\r\n                        authentication = {};\r\n                        this.connection.gatewayToken = config.gatewayToken;\r\n                        if (!config.gatewayToken) return [3, 5];\r\n                        if (!reconnect) return [3, 4];\r\n                        _c.label = 1;\r\n                    case 1:\r\n                        _c.trys.push([1, 3, , 4]);\r\n                        return [4, this.getNewGWToken()];\r\n                    case 2:\r\n                        token = _c.sent();\r\n                        config.gatewayToken = token;\r\n                        return [3, 4];\r\n                    case 3:\r\n                        e_1 = _c.sent();\r\n                        this.logger.warn(\"failed to get GW token when reconnecting \" + ((e_1 === null || e_1 === void 0 ? void 0 : e_1.message) || e_1));\r\n                        return [3, 4];\r\n                    case 4:\r\n                        authentication.method = \"gateway-token\";\r\n                        authentication.token = config.gatewayToken;\r\n                        this.connection.gatewayToken = config.gatewayToken;\r\n                        return [3, 10];\r\n                    case 5:\r\n                        if (!(config.flowName === \"sspi\")) return [3, 9];\r\n                        authentication.provider = \"win\";\r\n                        authentication.method = \"access-token\";\r\n                        if (!(config.flowCallback && config.sessionId)) return [3, 7];\r\n                        _a = authentication;\r\n                        return [4, config.flowCallback(config.sessionId, null)];\r\n                    case 6:\r\n                        _a.token =\r\n                            (_c.sent())\r\n                                .data\r\n                                .toString(\"base64\");\r\n                        return [3, 8];\r\n                    case 7: throw new Error(\"Invalid SSPI config\");\r\n                    case 8: return [3, 10];\r\n                    case 9:\r\n                        if (config.token) {\r\n                            authentication.method = \"access-token\";\r\n                            authentication.token = config.token;\r\n                        }\r\n                        else if (config.username) {\r\n                            authentication.method = \"secret\";\r\n                            authentication.login = config.username;\r\n                            authentication.secret = config.password;\r\n                        }\r\n                        else {\r\n                            throw new Error(\"invalid auth message\" + JSON.stringify(config));\r\n                        }\r\n                        _c.label = 10;\r\n                    case 10:\r\n                        helloMsg = {\r\n                            type: \"hello\",\r\n                            identity: this.settings.identity,\r\n                            authentication: authentication\r\n                        };\r\n                        if (config.sessionId) {\r\n                            helloMsg.request_id = config.sessionId;\r\n                        }\r\n                        this.globalDomain = domainSession(\"global\", this.connection, this.logger.subLogger(\"global-domain\"), [\r\n                            \"welcome\",\r\n                            \"token\",\r\n                            \"authentication-request\"\r\n                        ]);\r\n                        sendOptions = { skipPeerId: true };\r\n                        if (this.initialLogin) {\r\n                            sendOptions.retryInterval = this.settings.reconnectInterval;\r\n                            sendOptions.maxRetries = this.settings.reconnectAttempts;\r\n                        }\r\n                        _c.label = 11;\r\n                    case 11:\r\n                        _c.trys.push([11, 19, 20, 21]);\r\n                        welcomeMsg = void 0;\r\n                        _c.label = 12;\r\n                    case 12:\r\n                        return [4, this.globalDomain.send(helloMsg, undefined, sendOptions)];\r\n                    case 13:\r\n                        msg = _c.sent();\r\n                        if (!(msg.type === \"authentication-request\")) return [3, 16];\r\n                        token = Buffer.from(msg.authentication.token, \"base64\");\r\n                        if (!(config.flowCallback && config.sessionId)) return [3, 15];\r\n                        _b = helloMsg.authentication;\r\n                        return [4, config.flowCallback(config.sessionId, token)];\r\n                    case 14:\r\n                        _b.token =\r\n                            (_c.sent())\r\n                                .data\r\n                                .toString(\"base64\");\r\n                        _c.label = 15;\r\n                    case 15:\r\n                        helloMsg.request_id = config.sessionId;\r\n                        return [3, 12];\r\n                    case 16:\r\n                        if (msg.type === \"welcome\") {\r\n                            welcomeMsg = msg;\r\n                            return [3, 18];\r\n                        }\r\n                        else if (msg.type === \"error\") {\r\n                            throw new Error(\"Authentication failed: \" + msg.reason);\r\n                        }\r\n                        else {\r\n                            throw new Error(\"Unexpected message type during authentication: \" + msg.type);\r\n                        }\r\n                    case 17: return [3, 12];\r\n                    case 18:\r\n                        this.initialLogin = false;\r\n                        this.logger.debug(\"login successful with peerId \" + welcomeMsg.peer_id);\r\n                        this.connection.peerId = welcomeMsg.peer_id;\r\n                        this.connection.resolvedIdentity = welcomeMsg.resolved_identity;\r\n                        this.connection.availableDomains = welcomeMsg.available_domains;\r\n                        if (welcomeMsg.options) {\r\n                            this.connection.token = welcomeMsg.options.access_token;\r\n                            this.connection.info = welcomeMsg.options.info;\r\n                        }\r\n                        this.setLoggedIn(true);\r\n                        return [2, welcomeMsg.resolved_identity];\r\n                    case 19:\r\n                        err_1 = _c.sent();\r\n                        this.logger.error(\"error sending hello message - \" + (err_1.message || err_1.msg || err_1.reason || err_1), err_1);\r\n                        throw err_1;\r\n                    case 20:\r\n                        if (config && config.flowCallback && config.sessionId) {\r\n                            config.flowCallback(config.sessionId, null);\r\n                        }\r\n                        return [7];\r\n                    case 21: return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    GW3ProtocolImpl.prototype.logout = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var promises;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.logger.debug(\"logging out...\");\r\n                        this.shouldTryLogin = false;\r\n                        if (this.pingTimer) {\r\n                            clearTimeout(this.pingTimer);\r\n                        }\r\n                        promises = this.sessions.map(function (session) {\r\n                            session.leave();\r\n                        });\r\n                        return [4, Promise.all(promises)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    GW3ProtocolImpl.prototype.loggedIn = function (callback) {\r\n        if (this._isLoggedIn) {\r\n            callback();\r\n        }\r\n        return this.registry.add(\"onLoggedIn\", callback);\r\n    };\r\n    GW3ProtocolImpl.prototype.domain = function (domainName, domainLogger, successMessages, errorMessages) {\r\n        var session = this.sessions.filter(function (s) { return s.domain === domainName; })[0];\r\n        if (!session) {\r\n            session = domainSession(domainName, this.connection, domainLogger, successMessages, errorMessages);\r\n            this.sessions.push(session);\r\n        }\r\n        return session;\r\n    };\r\n    GW3ProtocolImpl.prototype.handleDisconnected = function () {\r\n        var _this = this;\r\n        this.setLoggedIn(false);\r\n        var tryToLogin = this.shouldTryLogin;\r\n        if (tryToLogin && this.initialLogin) {\r\n            if (this.initialLoginAttempts <= 0) {\r\n                return;\r\n            }\r\n            this.initialLoginAttempts--;\r\n        }\r\n        this.logger.debug(\"disconnected - will try new login?\" + this.shouldTryLogin);\r\n        if (this.shouldTryLogin) {\r\n            if (!this.loginConfig) {\r\n                throw new Error(\"no login info\");\r\n            }\r\n            this.connection.login(this.loginConfig, true)\r\n                .catch(function () {\r\n                setTimeout(_this.handleDisconnected.bind(_this), _this.settings.reconnectInterval || 1000);\r\n            });\r\n        }\r\n    };\r\n    GW3ProtocolImpl.prototype.setLoggedIn = function (value) {\r\n        this._isLoggedIn = value;\r\n        if (this._isLoggedIn) {\r\n            this.registry.execute(\"onLoggedIn\");\r\n        }\r\n    };\r\n    GW3ProtocolImpl.prototype.ping = function () {\r\n        var _this = this;\r\n        if (!this.shouldTryLogin) {\r\n            return;\r\n        }\r\n        if (this._isLoggedIn) {\r\n            this.connection.send({ type: \"ping\" });\r\n        }\r\n        this.pingTimer = setTimeout(function () {\r\n            _this.ping();\r\n        }, 30 * 1000);\r\n    };\r\n    GW3ProtocolImpl.prototype.authToken = function () {\r\n        var createTokenReq = {\r\n            type: \"create-token\"\r\n        };\r\n        if (!this.globalDomain) {\r\n            return Promise.reject(new Error(\"no global domain session\"));\r\n        }\r\n        return this.globalDomain.send(createTokenReq)\r\n            .then(function (res) {\r\n            return res.token;\r\n        });\r\n    };\r\n    GW3ProtocolImpl.prototype.getNewGWToken = function () {\r\n        if (typeof window !== undefined) {\r\n            var glue42gd = window.glue42gd;\r\n            if (glue42gd) {\r\n                return glue42gd.getGWToken();\r\n            }\r\n        }\r\n        return Promise.reject(new Error(\"not running in GD\"));\r\n    };\r\n    return GW3ProtocolImpl;\r\n}());\n\nvar MessageReplayerImpl = (function () {\r\n    function MessageReplayerImpl(specs) {\r\n        this.specsNames = [];\r\n        this.messages = {};\r\n        this.subs = {};\r\n        this.subsRefCount = {};\r\n        this.specs = {};\r\n        for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\r\n            var spec = specs_1[_i];\r\n            this.specs[spec.name] = spec;\r\n            this.specsNames.push(spec.name);\r\n        }\r\n    }\r\n    MessageReplayerImpl.prototype.init = function (connection) {\r\n        var _this = this;\r\n        this.connection = connection;\r\n        for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {\r\n            var name_1 = _a[_i];\r\n            var _loop_1 = function (type) {\r\n                var refCount = this_1.subsRefCount[type];\r\n                if (!refCount) {\r\n                    refCount = 0;\r\n                }\r\n                refCount += 1;\r\n                this_1.subsRefCount[type] = refCount;\r\n                if (refCount > 1) {\r\n                    return \"continue\";\r\n                }\r\n                var sub = connection.on(type, function (msg) { return _this.processMessage(type, msg); });\r\n                this_1.subs[type] = sub;\r\n            };\r\n            var this_1 = this;\r\n            for (var _b = 0, _c = this.specs[name_1].types; _b < _c.length; _b++) {\r\n                var type = _c[_b];\r\n                _loop_1(type);\r\n            }\r\n        }\r\n    };\r\n    MessageReplayerImpl.prototype.processMessage = function (type, msg) {\r\n        if (this.isDone || !msg) {\r\n            return;\r\n        }\r\n        for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {\r\n            var name_2 = _a[_i];\r\n            if (this.specs[name_2].types.indexOf(type) !== -1) {\r\n                var messages = this.messages[name_2] || [];\r\n                this.messages[name_2] = messages;\r\n                messages.push(msg);\r\n            }\r\n        }\r\n    };\r\n    MessageReplayerImpl.prototype.drain = function (name, callback) {\r\n        var _a;\r\n        if (callback) {\r\n            (this.messages[name] || []).forEach(callback);\r\n        }\r\n        delete this.messages[name];\r\n        for (var _i = 0, _b = this.specs[name].types; _i < _b.length; _i++) {\r\n            var type = _b[_i];\r\n            this.subsRefCount[type] -= 1;\r\n            if (this.subsRefCount[type] <= 0) {\r\n                (_a = this.connection) === null || _a === void 0 ? void 0 : _a.off(this.subs[type]);\r\n                delete this.subs[type];\r\n                delete this.subsRefCount[type];\r\n            }\r\n        }\r\n        delete this.specs[name];\r\n        if (!this.specs.length) {\r\n            this.isDone = true;\r\n        }\r\n    };\r\n    return MessageReplayerImpl;\r\n}());\n\nvar PromisePlus = function (executor, timeoutMilliseconds, timeoutMessage) {\r\n    return new Promise(function (resolve, reject) {\r\n        var timeout = setTimeout(function () {\r\n            var message = timeoutMessage || \"Promise timeout hit: \" + timeoutMilliseconds;\r\n            reject(message);\r\n        }, timeoutMilliseconds);\r\n        var providedPromise = new Promise(executor);\r\n        providedPromise\r\n            .then(function (result) {\r\n            clearTimeout(timeout);\r\n            resolve(result);\r\n        })\r\n            .catch(function (error) {\r\n            clearTimeout(timeout);\r\n            reject(error);\r\n        });\r\n    });\r\n};\n\nvar WebPlatformTransport = (function () {\r\n    function WebPlatformTransport(settings, logger, identity) {\r\n        this.settings = settings;\r\n        this.logger = logger;\r\n        this.identity = identity;\r\n        this.parentReady = false;\r\n        this.iAmConnected = false;\r\n        this.rejected = false;\r\n        this.children = [];\r\n        this.parentPingTimeout = 3000;\r\n        this.connectionRequestTimeout = 5000;\r\n        this.defaultTargetString = \"*\";\r\n        this.registry = lib();\r\n        this.messages = {\r\n            connectionAccepted: { name: \"connectionAccepted\", handle: this.handleConnectionAccepted.bind(this) },\r\n            connectionRejected: { name: \"connectionRejected\", handle: this.handleConnectionRejected.bind(this) },\r\n            connectionRequest: { name: \"connectionRequest\", handle: this.handleConnectionRequest.bind(this) },\r\n            parentReady: { name: \"parentReady\", handle: this.handleParentReady.bind(this) },\r\n            parentPing: { name: \"parentPing\", handle: this.handleParentPing.bind(this) },\r\n            platformPing: { name: \"platformPing\", handle: this.handlePlatformPing.bind(this) },\r\n            platformUnload: { name: \"platformUnload\", handle: this.handlePlatformUnload.bind(this) },\r\n            platformReady: { name: \"platformReady\", handle: this.handlePlatformReady.bind(this) },\r\n            clientUnload: { name: \"clientUnload\", handle: this.handleClientUnload.bind(this) },\r\n            manualUnload: { name: \"manualUnload\", handle: this.handleManualUnload.bind(this) }\r\n        };\r\n        this.setUpMessageListener();\r\n        this.setUpUnload();\r\n        if (!this.settings.port) {\r\n            this.parent = window.opener || window.top;\r\n            this.parentType = window.opener ? \"opener\" :\r\n                window.name.indexOf(\"#wsp\") !== -1 ? \"workspace\" : \"top\";\r\n        }\r\n    }\r\n    Object.defineProperty(WebPlatformTransport.prototype, \"transportWindowId\", {\r\n        get: function () {\r\n            return this.publicWindowId;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    WebPlatformTransport.prototype.sendObject = function (msg) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                if (!this.port) {\r\n                    throw new Error(\"Cannot send message, because the port was not opened yet\");\r\n                }\r\n                this.port.postMessage(msg);\r\n                return [2];\r\n            });\r\n        });\r\n    };\r\n    Object.defineProperty(WebPlatformTransport.prototype, \"isObjectBasedTransport\", {\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    WebPlatformTransport.prototype.onMessage = function (callback) {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    };\r\n    WebPlatformTransport.prototype.send = function () {\r\n        return Promise.reject(\"not supported\");\r\n    };\r\n    WebPlatformTransport.prototype.onConnectedChanged = function (callback) {\r\n        return this.registry.add(\"onConnectedChanged\", callback);\r\n    };\r\n    WebPlatformTransport.prototype.open = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.logger.debug(\"opening a connection to the web platform gateway.\");\r\n                        return [4, this.connect()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        this.notifyStatusChanged(true);\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    WebPlatformTransport.prototype.close = function () {\r\n        return Promise.resolve();\r\n    };\r\n    WebPlatformTransport.prototype.name = function () {\r\n        return \"web-platform\";\r\n    };\r\n    WebPlatformTransport.prototype.reconnect = function () {\r\n        return Promise.resolve();\r\n    };\r\n    WebPlatformTransport.prototype.connect = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (this.parentReady) {\r\n                            this.logger.debug(\"cancelling connection attempt, because this client's parent has already given a ready signal\");\r\n                            return [2];\r\n                        }\r\n                        if (this.settings.port) {\r\n                            this.logger.debug(\"opening an internal web platform connection\");\r\n                            this.port = this.settings.port;\r\n                            this.publicWindowId = this.settings.windowId;\r\n                            if (this.identity) {\r\n                                this.identity.windowId = this.publicWindowId;\r\n                            }\r\n                            this.port.onmessage = function (event) { return _this.registry.execute(\"onMessage\", event.data); };\r\n                            this.logger.debug(\"internal web platform connection completed\");\r\n                            return [2];\r\n                        }\r\n                        if (!this.parentType || !this.parent) {\r\n                            throw new Error(\"Cannot initiate a connection, because there is no opener, no top and no port.\");\r\n                        }\r\n                        this.logger.debug(\"opening a \" + (this.parentType === \"opener\" ? \"child\" : \"grandchild\") + \" client web platform connection\");\r\n                        return [4, this.waitParent(this.parent, this.parentType)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [4, this.initiateRemoteConnection(this.parent, this.parentType)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        this.logger.debug(\"the \" + (this.parentType === \"opener\" ? \"child\" : \"grandchild\") + \" client is connected\");\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    WebPlatformTransport.prototype.initiateRemoteConnection = function (target, parentType) {\r\n        var _this = this;\r\n        return PromisePlus(function (resolve, reject) {\r\n            _this.connectionResolve = resolve;\r\n            _this.connectionReject = reject;\r\n            _this.myClientId = shortid();\r\n            var bridgeInstanceId = _this.parentType === \"workspace\" ? window.name.substring(0, window.name.indexOf(\"#wsp\")) : window.name;\r\n            var request = {\r\n                glue42core: {\r\n                    type: _this.messages.connectionRequest.name,\r\n                    clientId: _this.myClientId,\r\n                    clientType: parentType === \"top\" || parentType === \"workspace\" ? \"grandChild\" : \"child\",\r\n                    bridgeInstanceId: bridgeInstanceId\r\n                }\r\n            };\r\n            _this.logger.debug(\"sending connection request to \" + parentType);\r\n            target.postMessage(request, _this.defaultTargetString);\r\n        }, this.connectionRequestTimeout, \"The connection to the opener/top window timed out\");\r\n    };\r\n    WebPlatformTransport.prototype.waitParent = function (target, parentType) {\r\n        var _this = this;\r\n        return PromisePlus(function (resolve) {\r\n            _this.parentPingResolve = resolve;\r\n            var message = {\r\n                glue42core: {\r\n                    type: parentType === \"opener\" ? _this.messages.platformPing.name : _this.messages.parentPing.name\r\n                }\r\n            };\r\n            _this.logger.debug(\"checking for \" + parentType + \" window availability\");\r\n            target.postMessage(message, _this.defaultTargetString);\r\n        }, this.parentPingTimeout, \"Cannot initiate glue, because this window was not opened or created by a glue client\");\r\n    };\r\n    WebPlatformTransport.prototype.setUpMessageListener = function () {\r\n        var _this = this;\r\n        if (this.settings.port) {\r\n            this.logger.debug(\"skipping generic message listener, because this is an internal client\");\r\n            return;\r\n        }\r\n        window.addEventListener(\"message\", function (event) {\r\n            var _a;\r\n            var data = (_a = event.data) === null || _a === void 0 ? void 0 : _a.glue42core;\r\n            if (!data || _this.rejected) {\r\n                return;\r\n            }\r\n            if (!_this.checkMessageTypeValid(data.type)) {\r\n                _this.logger.error(\"cannot handle the incoming glue42 core message, because the type is invalid: \" + data.type);\r\n                return;\r\n            }\r\n            var messageType = data.type;\r\n            _this.logger.debug(\"received valid glue42core message of type: \" + messageType);\r\n            _this.messages[messageType].handle(event);\r\n        });\r\n    };\r\n    WebPlatformTransport.prototype.setUpUnload = function () {\r\n        var _this = this;\r\n        if (this.settings.port) {\r\n            this.logger.debug(\"skipping unload event listener, because this is an internal client\");\r\n            return;\r\n        }\r\n        window.addEventListener(\"beforeunload\", function () {\r\n            var _a, _b;\r\n            var message = {\r\n                glue42core: {\r\n                    type: _this.messages.clientUnload.name,\r\n                    data: {\r\n                        clientId: _this.myClientId,\r\n                        ownWindowId: (_a = _this.identity) === null || _a === void 0 ? void 0 : _a.windowId\r\n                    }\r\n                }\r\n            };\r\n            if (_this.parent) {\r\n                _this.parent.postMessage(message, _this.defaultTargetString);\r\n            }\r\n            (_b = _this.port) === null || _b === void 0 ? void 0 : _b.postMessage(message);\r\n        });\r\n    };\r\n    WebPlatformTransport.prototype.handleParentReady = function () {\r\n        this.logger.debug(\"handling the ready signal from the parent, by resoling the pending promise.\");\r\n        this.parentReady = true;\r\n        if (this.parentPingResolve) {\r\n            this.parentPingResolve();\r\n            delete this.parentPingResolve;\r\n            return;\r\n        }\r\n        this.logger.debug(\"silently handling the ready signal from the top parent, because there is no defined promise\");\r\n    };\r\n    WebPlatformTransport.prototype.handlePlatformReady = function () {\r\n        this.logger.debug(\"the web platform gave the ready signal\");\r\n        this.parentReady = true;\r\n        if (this.parentPingResolve) {\r\n            this.parentPingResolve();\r\n            delete this.parentPingResolve;\r\n            return;\r\n        }\r\n        this.logger.debug(\"silently handling the ready signal from the top parent, because there is no defined promise\");\r\n    };\r\n    WebPlatformTransport.prototype.handleConnectionAccepted = function (event) {\r\n        var _a;\r\n        var data = (_a = event.data) === null || _a === void 0 ? void 0 : _a.glue42core;\r\n        if (this.myClientId === data.clientId) {\r\n            return this.handleAcceptanceOfMyRequest(data);\r\n        }\r\n        return this.handleAcceptanceOfGrandChildRequest(data, event);\r\n    };\r\n    WebPlatformTransport.prototype.handleAcceptanceOfMyRequest = function (data) {\r\n        var _this = this;\r\n        this.logger.debug(\"handling a connection accepted signal targeted at me.\");\r\n        if (!data.port) {\r\n            this.logger.error(\"cannot set up my connection, because I was not provided with a port\");\r\n            return;\r\n        }\r\n        this.publicWindowId = this.parentType === \"opener\" ? window.name :\r\n            this.parentType === \"top\" ? data.parentWindowId :\r\n                window.name.substring(0, window.name.indexOf(\"#wsp\"));\r\n        if (this.identity && this.parentType !== \"top\") {\r\n            this.identity.windowId = this.publicWindowId;\r\n        }\r\n        if (this.identity && data.appName) {\r\n            this.identity.application = data.appName;\r\n            this.identity.applicationName = data.appName;\r\n        }\r\n        this.port = data.port;\r\n        this.port.onmessage = function (e) { return _this.registry.execute(\"onMessage\", e.data); };\r\n        if (this.connectionResolve) {\r\n            this.logger.debug(\"my connection is set up, calling the connection resolve.\");\r\n            this.connectionResolve();\r\n            delete this.connectionResolve;\r\n            return;\r\n        }\r\n        this.logger.error(\"unable to call the connection resolve, because no connection promise was found\");\r\n    };\r\n    WebPlatformTransport.prototype.handleAcceptanceOfGrandChildRequest = function (data, event) {\r\n        this.logger.debug(\"handling a connection accepted signal targeted at a grandchild: \" + data.clientId);\r\n        var child = this.children.find(function (c) { return c.grandChildId === data.clientId; });\r\n        if (!child) {\r\n            this.logger.error(\"cannot handle connection accepted for grandchild: \" + data.clientId + \", because there is no grandchild with this id\");\r\n            return;\r\n        }\r\n        child.connected = true;\r\n        this.logger.debug(\"the grandchild connection for \" + data.clientId + \" is set up, forwarding the success message and the gateway port\");\r\n        data.parentWindowId = this.publicWindowId;\r\n        child.source.postMessage(event.data, child.origin, [data.port]);\r\n        return;\r\n    };\r\n    WebPlatformTransport.prototype.handleConnectionRejected = function () {\r\n        this.logger.debug(\"handling a connection rejection. Most likely the reason is that this window was not created by a glue API call\");\r\n        if (this.connectionReject) {\r\n            this.connectionReject(\"The platform connection was rejected. Most likely because this window was not created by a glue API call\");\r\n            delete this.connectionReject;\r\n        }\r\n    };\r\n    WebPlatformTransport.prototype.handleConnectionRequest = function (event) {\r\n        var source = event.source;\r\n        var data = event.data.glue42core;\r\n        if (!data.clientType || data.clientType !== \"grandChild\") {\r\n            return this.rejectConnectionRequest(source, event.origin, \"rejecting a connection request, because the source was not opened by a glue API call\");\r\n        }\r\n        if (!data.clientId) {\r\n            return this.rejectConnectionRequest(source, event.origin, \"rejecting a connection request, because the source did not provide a valid id\");\r\n        }\r\n        if (this.parentType !== \"opener\" || !this.parent) {\r\n            return this.rejectConnectionRequest(source, event.origin, \"Cannot forward the connection request, because no direct connection to the platform was found\");\r\n        }\r\n        this.logger.debug(\"handling a connection request for a grandchild: \" + data.clientId);\r\n        this.children.push({ grandChildId: data.clientId, source: source, connected: false, origin: event.origin });\r\n        this.logger.debug(\"grandchild: \" + data.clientId + \" is prepared, forwarding connection request to the platform\");\r\n        this.parent.postMessage(event.data, this.defaultTargetString);\r\n    };\r\n    WebPlatformTransport.prototype.handleParentPing = function (event) {\r\n        if (!this.parentReady) {\r\n            this.logger.debug(\"my parent is not ready, I am ignoring the parent ping\");\r\n            return;\r\n        }\r\n        if (!this.iAmConnected) {\r\n            this.logger.debug(\"i am not fully connected yet, I am ignoring the parent ping\");\r\n            return;\r\n        }\r\n        var message = {\r\n            glue42core: {\r\n                type: this.messages.parentReady.name\r\n            }\r\n        };\r\n        var source = event.source;\r\n        this.logger.debug(\"responding to a parent ping with a ready message\");\r\n        source.postMessage(message, event.origin);\r\n    };\r\n    WebPlatformTransport.prototype.handlePlatformUnload = function (event) {\r\n        this.logger.debug(\"detected a web platform unload\");\r\n        this.parentReady = false;\r\n        if (this.children.length) {\r\n            this.logger.debug(\"forwarding the platform unload to all known children and starting platform discovery polling\");\r\n            this.children.forEach(function (child) { return child.source.postMessage(event.data, child.origin); });\r\n        }\r\n        this.notifyStatusChanged(false, \"Gateway unloaded\");\r\n    };\r\n    WebPlatformTransport.prototype.handleManualUnload = function () {\r\n        var _a, _b;\r\n        var message = {\r\n            glue42core: {\r\n                type: this.messages.clientUnload.name,\r\n                data: {\r\n                    clientId: this.myClientId,\r\n                    ownWindowId: (_a = this.identity) === null || _a === void 0 ? void 0 : _a.windowId\r\n                }\r\n            }\r\n        };\r\n        if (this.parent) {\r\n            this.parent.postMessage(message, this.defaultTargetString);\r\n        }\r\n        (_b = this.port) === null || _b === void 0 ? void 0 : _b.postMessage(message);\r\n    };\r\n    WebPlatformTransport.prototype.handleClientUnload = function (event) {\r\n        var data = event.data.glue42core;\r\n        var clientId = data === null || data === void 0 ? void 0 : data.data.clientId;\r\n        if (!clientId) {\r\n            this.logger.warn(\"cannot process grand child unload, because the provided id was not valid\");\r\n            return;\r\n        }\r\n        var foundChild = this.children.find(function (child) { return child.grandChildId === clientId; });\r\n        if (!foundChild) {\r\n            this.logger.warn(\"cannot process grand child unload, because this client is unaware of this grandchild\");\r\n            return;\r\n        }\r\n        this.logger.debug(\"handling grandchild unload for id: \" + clientId);\r\n        this.children = this.children.filter(function (child) { return child.grandChildId !== clientId; });\r\n    };\r\n    WebPlatformTransport.prototype.handlePlatformPing = function () {\r\n        this.logger.error(\"cannot handle platform ping, because this is not a platform calls handling component\");\r\n    };\r\n    WebPlatformTransport.prototype.notifyStatusChanged = function (status, reason) {\r\n        this.iAmConnected = status;\r\n        this.registry.execute(\"onConnectedChanged\", status, reason);\r\n    };\r\n    WebPlatformTransport.prototype.checkMessageTypeValid = function (typeToValidate) {\r\n        return typeof typeToValidate === \"string\" && !!this.messages[typeToValidate];\r\n    };\r\n    WebPlatformTransport.prototype.rejectConnectionRequest = function (source, origin, reason) {\r\n        this.rejected = true;\r\n        this.logger.error(reason);\r\n        var rejection = {\r\n            glue42core: {\r\n                type: this.messages.connectionRejected.name\r\n            }\r\n        };\r\n        source.postMessage(rejection, origin);\r\n    };\r\n    return WebPlatformTransport;\r\n}());\n\nvar Connection = (function () {\r\n    function Connection(settings, logger) {\r\n        this.settings = settings;\r\n        this.logger = logger;\r\n        this.messageHandlers = {};\r\n        this.ids = 1;\r\n        this.registry = lib();\r\n        this._connected = false;\r\n        this.isTrace = false;\r\n        settings = settings || {};\r\n        settings.reconnectAttempts = settings.reconnectAttempts || 10;\r\n        settings.reconnectInterval = settings.reconnectInterval || 1000;\r\n        if (settings.inproc) {\r\n            this.transport = new InProcTransport(settings.inproc, logger.subLogger(\"inMemory\"));\r\n        }\r\n        else if (settings.sharedWorker) {\r\n            this.transport = new SharedWorkerTransport(settings.sharedWorker, logger.subLogger(\"shared-worker\"));\r\n        }\r\n        else if (settings.webPlatform) {\r\n            this.transport = new WebPlatformTransport(settings.webPlatform, logger.subLogger(\"web-platform\"), settings.identity);\r\n        }\r\n        else if (settings.ws !== undefined) {\r\n            this.transport = new WS(settings, logger.subLogger(\"ws\"));\r\n        }\r\n        else {\r\n            throw new Error(\"No connection information specified\");\r\n        }\r\n        this.isTrace = logger.canPublish(\"trace\");\r\n        logger.debug(\"starting with \" + this.transport.name() + \" transport\");\r\n        this.protocol = new GW3ProtocolImpl(this, settings, logger.subLogger(\"protocol\"));\r\n        this.transport.onConnectedChanged(this.handleConnectionChanged.bind(this));\r\n        this.transport.onMessage(this.handleTransportMessage.bind(this));\r\n        if (settings.replaySpecs && settings.replaySpecs.length) {\r\n            this.replayer = new MessageReplayerImpl(settings.replaySpecs);\r\n            this.replayer.init(this);\r\n        }\r\n    }\r\n    Object.defineProperty(Connection.prototype, \"protocolVersion\", {\r\n        get: function () {\r\n            var _a;\r\n            return (_a = this.protocol) === null || _a === void 0 ? void 0 : _a.protocolVersion;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Connection.prototype.send = function (message, options) {\r\n        if (this.transport.sendObject &&\r\n            this.transport.isObjectBasedTransport) {\r\n            var msg = this.protocol.createObjectMessage(message);\r\n            if (this.isTrace) {\r\n                this.logger.trace(\">> \" + JSON.stringify(msg));\r\n            }\r\n            return this.transport.sendObject(msg, options);\r\n        }\r\n        else {\r\n            var strMessage = this.protocol.createStringMessage(message);\r\n            if (this.isTrace) {\r\n                this.logger.trace(\">> \" + strMessage);\r\n            }\r\n            return this.transport.send(strMessage, options);\r\n        }\r\n    };\r\n    Connection.prototype.on = function (type, messageHandler) {\r\n        type = type.toLowerCase();\r\n        if (this.messageHandlers[type] === undefined) {\r\n            this.messageHandlers[type] = {};\r\n        }\r\n        var id = this.ids++;\r\n        this.messageHandlers[type][id] = messageHandler;\r\n        return {\r\n            type: type,\r\n            id: id,\r\n        };\r\n    };\r\n    Connection.prototype.off = function (info) {\r\n        delete this.messageHandlers[info.type.toLowerCase()][info.id];\r\n    };\r\n    Object.defineProperty(Connection.prototype, \"isConnected\", {\r\n        get: function () {\r\n            return this.protocol.isLoggedIn;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Connection.prototype.connected = function (callback) {\r\n        var _this = this;\r\n        return this.protocol.loggedIn(function () {\r\n            callback(_this.settings.ws || _this.settings.sharedWorker || \"\");\r\n        });\r\n    };\r\n    Connection.prototype.disconnected = function (callback) {\r\n        return this.registry.add(\"disconnected\", callback);\r\n    };\r\n    Connection.prototype.login = function (authRequest, reconnect) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var identity;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4, this.transport.open()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        timer(\"connection\").mark(\"transport-opened\");\r\n                        identity = this.protocol.login(authRequest, reconnect);\r\n                        timer(\"connection\").mark(\"protocol-logged-in\");\r\n                        return [2, identity];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Connection.prototype.logout = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4, this.protocol.logout()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [4, this.transport.close()];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Connection.prototype.loggedIn = function (callback) {\r\n        return this.protocol.loggedIn(callback);\r\n    };\r\n    Connection.prototype.domain = function (domain, successMessages, errorMessages) {\r\n        return this.protocol.domain(domain, this.logger.subLogger(\"domain=\" + domain), successMessages, errorMessages);\r\n    };\r\n    Connection.prototype.authToken = function () {\r\n        return this.protocol.authToken();\r\n    };\r\n    Connection.prototype.reconnect = function () {\r\n        return this.transport.reconnect();\r\n    };\r\n    Connection.prototype.distributeMessage = function (message, type) {\r\n        var _this = this;\r\n        var handlers = this.messageHandlers[type.toLowerCase()];\r\n        if (handlers !== undefined) {\r\n            Object.keys(handlers).forEach(function (handlerId) {\r\n                var handler = handlers[handlerId];\r\n                if (handler !== undefined) {\r\n                    try {\r\n                        handler(message);\r\n                    }\r\n                    catch (error) {\r\n                        try {\r\n                            _this.logger.error(\"Message handler failed with \" + error.stack, error);\r\n                        }\r\n                        catch (loggerError) {\r\n                            console.log(\"Message handler failed\", error);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    };\r\n    Connection.prototype.handleConnectionChanged = function (connected) {\r\n        if (this._connected === connected) {\r\n            return;\r\n        }\r\n        this._connected = connected;\r\n        if (connected) {\r\n            this.registry.execute(\"connected\");\r\n        }\r\n        else {\r\n            this.registry.execute(\"disconnected\");\r\n        }\r\n    };\r\n    Connection.prototype.handleTransportMessage = function (msg) {\r\n        var msgObj;\r\n        if (typeof msg === \"string\") {\r\n            msgObj = this.protocol.processStringMessage(msg);\r\n        }\r\n        else {\r\n            msgObj = this.protocol.processObjectMessage(msg);\r\n        }\r\n        if (this.isTrace) {\r\n            this.logger.trace(\"<< \" + JSON.stringify(msgObj));\r\n        }\r\n        this.distributeMessage(msgObj.msg, msgObj.msgType);\r\n    };\r\n    return Connection;\r\n}());\n\nvar order = [\"trace\", \"debug\", \"info\", \"warn\", \"error\", \"off\"];\r\nvar Logger = (function () {\r\n    function Logger(name, parent, logFn) {\r\n        this.name = name;\r\n        this.parent = parent;\r\n        this.subLoggers = [];\r\n        this.logFn = console;\r\n        this.customLogFn = false;\r\n        this.name = name;\r\n        if (parent) {\r\n            this.path = parent.path + \".\" + name;\r\n        }\r\n        else {\r\n            this.path = name;\r\n        }\r\n        this.loggerFullName = \"[\" + this.path + \"]\";\r\n        this.includeTimeAndLevel = !logFn;\r\n        if (logFn) {\r\n            this.logFn = logFn;\r\n            this.customLogFn = true;\r\n        }\r\n    }\r\n    Logger.prototype.subLogger = function (name) {\r\n        var existingSub = this.subLoggers.filter(function (subLogger) {\r\n            return subLogger.name === name;\r\n        })[0];\r\n        if (existingSub !== undefined) {\r\n            return existingSub;\r\n        }\r\n        Object.keys(this).forEach(function (key) {\r\n            if (key === name) {\r\n                throw new Error(\"This sub logger name is not allowed.\");\r\n            }\r\n        });\r\n        var sub = new Logger(name, this, this.customLogFn ? this.logFn : undefined);\r\n        this.subLoggers.push(sub);\r\n        return sub;\r\n    };\r\n    Logger.prototype.publishLevel = function (level) {\r\n        var _a;\r\n        if (level) {\r\n            this._publishLevel = level;\r\n        }\r\n        return this._publishLevel || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.publishLevel());\r\n    };\r\n    Logger.prototype.consoleLevel = function (level) {\r\n        var _a;\r\n        if (level) {\r\n            this._consoleLevel = level;\r\n        }\r\n        return this._consoleLevel || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.consoleLevel());\r\n    };\r\n    Logger.prototype.log = function (message, level, error) {\r\n        this.publishMessage(level || \"info\", message, error);\r\n    };\r\n    Logger.prototype.trace = function (message) {\r\n        this.log(message, \"trace\");\r\n    };\r\n    Logger.prototype.debug = function (message) {\r\n        this.log(message, \"debug\");\r\n    };\r\n    Logger.prototype.info = function (message) {\r\n        this.log(message, \"info\");\r\n    };\r\n    Logger.prototype.warn = function (message) {\r\n        this.log(message, \"warn\");\r\n    };\r\n    Logger.prototype.error = function (message, err) {\r\n        this.log(message, \"error\");\r\n    };\r\n    Logger.prototype.canPublish = function (level, compareWith) {\r\n        var levelIdx = order.indexOf(level);\r\n        var restrictionIdx = order.indexOf(compareWith || this.consoleLevel() || \"trace\");\r\n        return levelIdx >= restrictionIdx;\r\n    };\r\n    Logger.prototype.publishMessage = function (level, message, error) {\r\n        var loggerName = this.loggerFullName;\r\n        if (level === \"error\" && !error) {\r\n            var e = new Error();\r\n            if (e.stack) {\r\n                message =\r\n                    message +\r\n                        \"\\n\" +\r\n                        e.stack\r\n                            .split(\"\\n\")\r\n                            .slice(3)\r\n                            .join(\"\\n\");\r\n            }\r\n        }\r\n        if (this.canPublish(level, this.publishLevel())) {\r\n            var interop = Logger.Interop;\r\n            if (interop) {\r\n                try {\r\n                    if (interop.methods({ name: Logger.InteropMethodName }).length > 0) {\r\n                        interop.invoke(Logger.InteropMethodName, {\r\n                            msg: \"\" + message,\r\n                            logger: loggerName,\r\n                            level: level\r\n                        });\r\n                    }\r\n                }\r\n                catch (_a) {\r\n                }\r\n            }\r\n        }\r\n        if (this.canPublish(level)) {\r\n            var prefix = \"\";\r\n            if (this.includeTimeAndLevel) {\r\n                var date = new Date();\r\n                var time = date.getHours() + \":\" + date.getMinutes() + \":\" + date.getSeconds() + \":\" + date.getMilliseconds();\r\n                prefix = \"[\" + time + \"] [\" + level + \"] \";\r\n            }\r\n            var toPrint = \"\" + prefix + loggerName + \": \" + message;\r\n            switch (level) {\r\n                case \"trace\":\r\n                    this.logFn.debug(toPrint);\r\n                    break;\r\n                case \"debug\":\r\n                    if (this.logFn.debug) {\r\n                        this.logFn.debug(toPrint);\r\n                    }\r\n                    else {\r\n                        this.logFn.log(toPrint);\r\n                    }\r\n                    break;\r\n                case \"info\":\r\n                    this.logFn.info(toPrint);\r\n                    break;\r\n                case \"warn\":\r\n                    this.logFn.warn(toPrint);\r\n                    break;\r\n                case \"error\":\r\n                    this.logFn.error(toPrint, error);\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n    Logger.InteropMethodName = \"T42.AppLogger.Log\";\r\n    return Logger;\r\n}());\n\nvar GW_MESSAGE_CREATE_CONTEXT = \"create-context\";\r\nvar GW_MESSAGE_ACTIVITY_CREATED = \"created\";\r\nvar GW_MESSAGE_ACTIVITY_DESTROYED = \"destroyed\";\r\nvar GW_MESSAGE_CONTEXT_CREATED = \"context-created\";\r\nvar GW_MESSAGE_CONTEXT_ADDED = \"context-added\";\r\nvar GW_MESSAGE_SUBSCRIBE_CONTEXT = \"subscribe-context\";\r\nvar GW_MESSAGE_SUBSCRIBED_CONTEXT = \"subscribed-context\";\r\nvar GW_MESSAGE_UNSUBSCRIBE_CONTEXT = \"unsubscribe-context\";\r\nvar GW_MESSAGE_DESTROY_CONTEXT = \"destroy-context\";\r\nvar GW_MESSAGE_CONTEXT_DESTROYED = \"context-destroyed\";\r\nvar GW_MESSAGE_UPDATE_CONTEXT = \"update-context\";\r\nvar GW_MESSAGE_CONTEXT_UPDATED = \"context-updated\";\r\nvar GW_MESSAGE_JOINED_ACTIVITY = \"joined\";\n\nvar ContextMessageReplaySpec = {\r\n    get name() {\r\n        return \"context\";\r\n    },\r\n    get types() {\r\n        return [\r\n            GW_MESSAGE_CREATE_CONTEXT,\r\n            GW_MESSAGE_ACTIVITY_CREATED,\r\n            GW_MESSAGE_ACTIVITY_DESTROYED,\r\n            GW_MESSAGE_CONTEXT_CREATED,\r\n            GW_MESSAGE_CONTEXT_ADDED,\r\n            GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n            GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n            GW_MESSAGE_DESTROY_CONTEXT,\r\n            GW_MESSAGE_CONTEXT_DESTROYED,\r\n            GW_MESSAGE_UPDATE_CONTEXT,\r\n            GW_MESSAGE_CONTEXT_UPDATED,\r\n            GW_MESSAGE_JOINED_ACTIVITY\r\n        ];\r\n    }\r\n};\n\nvar version = \"5.4.13\";\n\nfunction prepareConfig (configuration, ext, glue42gd) {\r\n    var _a, _b, _c, _d, _e;\r\n    var nodeStartingContext;\r\n    if (Utils.isNode()) {\r\n        var startingContextString = process.env._GD_STARTING_CONTEXT_;\r\n        if (startingContextString) {\r\n            try {\r\n                nodeStartingContext = JSON.parse(startingContextString);\r\n            }\r\n            catch (_f) {\r\n            }\r\n        }\r\n    }\r\n    function getConnection() {\r\n        var _a, _b, _c, _d, _e;\r\n        var gwConfig = configuration.gateway;\r\n        var protocolVersion = (_a = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.protocolVersion) !== null && _a !== void 0 ? _a : 3;\r\n        var reconnectInterval = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.reconnectInterval;\r\n        var reconnectAttempts = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.reconnectAttempts;\r\n        var defaultWs = \"ws://localhost:8385\";\r\n        var ws = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.ws;\r\n        var sharedWorker = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.sharedWorker;\r\n        var inproc = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.inproc;\r\n        var webPlatform = (_b = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.webPlatform) !== null && _b !== void 0 ? _b : undefined;\r\n        if (glue42gd) {\r\n            ws = glue42gd.gwURL;\r\n        }\r\n        if (Utils.isNode() && nodeStartingContext && nodeStartingContext.gwURL) {\r\n            ws = nodeStartingContext.gwURL;\r\n        }\r\n        if (!ws && !sharedWorker && !inproc) {\r\n            ws = defaultWs;\r\n        }\r\n        var instanceId;\r\n        var windowId;\r\n        var pid;\r\n        var environment;\r\n        var region;\r\n        var appName = getApplication();\r\n        var uniqueAppName = appName;\r\n        if (typeof glue42gd !== \"undefined\") {\r\n            windowId = glue42gd.windowId;\r\n            pid = glue42gd.pid;\r\n            if (glue42gd.env) {\r\n                environment = glue42gd.env.env;\r\n                region = glue42gd.env.region;\r\n            }\r\n            uniqueAppName = (_c = glue42gd.application) !== null && _c !== void 0 ? _c : \"glue-app\";\r\n            instanceId = glue42gd.appInstanceId;\r\n        }\r\n        else if (Utils.isNode()) {\r\n            pid = process.pid;\r\n            if (nodeStartingContext) {\r\n                environment = nodeStartingContext.env;\r\n                region = nodeStartingContext.region;\r\n                instanceId = nodeStartingContext.instanceId;\r\n            }\r\n        }\r\n        else ;\r\n        var replaySpecs = (_e = (_d = configuration.gateway) === null || _d === void 0 ? void 0 : _d.replaySpecs) !== null && _e !== void 0 ? _e : [];\r\n        replaySpecs.push(ContextMessageReplaySpec);\r\n        return {\r\n            identity: {\r\n                application: uniqueAppName,\r\n                applicationName: appName,\r\n                windowId: windowId,\r\n                instance: instanceId,\r\n                process: pid,\r\n                region: region,\r\n                environment: environment,\r\n                api: ext.version || version\r\n            },\r\n            reconnectInterval: reconnectInterval,\r\n            ws: ws,\r\n            sharedWorker: sharedWorker,\r\n            webPlatform: webPlatform,\r\n            inproc: inproc,\r\n            protocolVersion: protocolVersion,\r\n            reconnectAttempts: reconnectAttempts,\r\n            replaySpecs: replaySpecs,\r\n        };\r\n    }\r\n    function getApplication() {\r\n        if (configuration.application) {\r\n            return configuration.application;\r\n        }\r\n        if (glue42gd) {\r\n            return glue42gd.applicationName;\r\n        }\r\n        var uid = shortid();\r\n        if (Utils.isNode()) {\r\n            if (nodeStartingContext) {\r\n                return nodeStartingContext.applicationConfig.name;\r\n            }\r\n            return \"NodeJS\" + uid;\r\n        }\r\n        if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\r\n            return document.title + (\" (\" + uid + \")\");\r\n        }\r\n        return uid;\r\n    }\r\n    function getAuth() {\r\n        var _a, _b, _c;\r\n        if (typeof configuration.auth === \"string\") {\r\n            return {\r\n                token: configuration.auth\r\n            };\r\n        }\r\n        if (configuration.auth) {\r\n            return configuration.auth;\r\n        }\r\n        if (Utils.isNode() && nodeStartingContext && nodeStartingContext.gwToken) {\r\n            return {\r\n                gatewayToken: nodeStartingContext.gwToken\r\n            };\r\n        }\r\n        if (((_a = configuration.gateway) === null || _a === void 0 ? void 0 : _a.webPlatform) || ((_b = configuration.gateway) === null || _b === void 0 ? void 0 : _b.inproc) || ((_c = configuration.gateway) === null || _c === void 0 ? void 0 : _c.sharedWorker)) {\r\n            return {\r\n                username: \"glue42\", password: \"glue42\"\r\n            };\r\n        }\r\n    }\r\n    function getLogger() {\r\n        var _a, _b;\r\n        var config = configuration.logger;\r\n        var defaultLevel = \"warn\";\r\n        if (!config) {\r\n            config = defaultLevel;\r\n        }\r\n        var gdConsoleLevel;\r\n        if (glue42gd) {\r\n            gdConsoleLevel = glue42gd.consoleLogLevel;\r\n        }\r\n        if (typeof config === \"string\") {\r\n            return { console: gdConsoleLevel !== null && gdConsoleLevel !== void 0 ? gdConsoleLevel : config, publish: defaultLevel };\r\n        }\r\n        return {\r\n            console: (_a = gdConsoleLevel !== null && gdConsoleLevel !== void 0 ? gdConsoleLevel : config.console) !== null && _a !== void 0 ? _a : defaultLevel,\r\n            publish: (_b = config.publish) !== null && _b !== void 0 ? _b : defaultLevel\r\n        };\r\n    }\r\n    var connection = getConnection();\r\n    var application = getApplication();\r\n    if (typeof window !== \"undefined\") {\r\n        var windowAsAny = window;\r\n        var containerApplication = windowAsAny.htmlContainer ?\r\n            windowAsAny.htmlContainer.containerName + \".\" + windowAsAny.htmlContainer.application : (_a = windowAsAny === null || windowAsAny === void 0 ? void 0 : windowAsAny.glue42gd) === null || _a === void 0 ? void 0 : _a.application;\r\n        if (containerApplication) {\r\n            application = containerApplication;\r\n        }\r\n    }\r\n    return {\r\n        bus: (_b = configuration.bus) !== null && _b !== void 0 ? _b : false,\r\n        application: application,\r\n        auth: getAuth(),\r\n        logger: getLogger(),\r\n        connection: connection,\r\n        metrics: (_c = configuration.metrics) !== null && _c !== void 0 ? _c : true,\r\n        contexts: (_d = configuration.contexts) !== null && _d !== void 0 ? _d : true,\r\n        version: ext.version || version,\r\n        libs: (_e = ext.libs) !== null && _e !== void 0 ? _e : [],\r\n        customLogger: configuration.customLogger\r\n    };\r\n}\n\nvar GW3ContextData = (function () {\r\n    function GW3ContextData(contextId, name, isAnnounced, activityId) {\r\n        this.updateCallbacks = {};\r\n        this.contextId = contextId;\r\n        this.name = name;\r\n        this.isAnnounced = isAnnounced;\r\n        this.activityId = activityId;\r\n        this.context = {};\r\n    }\r\n    GW3ContextData.prototype.hasCallbacks = function () {\r\n        return Object.keys(this.updateCallbacks).length > 0;\r\n    };\r\n    GW3ContextData.prototype.getState = function () {\r\n        if (this.isAnnounced && this.hasCallbacks()) {\r\n            return 3;\r\n        }\r\n        if (this.isAnnounced) {\r\n            return 2;\r\n        }\r\n        if (this.hasCallbacks()) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    };\r\n    return GW3ContextData;\r\n}());\n\nfunction applyContextDelta(context, delta, logger) {\r\n    try {\r\n        if (logger === null || logger === void 0 ? void 0 : logger.canPublish(\"trace\")) {\r\n            logger === null || logger === void 0 ? void 0 : logger.trace(\"applying context delta \" + JSON.stringify(delta) + \" on context \" + JSON.stringify(context));\r\n        }\r\n        if (!delta) {\r\n            return context;\r\n        }\r\n        if (delta.reset) {\r\n            context = __assign({}, delta.reset);\r\n            return context;\r\n        }\r\n        context = deepClone(context, undefined);\r\n        if (delta.commands) {\r\n            for (var _i = 0, _a = delta.commands; _i < _a.length; _i++) {\r\n                var command = _a[_i];\r\n                if (command.type === \"remove\") {\r\n                    deletePath(context, command.path);\r\n                }\r\n                else if (command.type === \"set\") {\r\n                    setValueToPath(context, command.value, command.path);\r\n                }\r\n            }\r\n            return context;\r\n        }\r\n        var added_1 = delta.added;\r\n        var updated_1 = delta.updated;\r\n        var removed = delta.removed;\r\n        if (added_1) {\r\n            Object.keys(added_1).forEach(function (key) {\r\n                context[key] = added_1[key];\r\n            });\r\n        }\r\n        if (updated_1) {\r\n            Object.keys(updated_1).forEach(function (key) {\r\n                mergeObjectsProperties(key, context, updated_1);\r\n            });\r\n        }\r\n        if (removed) {\r\n            removed.forEach(function (key) {\r\n                delete context[key];\r\n            });\r\n        }\r\n        return context;\r\n    }\r\n    catch (e) {\r\n        logger === null || logger === void 0 ? void 0 : logger.error(\"error applying context delta \" + JSON.stringify(delta) + \" on context \" + JSON.stringify(context), e);\r\n        return context;\r\n    }\r\n}\r\nfunction deepClone(obj, hash) {\r\n    hash = hash || new WeakMap();\r\n    if (Object(obj) !== obj) {\r\n        return obj;\r\n    }\r\n    if (obj instanceof Set) {\r\n        return new Set(obj);\r\n    }\r\n    if (hash.has(obj)) {\r\n        return hash.get(obj);\r\n    }\r\n    var result = obj instanceof Date ? new Date(obj)\r\n        : obj instanceof RegExp ? new RegExp(obj.source, obj.flags)\r\n            : obj.constructor ? new obj.constructor()\r\n                : Object.create(null);\r\n    hash.set(obj, result);\r\n    if (obj instanceof Map) {\r\n        Array.from(obj, function (_a) {\r\n            var key = _a[0], val = _a[1];\r\n            return result.set(key, deepClone(val, hash));\r\n        });\r\n    }\r\n    return Object.assign.apply(Object, __spreadArrays([result], Object.keys(obj).map(function (key) {\r\n        var _a;\r\n        return (_a = {}, _a[key] = deepClone(obj[key], hash), _a);\r\n    })));\r\n}\r\nvar mergeObjectsProperties = function (key, what, withWhat) {\r\n    var right = withWhat[key];\r\n    if (right === undefined) {\r\n        return what;\r\n    }\r\n    var left = what[key];\r\n    if (!left || !right) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n    if (typeof left === \"string\" ||\r\n        typeof left === \"number\" ||\r\n        typeof left === \"boolean\" ||\r\n        typeof right === \"string\" ||\r\n        typeof right === \"number\" ||\r\n        typeof right === \"boolean\" ||\r\n        Array.isArray(left) ||\r\n        Array.isArray(right)) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n    what[key] = Object.assign({}, left, right);\r\n    return what;\r\n};\r\nfunction deepEqual(x, y) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    if (!(x instanceof Object) || !(y instanceof Object)) {\r\n        return false;\r\n    }\r\n    if (x.constructor !== y.constructor) {\r\n        return false;\r\n    }\r\n    for (var p in x) {\r\n        if (!x.hasOwnProperty(p)) {\r\n            continue;\r\n        }\r\n        if (!y.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n        if (x[p] === y[p]) {\r\n            continue;\r\n        }\r\n        if (typeof (x[p]) !== \"object\") {\r\n            return false;\r\n        }\r\n        if (!deepEqual(x[p], y[p])) {\r\n            return false;\r\n        }\r\n    }\r\n    for (var p in y) {\r\n        if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction setValueToPath(obj, value, path) {\r\n    var pathArr = path.split(\".\");\r\n    var i;\r\n    for (i = 0; i < pathArr.length - 1; i++) {\r\n        if (!obj[pathArr[i]]) {\r\n            obj[pathArr[i]] = {};\r\n        }\r\n        if (typeof obj[pathArr[i]] !== \"object\") {\r\n            obj[pathArr[i]] = {};\r\n        }\r\n        obj = obj[pathArr[i]];\r\n    }\r\n    obj[pathArr[i]] = value;\r\n}\r\nfunction isSubset(superObj, subObj) {\r\n    return Object.keys(subObj).every(function (ele) {\r\n        if (typeof subObj[ele] === \"object\") {\r\n            return isSubset((superObj === null || superObj === void 0 ? void 0 : superObj[ele]) || {}, subObj[ele] || {});\r\n        }\r\n        return subObj[ele] === (superObj === null || superObj === void 0 ? void 0 : superObj[ele]);\r\n    });\r\n}\r\nfunction deletePath(obj, path) {\r\n    var pathArr = path.split(\".\");\r\n    var i;\r\n    for (i = 0; i < pathArr.length - 1; i++) {\r\n        if (!obj[pathArr[i]]) {\r\n            return;\r\n        }\r\n        obj = obj[pathArr[i]];\r\n    }\r\n    delete obj[pathArr[i]];\r\n}\n\nvar GW3Bridge = (function () {\r\n    function GW3Bridge(config) {\r\n        var _this = this;\r\n        var _a;\r\n        this._contextNameToData = {};\r\n        this._gw3Subscriptions = [];\r\n        this._nextCallbackSubscriptionNumber = 0;\r\n        this._contextNameToId = {};\r\n        this._contextIdToName = {};\r\n        this._protocolVersion = undefined;\r\n        this._connection = config.connection;\r\n        this._logger = config.logger;\r\n        this._gw3Session = this._connection.domain(\"global\", [\r\n            GW_MESSAGE_CONTEXT_CREATED,\r\n            GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            GW_MESSAGE_CONTEXT_DESTROYED,\r\n            GW_MESSAGE_CONTEXT_UPDATED,\r\n        ]);\r\n        this.subscribeToContextCreatedMessages();\r\n        this.subscribeToContextUpdatedMessages();\r\n        this.subscribeToContextDestroyedMessages();\r\n        (_a = this._connection.replayer) === null || _a === void 0 ? void 0 : _a.drain(ContextMessageReplaySpec.name, function (message) {\r\n            var type = message.type;\r\n            if (!type) {\r\n                return;\r\n            }\r\n            if (type === GW_MESSAGE_CONTEXT_CREATED ||\r\n                type === GW_MESSAGE_CONTEXT_ADDED ||\r\n                type === GW_MESSAGE_ACTIVITY_CREATED) {\r\n                _this.handleContextCreatedMessage(message);\r\n            }\r\n            else if (type === GW_MESSAGE_SUBSCRIBED_CONTEXT ||\r\n                type === GW_MESSAGE_CONTEXT_UPDATED ||\r\n                type === GW_MESSAGE_JOINED_ACTIVITY) {\r\n                _this.handleContextUpdatedMessage(message);\r\n            }\r\n            else if (type === GW_MESSAGE_CONTEXT_DESTROYED ||\r\n                type === GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n                _this.handleContextDestroyedMessage(message);\r\n            }\r\n        });\r\n    }\r\n    Object.defineProperty(GW3Bridge.prototype, \"protocolVersion\", {\r\n        get: function () {\r\n            var _a;\r\n            if (!this._protocolVersion) {\r\n                var contextsDomainInfo = this._connection.availableDomains.find(function (d) { return d.uri === \"context\"; });\r\n                this._protocolVersion = (_a = contextsDomainInfo === null || contextsDomainInfo === void 0 ? void 0 : contextsDomainInfo.version) !== null && _a !== void 0 ? _a : 1;\r\n            }\r\n            return this._protocolVersion;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(GW3Bridge.prototype, \"setPathSupported\", {\r\n        get: function () {\r\n            return this.protocolVersion >= 2;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    GW3Bridge.prototype.dispose = function () {\r\n        for (var _i = 0, _a = this._gw3Subscriptions; _i < _a.length; _i++) {\r\n            var sub = _a[_i];\r\n            this._connection.off(sub);\r\n        }\r\n        this._gw3Subscriptions.length = 0;\r\n        for (var contextName in this._contextNameToData) {\r\n            if (this._contextNameToId.hasOwnProperty(contextName)) {\r\n                delete this._contextNameToData[contextName];\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.createContext = function (name, data) {\r\n        var _this = this;\r\n        return this._gw3Session\r\n            .send({\r\n            type: GW_MESSAGE_CREATE_CONTEXT,\r\n            domain: \"global\",\r\n            name: name,\r\n            data: data,\r\n            lifetime: \"retained\",\r\n        })\r\n            .then(function (createContextMsg) {\r\n            _this._contextNameToId[name] = createContextMsg.context_id;\r\n            _this._contextIdToName[createContextMsg.context_id] = name;\r\n            var contextData = _this._contextNameToData[name] || new GW3ContextData(createContextMsg.context_id, name, true, undefined);\r\n            contextData.isAnnounced = true;\r\n            contextData.name = name;\r\n            contextData.contextId = createContextMsg.context_id;\r\n            contextData.context = data;\r\n            _this._contextNameToData[name] = contextData;\r\n            return createContextMsg.context_id;\r\n        });\r\n    };\r\n    GW3Bridge.prototype.all = function () {\r\n        var _this = this;\r\n        return Object.keys(this._contextNameToData)\r\n            .filter(function (name) { return _this._contextNameToData[name].isAnnounced; });\r\n    };\r\n    GW3Bridge.prototype.update = function (name, delta) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var contextData, currentContext, calculatedDelta;\r\n            var _this = this;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        contextData = this._contextNameToData[name];\r\n                        if (!contextData || !contextData.isAnnounced) {\r\n                            return [2, this.createContext(name, delta)];\r\n                        }\r\n                        currentContext = contextData.context;\r\n                        if (!!contextData.hasCallbacks()) return [3, 2];\r\n                        return [4, this.get(contextData.name)];\r\n                    case 1:\r\n                        currentContext = _b.sent();\r\n                        _b.label = 2;\r\n                    case 2:\r\n                        calculatedDelta = this.protocolVersion === 2 ?\r\n                            this.calculateContextDeltaV2(currentContext, delta) :\r\n                            this.calculateContextDeltaV1(currentContext, delta);\r\n                        if (!Object.keys(calculatedDelta.added).length\r\n                            && !Object.keys(calculatedDelta.updated).length\r\n                            && !calculatedDelta.removed.length\r\n                            && !((_a = calculatedDelta.commands) === null || _a === void 0 ? void 0 : _a.length)) {\r\n                            return [2, Promise.resolve()];\r\n                        }\r\n                        return [2, this._gw3Session\r\n                                .send({\r\n                                type: GW_MESSAGE_UPDATE_CONTEXT,\r\n                                domain: \"global\",\r\n                                context_id: contextData.contextId,\r\n                                delta: calculatedDelta,\r\n                            }, {}, { skipPeerId: false })\r\n                                .then(function (gwResponse) {\r\n                                _this.handleUpdated(contextData, calculatedDelta, {\r\n                                    updaterId: gwResponse.peer_id\r\n                                });\r\n                            })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    GW3Bridge.prototype.set = function (name, data) {\r\n        var _this = this;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, data);\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n            type: GW_MESSAGE_UPDATE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n            delta: { reset: data },\r\n        }, {}, { skipPeerId: false })\r\n            .then(function (gwResponse) {\r\n            _this.handleUpdated(contextData, { reset: data, added: {}, removed: [], updated: {} }, { updaterId: gwResponse.peer_id });\r\n        });\r\n    };\r\n    GW3Bridge.prototype.setPath = function (name, path, value) {\r\n        if (!this.setPathSupported) {\r\n            return Promise.reject(\"glue.contexts.setPath operation is not supported, use Glue42 3.10 or later\");\r\n        }\r\n        return this.setPaths(name, [{ path: path, value: value }]);\r\n    };\r\n    GW3Bridge.prototype.setPaths = function (name, pathValues) {\r\n        var _this = this;\r\n        if (!this.setPathSupported) {\r\n            return Promise.reject(\"glue.contexts.setPaths operation is not supported, use Glue42 3.10 or later\");\r\n        }\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            var obj = {};\r\n            for (var _i = 0, pathValues_1 = pathValues; _i < pathValues_1.length; _i++) {\r\n                var pathValue = pathValues_1[_i];\r\n                setValueToPath(obj, pathValue.value, pathValue.path);\r\n            }\r\n            return this.createContext(name, obj);\r\n        }\r\n        var commands = [];\r\n        for (var _a = 0, pathValues_2 = pathValues; _a < pathValues_2.length; _a++) {\r\n            var pathValue = pathValues_2[_a];\r\n            if (pathValue.value === null) {\r\n                commands.push({ type: \"remove\", path: pathValue.path });\r\n            }\r\n            else {\r\n                commands.push({ type: \"set\", path: pathValue.path, value: pathValue.value });\r\n            }\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n            type: GW_MESSAGE_UPDATE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n            delta: { commands: commands }\r\n        }, {}, { skipPeerId: false })\r\n            .then(function (gwResponse) {\r\n            _this.handleUpdated(contextData, { added: {}, removed: [], updated: {}, commands: commands }, { updaterId: gwResponse.peer_id });\r\n        });\r\n    };\r\n    GW3Bridge.prototype.get = function (name) {\r\n        var _this = this;\r\n        var _a;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return Promise.resolve({});\r\n        }\r\n        if (contextData && !contextData.hasCallbacks()) {\r\n            return new Promise(function (resolve, _) { return __awaiter(_this, void 0, void 0, function () {\r\n                var _this = this;\r\n                return __generator(this, function (_a) {\r\n                    this.subscribe(name, function (data, _d, _r, un) {\r\n                        _this.unsubscribe(un);\r\n                        resolve(data);\r\n                    });\r\n                    return [2];\r\n                });\r\n            }); });\r\n        }\r\n        var context = (_a = contextData === null || contextData === void 0 ? void 0 : contextData.context) !== null && _a !== void 0 ? _a : {};\r\n        return Promise.resolve(context);\r\n    };\r\n    GW3Bridge.prototype.subscribe = function (name, callback) {\r\n        var thisCallbackSubscriptionNumber = this._nextCallbackSubscriptionNumber;\r\n        this._nextCallbackSubscriptionNumber += 1;\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData ||\r\n            !contextData.isAnnounced) {\r\n            contextData = contextData || new GW3ContextData(undefined, name, false, undefined);\r\n            this._contextNameToData[name] = contextData;\r\n            contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n        var hadCallbacks = contextData.hasCallbacks();\r\n        contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n        if (!hadCallbacks) {\r\n            if (!contextData.joinedActivity) {\r\n                if (contextData.context && contextData.sentExplicitSubscription) {\r\n                    var clone = deepClone(contextData.context);\r\n                    callback(clone, clone, [], thisCallbackSubscriptionNumber);\r\n                    return Promise.resolve(thisCallbackSubscriptionNumber);\r\n                }\r\n                return this.sendSubscribe(contextData)\r\n                    .then(function () { return thisCallbackSubscriptionNumber; });\r\n            }\r\n            else {\r\n                var clone = deepClone(contextData.context);\r\n                callback(clone, clone, [], thisCallbackSubscriptionNumber);\r\n                return Promise.resolve(thisCallbackSubscriptionNumber);\r\n            }\r\n        }\r\n        else {\r\n            var clone = deepClone(contextData.context);\r\n            callback(clone, clone, [], thisCallbackSubscriptionNumber);\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.unsubscribe = function (subscriptionKey) {\r\n        for (var _i = 0, _a = Object.keys(this._contextNameToData); _i < _a.length; _i++) {\r\n            var name_1 = _a[_i];\r\n            var contextId = this._contextNameToId[name_1];\r\n            var contextData = this._contextNameToData[name_1];\r\n            if (!contextData) {\r\n                return;\r\n            }\r\n            var hadCallbacks = contextData.hasCallbacks();\r\n            delete contextData.updateCallbacks[subscriptionKey];\r\n            if (contextData.isAnnounced &&\r\n                hadCallbacks &&\r\n                !contextData.hasCallbacks() &&\r\n                contextData.sentExplicitSubscription) {\r\n                this.sendUnsubscribe(contextData);\r\n            }\r\n            if (!contextData.isAnnounced &&\r\n                !contextData.hasCallbacks()) {\r\n                delete this._contextNameToData[name_1];\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.destroy = function (name) {\r\n        var contextData = this._contextNameToData[name];\r\n        if (!contextData) {\r\n            return Promise.reject(\"context with \" + name + \" does not exist\");\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n            type: GW_MESSAGE_DESTROY_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n        }).then(function (_) { return undefined; });\r\n    };\r\n    GW3Bridge.prototype.handleUpdated = function (contextData, delta, extraData) {\r\n        var oldContext = contextData.context;\r\n        contextData.context = applyContextDelta(contextData.context, delta, this._logger);\r\n        if (this._contextNameToData[contextData.name] === contextData &&\r\n            !deepEqual(oldContext, contextData.context)) {\r\n            this.invokeUpdateCallbacks(contextData, delta, extraData);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextCreatedMessages = function () {\r\n        var createdMessageTypes = [\r\n            GW_MESSAGE_CONTEXT_ADDED,\r\n            GW_MESSAGE_CONTEXT_CREATED,\r\n            GW_MESSAGE_ACTIVITY_CREATED,\r\n        ];\r\n        for (var _i = 0, createdMessageTypes_1 = createdMessageTypes; _i < createdMessageTypes_1.length; _i++) {\r\n            var createdMessageType = createdMessageTypes_1[_i];\r\n            var sub = this._connection.on(createdMessageType, this.handleContextCreatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextCreatedMessage = function (contextCreatedMsg) {\r\n        var createdMessageType = contextCreatedMsg.type;\r\n        if (createdMessageType === GW_MESSAGE_ACTIVITY_CREATED) {\r\n            this._contextNameToId[contextCreatedMsg.activity_id] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.activity_id;\r\n        }\r\n        else if (createdMessageType === GW_MESSAGE_CONTEXT_ADDED) {\r\n            this._contextNameToId[contextCreatedMsg.name] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.name;\r\n        }\r\n        else ;\r\n        var name = this._contextIdToName[contextCreatedMsg.context_id];\r\n        if (!name) {\r\n            throw new Error(\"Received created event for context with unknown name: \" + contextCreatedMsg.context_id);\r\n        }\r\n        if (!this._contextNameToId[name]) {\r\n            throw new Error(\"Received created event for context with unknown id: \" + contextCreatedMsg.context_id);\r\n        }\r\n        var contextData = this._contextNameToData[name];\r\n        if (contextData) {\r\n            if (contextData.isAnnounced) {\r\n                return;\r\n            }\r\n            else {\r\n                if (!contextData.hasCallbacks()) {\r\n                    throw new Error(\"Assertion failure: contextData.hasCallbacks()\");\r\n                }\r\n                contextData.isAnnounced = true;\r\n                contextData.contextId = contextCreatedMsg.context_id;\r\n                contextData.activityId = contextCreatedMsg.activity_id;\r\n                if (!contextData.sentExplicitSubscription) {\r\n                    this.sendSubscribe(contextData);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._contextNameToData[name] = contextData =\r\n                new GW3ContextData(contextCreatedMsg.context_id, name, true, contextCreatedMsg.activity_id);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextUpdatedMessages = function () {\r\n        var updatedMessageTypes = [\r\n            GW_MESSAGE_CONTEXT_UPDATED,\r\n            GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            GW_MESSAGE_JOINED_ACTIVITY,\r\n        ];\r\n        for (var _i = 0, updatedMessageTypes_1 = updatedMessageTypes; _i < updatedMessageTypes_1.length; _i++) {\r\n            var updatedMessageType = updatedMessageTypes_1[_i];\r\n            var sub = this._connection.on(updatedMessageType, this.handleContextUpdatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextUpdatedMessage = function (contextUpdatedMsg) {\r\n        var updatedMessageType = contextUpdatedMsg.type;\r\n        var contextId = contextUpdatedMsg.context_id;\r\n        var contextData = this._contextNameToData[this._contextIdToName[contextId]];\r\n        var justSeen = !contextData || !contextData.isAnnounced;\r\n        if (updatedMessageType === GW_MESSAGE_JOINED_ACTIVITY) {\r\n            if (!contextData) {\r\n                contextData = new GW3ContextData(contextId, contextUpdatedMsg.activity_id, true, contextUpdatedMsg.activity_id);\r\n                this._contextNameToData[contextUpdatedMsg.activity_id] = contextData;\r\n                this._contextIdToName[contextId] = contextUpdatedMsg.activity_id;\r\n                this._contextNameToId[contextUpdatedMsg.activity_id] = contextId;\r\n            }\r\n            else {\r\n                contextData.contextId = contextId;\r\n                contextData.isAnnounced = true;\r\n                contextData.activityId = contextUpdatedMsg.activity_id;\r\n            }\r\n            contextData.joinedActivity = true;\r\n        }\r\n        else {\r\n            if (!contextData || !contextData.isAnnounced) {\r\n                if (updatedMessageType === GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n                    contextData = contextData || new GW3ContextData(contextId, contextUpdatedMsg.name, true, undefined);\r\n                    contextData.sentExplicitSubscription = true;\r\n                    this._contextNameToData[contextUpdatedMsg.name] = contextData;\r\n                    this._contextIdToName[contextId] = contextUpdatedMsg.name;\r\n                    this._contextNameToId[contextUpdatedMsg.name] = contextId;\r\n                }\r\n                else {\r\n                    this._logger.error(\"Received 'update' for unknown context: \" + contextId);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        var oldContext = contextData.context;\r\n        if (updatedMessageType === GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            contextData.context = contextUpdatedMsg.data || {};\r\n        }\r\n        else if (updatedMessageType === GW_MESSAGE_JOINED_ACTIVITY) {\r\n            contextData.context = contextUpdatedMsg.context_snapshot || {};\r\n        }\r\n        else if (updatedMessageType === GW_MESSAGE_CONTEXT_UPDATED) {\r\n            contextData.context = applyContextDelta(contextData.context, contextUpdatedMsg.delta, this._logger);\r\n        }\r\n        else {\r\n            throw new Error(\"Unrecognized context update message \" + updatedMessageType);\r\n        }\r\n        if (justSeen ||\r\n            !deepEqual(contextData.context, oldContext) ||\r\n            updatedMessageType === GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            this.invokeUpdateCallbacks(contextData, contextUpdatedMsg.delta, { updaterId: contextUpdatedMsg.updater_id });\r\n        }\r\n    };\r\n    GW3Bridge.prototype.invokeUpdateCallbacks = function (contextData, delta, extraData) {\r\n        delta = delta || { added: {}, updated: {}, reset: {}, removed: [] };\r\n        if (delta.commands) {\r\n            delta.added = delta.updated = delta.reset = {};\r\n            delta.removed = [];\r\n            for (var _i = 0, _a = delta.commands; _i < _a.length; _i++) {\r\n                var command = _a[_i];\r\n                if (command.type === \"remove\") {\r\n                    if (command.path.indexOf(\".\") === -1) {\r\n                        delta.removed.push(command.path);\r\n                    }\r\n                    setValueToPath(delta.updated, null, command.path);\r\n                }\r\n                else if (command.type === \"set\") {\r\n                    setValueToPath(delta.updated, command.value, command.path);\r\n                }\r\n            }\r\n        }\r\n        for (var updateCallbackIndex in contextData.updateCallbacks) {\r\n            if (contextData.updateCallbacks.hasOwnProperty(updateCallbackIndex)) {\r\n                try {\r\n                    var updateCallback = contextData.updateCallbacks[updateCallbackIndex];\r\n                    updateCallback(deepClone(contextData.context), Object.assign({}, delta.added || {}, delta.updated || {}, delta.reset || {}), delta.removed, parseInt(updateCallbackIndex, 10), extraData);\r\n                }\r\n                catch (err) {\r\n                    this._logger.debug(\"callback error: \" + JSON.stringify(err));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    GW3Bridge.prototype.subscribeToContextDestroyedMessages = function () {\r\n        var destroyedMessageTypes = [\r\n            GW_MESSAGE_CONTEXT_DESTROYED,\r\n            GW_MESSAGE_ACTIVITY_DESTROYED,\r\n        ];\r\n        for (var _i = 0, destroyedMessageTypes_1 = destroyedMessageTypes; _i < destroyedMessageTypes_1.length; _i++) {\r\n            var destroyedMessageType = destroyedMessageTypes_1[_i];\r\n            var sub = this._connection.on(destroyedMessageType, this.handleContextDestroyedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    };\r\n    GW3Bridge.prototype.handleContextDestroyedMessage = function (destroyedMsg) {\r\n        var destroyedMessageType = destroyedMsg.type;\r\n        var contextId;\r\n        var name;\r\n        if (destroyedMessageType === GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n            name = destroyedMsg.activity_id;\r\n            contextId = this._contextNameToId[name];\r\n            if (!contextId) {\r\n                this._logger.error(\"Received 'destroyed' for unknown activity: \" + destroyedMsg.activity_id);\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            contextId = destroyedMsg.context_id;\r\n            name = this._contextIdToName[contextId];\r\n            if (!name) {\r\n                this._logger.error(\"Received 'destroyed' for unknown context: \" + destroyedMsg.context_id);\r\n                return;\r\n            }\r\n        }\r\n        delete this._contextIdToName[contextId];\r\n        delete this._contextNameToId[name];\r\n        var contextData = this._contextNameToData[name];\r\n        delete this._contextNameToData[name];\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            this._logger.error(\"Received 'destroyed' for unknown context: \" + contextId);\r\n            return;\r\n        }\r\n    };\r\n    GW3Bridge.prototype.sendSubscribe = function (contextData) {\r\n        contextData.sentExplicitSubscription = true;\r\n        return this._gw3Session\r\n            .send({\r\n            type: GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n        }).then(function (_) { return undefined; });\r\n    };\r\n    GW3Bridge.prototype.sendUnsubscribe = function (contextData) {\r\n        contextData.sentExplicitSubscription = false;\r\n        return this._gw3Session\r\n            .send({\r\n            type: GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n            domain: \"global\",\r\n            context_id: contextData.contextId,\r\n        }).then(function (_) { return undefined; });\r\n    };\r\n    GW3Bridge.prototype.calculateContextDeltaV1 = function (from, to) {\r\n        var delta = { added: {}, updated: {}, removed: [], reset: undefined };\r\n        if (from) {\r\n            for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\r\n                var x = _a[_i];\r\n                if (Object.keys(to).indexOf(x) !== -1\r\n                    && to[x] !== null\r\n                    && !deepEqual(from[x], to[x])) {\r\n                    delta.updated[x] = to[x];\r\n                }\r\n            }\r\n        }\r\n        for (var _b = 0, _c = Object.keys(to); _b < _c.length; _b++) {\r\n            var x = _c[_b];\r\n            if (!from || (Object.keys(from).indexOf(x) === -1)) {\r\n                if (to[x] !== null) {\r\n                    delta.added[x] = to[x];\r\n                }\r\n            }\r\n            else if (to[x] === null) {\r\n                delta.removed.push(x);\r\n            }\r\n        }\r\n        return delta;\r\n    };\r\n    GW3Bridge.prototype.calculateContextDeltaV2 = function (from, to) {\r\n        var _a, _b;\r\n        var delta = { added: {}, updated: {}, removed: [], reset: undefined, commands: [] };\r\n        for (var _i = 0, _c = Object.keys(to); _i < _c.length; _i++) {\r\n            var x = _c[_i];\r\n            if (to[x] !== null) {\r\n                var fromX = from ? from[x] : null;\r\n                if (!deepEqual(fromX, to[x])) {\r\n                    (_a = delta.commands) === null || _a === void 0 ? void 0 : _a.push({ type: \"set\", path: x, value: to[x] });\r\n                }\r\n            }\r\n            else {\r\n                (_b = delta.commands) === null || _b === void 0 ? void 0 : _b.push({ type: \"remove\", path: x });\r\n            }\r\n        }\r\n        return delta;\r\n    };\r\n    return GW3Bridge;\r\n}());\n\nvar ContextsModule = (function () {\r\n    function ContextsModule(config) {\r\n        this._bridge = new GW3Bridge(config);\r\n    }\r\n    ContextsModule.prototype.all = function () {\r\n        return this._bridge.all();\r\n    };\r\n    ContextsModule.prototype.update = function (name, data) {\r\n        this.checkName(name);\r\n        this.checkData(data);\r\n        return this._bridge.update(name, data);\r\n    };\r\n    ContextsModule.prototype.set = function (name, data) {\r\n        this.checkName(name);\r\n        this.checkData(data);\r\n        return this._bridge.set(name, data);\r\n    };\r\n    ContextsModule.prototype.setPath = function (name, path, data) {\r\n        this.checkName(name);\r\n        this.checkPath(path);\r\n        var isTopLevelPath = path === \"\";\r\n        if (isTopLevelPath) {\r\n            this.checkData(data);\r\n            return this.set(name, data);\r\n        }\r\n        return this._bridge.setPath(name, path, data);\r\n    };\r\n    ContextsModule.prototype.setPaths = function (name, paths) {\r\n        this.checkName(name);\r\n        if (!Array.isArray(paths)) {\r\n            throw new Error(\"Please provide the paths as an array of PathValues!\");\r\n        }\r\n        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {\r\n            var _a = paths_1[_i], path = _a.path, value = _a.value;\r\n            this.checkPath(path);\r\n            var isTopLevelPath = path === \"\";\r\n            if (isTopLevelPath) {\r\n                this.checkData(value);\r\n            }\r\n        }\r\n        return this._bridge.setPaths(name, paths);\r\n    };\r\n    ContextsModule.prototype.subscribe = function (name, callback) {\r\n        var _this = this;\r\n        this.checkName(name);\r\n        if (typeof callback !== \"function\") {\r\n            throw new Error(\"Please provide the callback as a function!\");\r\n        }\r\n        return this._bridge\r\n            .subscribe(name, function (data, delta, removed, key, extraData) { return callback(data, delta, removed, function () { return _this._bridge.unsubscribe(key); }, extraData); })\r\n            .then(function (key) {\r\n            return function () {\r\n                _this._bridge.unsubscribe(key);\r\n            };\r\n        });\r\n    };\r\n    ContextsModule.prototype.get = function (name) {\r\n        this.checkName(name);\r\n        return this._bridge.get(name);\r\n    };\r\n    ContextsModule.prototype.ready = function () {\r\n        return Promise.resolve(this);\r\n    };\r\n    ContextsModule.prototype.destroy = function (name) {\r\n        this.checkName(name);\r\n        return this._bridge.destroy(name);\r\n    };\r\n    Object.defineProperty(ContextsModule.prototype, \"setPathSupported\", {\r\n        get: function () {\r\n            return this._bridge.setPathSupported;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ContextsModule.prototype.checkName = function (name) {\r\n        if (typeof name !== \"string\" || name === \"\") {\r\n            throw new Error(\"Please provide the name as a non-empty string!\");\r\n        }\r\n    };\r\n    ContextsModule.prototype.checkPath = function (path) {\r\n        if (typeof path !== \"string\") {\r\n            throw new Error(\"Please provide the path as a dot delimited string!\");\r\n        }\r\n    };\r\n    ContextsModule.prototype.checkData = function (data) {\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Please provide the data as an object!\");\r\n        }\r\n    };\r\n    return ContextsModule;\r\n}());\n\nfunction promisify (promise, successCallback, errorCallback) {\r\n    if (typeof successCallback !== \"function\" && typeof errorCallback !== \"function\") {\r\n        return promise;\r\n    }\r\n    if (typeof successCallback !== \"function\") {\r\n        successCallback = function () { };\r\n    }\r\n    else if (typeof errorCallback !== \"function\") {\r\n        errorCallback = function () { };\r\n    }\r\n    return promise.then(successCallback, errorCallback);\r\n}\n\nfunction rejectAfter(ms, promise, error) {\r\n    if (ms === void 0) { ms = 0; }\r\n    var timeout;\r\n    var clearTimeoutIfThere = function () {\r\n        if (timeout) {\r\n            clearTimeout(timeout);\r\n        }\r\n    };\r\n    promise\r\n        .then(function () {\r\n        clearTimeoutIfThere();\r\n    })\r\n        .catch(function () {\r\n        clearTimeoutIfThere();\r\n    });\r\n    return new Promise(function (resolve, reject) {\r\n        timeout = setTimeout(function () { return reject(error); }, ms);\r\n    });\r\n}\n\nvar InvokeStatus;\r\n(function (InvokeStatus) {\r\n    InvokeStatus[InvokeStatus[\"Success\"] = 0] = \"Success\";\r\n    InvokeStatus[InvokeStatus[\"Error\"] = 1] = \"Error\";\r\n})(InvokeStatus || (InvokeStatus = {}));\r\nvar Client = (function () {\r\n    function Client(protocol, repo, instance, configuration) {\r\n        this.protocol = protocol;\r\n        this.repo = repo;\r\n        this.instance = instance;\r\n        this.configuration = configuration;\r\n    }\r\n    Client.prototype.subscribe = function (method, options, successCallback, errorCallback, existingSub) {\r\n        var _this = this;\r\n        var callProtocolSubscribe = function (targetServers, stream, successProxy, errorProxy) {\r\n            var _a;\r\n            options.methodResponseTimeout = (_a = options.methodResponseTimeout) !== null && _a !== void 0 ? _a : options.waitTimeoutMs;\r\n            _this.protocol.client.subscribe(stream, options, targetServers, successProxy, errorProxy, existingSub);\r\n        };\r\n        var promise = new Promise(function (resolve, reject) {\r\n            var successProxy = function (sub) {\r\n                resolve(sub);\r\n            };\r\n            var errorProxy = function (err) {\r\n                reject(err);\r\n            };\r\n            if (!method) {\r\n                reject(\"Method definition is required. Please, provide either a unique string for a method name or a \\u201CmethodDefinition\\u201D object with a required \\u201Cname\\u201D property.\");\r\n                return;\r\n            }\r\n            var methodDef;\r\n            if (typeof method === \"string\") {\r\n                methodDef = { name: method };\r\n            }\r\n            else {\r\n                methodDef = method;\r\n            }\r\n            if (!methodDef.name) {\r\n                reject(\"Method definition is required. Please, provide either a unique string for a method name or a \\u201CmethodDefinition\\u201D object with a required \\u201Cname\\u201D property.\");\r\n                return;\r\n            }\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            var target = options.target;\r\n            if (target === undefined) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\") {\r\n                reject(new Error(\"\\\"\" + target + \"\\\" is not a valid target. Valid targets are \\\"all\\\", \\\"best\\\", or an instance.\"));\r\n                return;\r\n            }\r\n            if (options.methodResponseTimeout === undefined) {\r\n                options.methodResponseTimeout = options.method_response_timeout;\r\n                if (options.methodResponseTimeout === undefined) {\r\n                    options.methodResponseTimeout = _this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n            if (options.waitTimeoutMs === undefined) {\r\n                options.waitTimeoutMs = options.wait_for_method_timeout;\r\n                if (options.waitTimeoutMs === undefined) {\r\n                    options.waitTimeoutMs = _this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n            var delayStep = 500;\r\n            var delayTillNow = 0;\r\n            var currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n            if (currentServers.length > 0) {\r\n                callProtocolSubscribe(currentServers, currentServers[0].methods[0], successProxy, errorProxy);\r\n            }\r\n            else {\r\n                var retry_1 = function () {\r\n                    if (!target || !(options.waitTimeoutMs)) {\r\n                        return;\r\n                    }\r\n                    delayTillNow += delayStep;\r\n                    currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n                    if (currentServers.length > 0) {\r\n                        var streamInfo = currentServers[0].methods[0];\r\n                        callProtocolSubscribe(currentServers, streamInfo, successProxy, errorProxy);\r\n                    }\r\n                    else if (delayTillNow >= options.waitTimeoutMs) {\r\n                        var def = typeof method === \"string\" ? { name: method } : method;\r\n                        callProtocolSubscribe(currentServers, def, successProxy, errorProxy);\r\n                    }\r\n                    else {\r\n                        setTimeout(retry_1, delayStep);\r\n                    }\r\n                };\r\n                setTimeout(retry_1, delayStep);\r\n            }\r\n        });\r\n        return promisify(promise, successCallback, errorCallback);\r\n    };\r\n    Client.prototype.servers = function (methodFilter) {\r\n        var filterCopy = methodFilter === undefined\r\n            ? undefined\r\n            : __assign({}, methodFilter);\r\n        return this.getServers(filterCopy).map(function (serverMethodMap) {\r\n            return serverMethodMap.server.instance;\r\n        });\r\n    };\r\n    Client.prototype.methods = function (methodFilter) {\r\n        if (typeof methodFilter === \"string\") {\r\n            methodFilter = { name: methodFilter };\r\n        }\r\n        else {\r\n            methodFilter = __assign({}, methodFilter);\r\n        }\r\n        return this.getMethods(methodFilter);\r\n    };\r\n    Client.prototype.methodsForInstance = function (instance) {\r\n        return this.getMethodsForInstance(instance);\r\n    };\r\n    Client.prototype.methodAdded = function (callback) {\r\n        return this.repo.onMethodAdded(callback);\r\n    };\r\n    Client.prototype.methodRemoved = function (callback) {\r\n        return this.repo.onMethodRemoved(callback);\r\n    };\r\n    Client.prototype.serverAdded = function (callback) {\r\n        return this.repo.onServerAdded(callback);\r\n    };\r\n    Client.prototype.serverRemoved = function (callback) {\r\n        return this.repo.onServerRemoved(function (server, reason) {\r\n            callback(server, reason);\r\n        });\r\n    };\r\n    Client.prototype.serverMethodAdded = function (callback) {\r\n        return this.repo.onServerMethodAdded(function (server, method) {\r\n            callback({ server: server, method: method });\r\n        });\r\n    };\r\n    Client.prototype.serverMethodRemoved = function (callback) {\r\n        return this.repo.onServerMethodRemoved(function (server, method) {\r\n            callback({ server: server, method: method });\r\n        });\r\n    };\r\n    Client.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var getInvokePromise;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                getInvokePromise = function () { return __awaiter(_this, void 0, void 0, function () {\r\n                    var methodDefinition, serversMethodMap, err_1, method, errorObj, timeout, additionalOptionsCopy, invokePromises, invocationMessages, results, allRejected;\r\n                    var _this = this;\r\n                    var _a, _b, _c;\r\n                    return __generator(this, function (_d) {\r\n                        switch (_d.label) {\r\n                            case 0:\r\n                                if (typeof methodFilter === \"string\") {\r\n                                    methodDefinition = { name: methodFilter };\r\n                                }\r\n                                else {\r\n                                    methodDefinition = __assign({}, methodFilter);\r\n                                }\r\n                                if (!methodDefinition.name) {\r\n                                    return [2, Promise.reject(\"Method definition is required. Please, provide either a unique string for a method name or a \\u201CmethodDefinition\\u201D object with a required \\u201Cname\\u201D property.\")];\r\n                                }\r\n                                if (!argumentObj) {\r\n                                    argumentObj = {};\r\n                                }\r\n                                if (!target) {\r\n                                    target = \"best\";\r\n                                }\r\n                                if (typeof target === \"string\" && target !== \"all\" && target !== \"best\" && target !== \"skipMine\") {\r\n                                    return [2, Promise.reject(new Error(\"\\\"\" + target + \"\\\" is not a valid target. Valid targets are \\\"all\\\" and \\\"best\\\".\"))];\r\n                                }\r\n                                if (!additionalOptions) {\r\n                                    additionalOptions = {};\r\n                                }\r\n                                if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                                    additionalOptions.methodResponseTimeoutMs = additionalOptions.method_response_timeout;\r\n                                    if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                                        additionalOptions.methodResponseTimeoutMs = this.configuration.methodResponseTimeout;\r\n                                    }\r\n                                }\r\n                                if (additionalOptions.waitTimeoutMs === undefined) {\r\n                                    additionalOptions.waitTimeoutMs = additionalOptions.wait_for_method_timeout;\r\n                                    if (additionalOptions.waitTimeoutMs === undefined) {\r\n                                        additionalOptions.waitTimeoutMs = this.configuration.waitTimeoutMs;\r\n                                    }\r\n                                }\r\n                                if (additionalOptions.waitTimeoutMs !== undefined && typeof additionalOptions.waitTimeoutMs !== \"number\") {\r\n                                    return [2, Promise.reject(new Error(\"\\\"\" + additionalOptions.waitTimeoutMs + \"\\\" is not a valid number for \\\"waitTimeoutMs\\\" \"))];\r\n                                }\r\n                                if (typeof argumentObj !== \"object\") {\r\n                                    return [2, Promise.reject(new Error(\"The method arguments must be an object. method: \" + methodDefinition.name))];\r\n                                }\r\n                                serversMethodMap = this.getServerMethodsByFilterAndTarget(methodDefinition, target);\r\n                                if (!(serversMethodMap.length === 0)) return [3, 4];\r\n                                _d.label = 1;\r\n                            case 1:\r\n                                _d.trys.push([1, 3, , 4]);\r\n                                return [4, this.tryToAwaitForMethods(methodDefinition, target, additionalOptions)];\r\n                            case 2:\r\n                                serversMethodMap = _d.sent();\r\n                                return [3, 4];\r\n                            case 3:\r\n                                err_1 = _d.sent();\r\n                                method = __assign(__assign({}, methodDefinition), { getServers: function () { return []; }, supportsStreaming: false, objectTypes: (_a = methodDefinition.objectTypes) !== null && _a !== void 0 ? _a : [], flags: (_c = (_b = methodDefinition.flags) === null || _b === void 0 ? void 0 : _b.metadata) !== null && _c !== void 0 ? _c : {} });\r\n                                errorObj = {\r\n                                    method: method,\r\n                                    called_with: argumentObj,\r\n                                    message: \"Can not find a method matching \" + JSON.stringify(methodFilter) + \" with server filter \" + JSON.stringify(target),\r\n                                    executed_by: undefined,\r\n                                    returned: undefined,\r\n                                    status: undefined,\r\n                                };\r\n                                return [2, Promise.reject(errorObj)];\r\n                            case 4:\r\n                                timeout = additionalOptions.methodResponseTimeoutMs;\r\n                                additionalOptionsCopy = additionalOptions;\r\n                                invokePromises = serversMethodMap.map(function (serversMethodPair) {\r\n                                    var invId = shortid();\r\n                                    var method = serversMethodPair.methods[0];\r\n                                    var server = serversMethodPair.server;\r\n                                    var invokePromise = _this.protocol.client.invoke(invId, method, argumentObj, server, additionalOptionsCopy);\r\n                                    return Promise.race([\r\n                                        invokePromise,\r\n                                        rejectAfter(timeout, invokePromise, {\r\n                                            invocationId: invId,\r\n                                            message: \"Invocation timeout (\" + timeout + \" ms) reached for method name: \" + (method === null || method === void 0 ? void 0 : method.name) + \", target instance: \" + JSON.stringify(server.instance) + \", options: \" + JSON.stringify(additionalOptionsCopy),\r\n                                            status: InvokeStatus.Error,\r\n                                        })\r\n                                    ]);\r\n                                });\r\n                                return [4, Promise.all(invokePromises)];\r\n                            case 5:\r\n                                invocationMessages = _d.sent();\r\n                                results = this.getInvocationResultObj(invocationMessages, methodDefinition, argumentObj);\r\n                                allRejected = invocationMessages.every(function (result) { return result.status === InvokeStatus.Error; });\r\n                                if (allRejected) {\r\n                                    return [2, Promise.reject(results)];\r\n                                }\r\n                                return [2, results];\r\n                        }\r\n                    });\r\n                }); };\r\n                return [2, promisify(getInvokePromise(), success, error)];\r\n            });\r\n        });\r\n    };\r\n    Client.prototype.getInvocationResultObj = function (invocationResults, method, calledWith) {\r\n        var all_return_values = invocationResults\r\n            .filter(function (invokeMessage) { return invokeMessage.status === InvokeStatus.Success; })\r\n            .reduce(function (allValues, currentValue) {\r\n            allValues = __spreadArrays(allValues, [\r\n                {\r\n                    executed_by: currentValue.instance,\r\n                    returned: currentValue.result,\r\n                    called_with: calledWith,\r\n                    method: method,\r\n                    message: currentValue.message,\r\n                    status: currentValue.status,\r\n                }\r\n            ]);\r\n            return allValues;\r\n        }, []);\r\n        var all_errors = invocationResults\r\n            .filter(function (invokeMessage) { return invokeMessage.status === InvokeStatus.Error; })\r\n            .reduce(function (allErrors, currError) {\r\n            allErrors = __spreadArrays(allErrors, [\r\n                {\r\n                    executed_by: currError.instance,\r\n                    called_with: calledWith,\r\n                    name: method.name,\r\n                    message: currError.message,\r\n                }\r\n            ]);\r\n            return allErrors;\r\n        }, []);\r\n        var invResult = invocationResults[0];\r\n        var result = {\r\n            method: method,\r\n            called_with: calledWith,\r\n            returned: invResult.result,\r\n            executed_by: invResult.instance,\r\n            all_return_values: all_return_values,\r\n            all_errors: all_errors,\r\n            message: invResult.message,\r\n            status: invResult.status\r\n        };\r\n        return result;\r\n    };\r\n    Client.prototype.tryToAwaitForMethods = function (methodDefinition, target, additionalOptions) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (additionalOptions.waitTimeoutMs === 0) {\r\n                reject();\r\n                return;\r\n            }\r\n            var delayStep = 500;\r\n            var delayTillNow = 0;\r\n            var retry = function () {\r\n                delayTillNow += delayStep;\r\n                var serversMethodMap = _this.getServerMethodsByFilterAndTarget(methodDefinition, target);\r\n                if (serversMethodMap.length > 0) {\r\n                    clearInterval(interval);\r\n                    resolve(serversMethodMap);\r\n                }\r\n                else if (delayTillNow >= (additionalOptions.waitTimeoutMs || 10000)) {\r\n                    clearInterval(interval);\r\n                    reject();\r\n                    return;\r\n                }\r\n            };\r\n            var interval = setInterval(retry, delayStep);\r\n        });\r\n    };\r\n    Client.prototype.filterByTarget = function (target, serverMethodMap) {\r\n        var _this = this;\r\n        if (typeof target === \"string\") {\r\n            if (target === \"all\") {\r\n                return __spreadArrays(serverMethodMap);\r\n            }\r\n            else if (target === \"best\") {\r\n                var localMachine = serverMethodMap\r\n                    .find(function (s) { return s.server.instance.isLocal; });\r\n                if (localMachine) {\r\n                    return [localMachine];\r\n                }\r\n                if (serverMethodMap[0] !== undefined) {\r\n                    return [serverMethodMap[0]];\r\n                }\r\n            }\r\n            else if (target === \"skipMine\") {\r\n                return serverMethodMap.filter(function (_a) {\r\n                    var server = _a.server;\r\n                    return server.instance.peerId !== _this.instance.peerId;\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            var targetArray = void 0;\r\n            if (!Array.isArray(target)) {\r\n                targetArray = [target];\r\n            }\r\n            else {\r\n                targetArray = target;\r\n            }\r\n            var allServersMatching = targetArray.reduce(function (matches, filter) {\r\n                var myMatches = serverMethodMap.filter(function (serverMethodPair) {\r\n                    return _this.instanceMatch(filter, serverMethodPair.server.instance);\r\n                });\r\n                return matches.concat(myMatches);\r\n            }, []);\r\n            return allServersMatching;\r\n        }\r\n        return [];\r\n    };\r\n    Client.prototype.instanceMatch = function (instanceFilter, instanceDefinition) {\r\n        return this.containsProps(instanceFilter, instanceDefinition);\r\n    };\r\n    Client.prototype.methodMatch = function (methodFilter, methodDefinition) {\r\n        return this.containsProps(methodFilter, methodDefinition);\r\n    };\r\n    Client.prototype.containsProps = function (filter, repoMethod) {\r\n        var filterProps = Object.keys(filter)\r\n            .filter(function (prop) {\r\n            return filter[prop] !== undefined\r\n                && typeof filter[prop] !== \"function\"\r\n                && prop !== \"object_types\"\r\n                && prop !== \"display_name\"\r\n                && prop !== \"id\"\r\n                && prop !== \"gatewayId\"\r\n                && prop !== \"identifier\"\r\n                && prop[0] !== \"_\";\r\n        });\r\n        return filterProps.every(function (prop) {\r\n            var isMatch;\r\n            var filterValue = filter[prop];\r\n            var repoMethodValue = repoMethod[prop];\r\n            switch (prop) {\r\n                case \"objectTypes\":\r\n                    isMatch = (filterValue || []).every(function (filterValueEl) {\r\n                        return (repoMethodValue || []).includes(filterValueEl);\r\n                    });\r\n                    break;\r\n                case \"flags\":\r\n                    isMatch = isSubset(repoMethodValue || {}, filterValue || {});\r\n                    break;\r\n                default:\r\n                    isMatch = String(filterValue).toLowerCase() === String(repoMethodValue).toLowerCase();\r\n            }\r\n            return isMatch;\r\n        });\r\n    };\r\n    Client.prototype.getMethods = function (methodFilter) {\r\n        var _this = this;\r\n        if (methodFilter === undefined) {\r\n            return this.repo.getMethods();\r\n        }\r\n        var methods = this.repo.getMethods().filter(function (method) {\r\n            return _this.methodMatch(methodFilter, method);\r\n        });\r\n        return methods;\r\n    };\r\n    Client.prototype.getMethodsForInstance = function (instanceFilter) {\r\n        var _this = this;\r\n        var allServers = this.repo.getServers();\r\n        var matchingServers = allServers.filter(function (server) {\r\n            return _this.instanceMatch(instanceFilter, server.instance);\r\n        });\r\n        if (matchingServers.length === 0) {\r\n            return [];\r\n        }\r\n        var resultMethodsObject = {};\r\n        if (matchingServers.length === 1) {\r\n            resultMethodsObject = matchingServers[0].methods;\r\n        }\r\n        else {\r\n            matchingServers.forEach(function (server) {\r\n                Object.keys(server.methods).forEach(function (methodKey) {\r\n                    var method = server.methods[methodKey];\r\n                    resultMethodsObject[method.identifier] = method;\r\n                });\r\n            });\r\n        }\r\n        return Object.keys(resultMethodsObject)\r\n            .map(function (key) {\r\n            return resultMethodsObject[key];\r\n        });\r\n    };\r\n    Client.prototype.getServers = function (methodFilter) {\r\n        var _this = this;\r\n        var servers = this.repo.getServers();\r\n        if (methodFilter === undefined) {\r\n            return servers.map(function (server) {\r\n                return { server: server, methods: [] };\r\n            });\r\n        }\r\n        return servers.reduce(function (prev, current) {\r\n            var methodsForServer = Object.values(current.methods);\r\n            var matchingMethods = methodsForServer.filter(function (method) {\r\n                return _this.methodMatch(methodFilter, method);\r\n            });\r\n            if (matchingMethods.length > 0) {\r\n                prev.push({ server: current, methods: matchingMethods });\r\n            }\r\n            return prev;\r\n        }, []);\r\n    };\r\n    Client.prototype.getServerMethodsByFilterAndTarget = function (methodFilter, target) {\r\n        var serversMethodMap = this.getServers(methodFilter);\r\n        return this.filterByTarget(target, serversMethodMap);\r\n    };\r\n    return Client;\r\n}());\n\nvar ServerSubscription = (function () {\r\n    function ServerSubscription(protocol, repoMethod, subscription) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.subscription = subscription;\r\n    }\r\n    Object.defineProperty(ServerSubscription.prototype, \"stream\", {\r\n        get: function () {\r\n            if (!this.repoMethod.stream) {\r\n                throw new Error(\"no stream\");\r\n            }\r\n            return this.repoMethod.stream;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"arguments\", {\r\n        get: function () { return this.subscription.arguments || {}; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"branchKey\", {\r\n        get: function () { return this.subscription.branchKey; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ServerSubscription.prototype, \"instance\", {\r\n        get: function () {\r\n            if (!this.subscription.instance) {\r\n                throw new Error(\"no instance\");\r\n            }\r\n            return this.subscription.instance;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerSubscription.prototype.close = function () {\r\n        this.protocol.server.closeSingleSubscription(this.repoMethod, this.subscription);\r\n    };\r\n    ServerSubscription.prototype.push = function (data) {\r\n        this.protocol.server.pushDataToSingle(this.repoMethod, this.subscription, data);\r\n    };\r\n    return ServerSubscription;\r\n}());\n\nvar Request = (function () {\r\n    function Request(protocol, repoMethod, requestContext) {\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n        this.requestContext = requestContext;\r\n        this.arguments = requestContext.arguments;\r\n        this.instance = requestContext.instance;\r\n    }\r\n    Request.prototype.accept = function () {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, \"\");\r\n    };\r\n    Request.prototype.acceptOnBranch = function (branch) {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, branch);\r\n    };\r\n    Request.prototype.reject = function (reason) {\r\n        this.protocol.server.rejectRequest(this.requestContext, this.repoMethod, reason);\r\n    };\r\n    return Request;\r\n}());\n\nvar ServerStreaming = (function () {\r\n    function ServerStreaming(protocol, server) {\r\n        var _this = this;\r\n        this.protocol = protocol;\r\n        this.server = server;\r\n        protocol.server.onSubRequest(function (rc, rm) { return _this.handleSubRequest(rc, rm); });\r\n        protocol.server.onSubAdded(function (sub, rm) { return _this.handleSubAdded(sub, rm); });\r\n        protocol.server.onSubRemoved(function (sub, rm) { return _this.handleSubRemoved(sub, rm); });\r\n    }\r\n    ServerStreaming.prototype.handleSubRequest = function (requestContext, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRequestHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var request = new Request(this.protocol, repoMethod, requestContext);\r\n        repoMethod.streamCallbacks.subscriptionRequestHandler(request);\r\n    };\r\n    ServerStreaming.prototype.handleSubAdded = function (subscription, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionAddedHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var sub = new ServerSubscription(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionAddedHandler(sub);\r\n    };\r\n    ServerStreaming.prototype.handleSubRemoved = function (subscription, repoMethod) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRemovedHandler === \"function\")) {\r\n            return;\r\n        }\r\n        var sub = new ServerSubscription(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionRemovedHandler(sub);\r\n    };\r\n    return ServerStreaming;\r\n}());\n\nvar ServerBranch = (function () {\r\n    function ServerBranch(key, protocol, repoMethod) {\r\n        this.key = key;\r\n        this.protocol = protocol;\r\n        this.repoMethod = repoMethod;\r\n    }\r\n    ServerBranch.prototype.subscriptions = function () {\r\n        var _this = this;\r\n        var subList = this.protocol.server.getSubscriptionList(this.repoMethod, this.key);\r\n        return subList.map(function (sub) {\r\n            return new ServerSubscription(_this.protocol, _this.repoMethod, sub);\r\n        });\r\n    };\r\n    ServerBranch.prototype.close = function () {\r\n        this.protocol.server.closeAllSubscriptions(this.repoMethod, this.key);\r\n    };\r\n    ServerBranch.prototype.push = function (data) {\r\n        this.protocol.server.pushData(this.repoMethod, data, [this.key]);\r\n    };\r\n    return ServerBranch;\r\n}());\n\nvar ServerStream = (function () {\r\n    function ServerStream(_protocol, _repoMethod, _server) {\r\n        this._protocol = _protocol;\r\n        this._repoMethod = _repoMethod;\r\n        this._server = _server;\r\n        this.name = this._repoMethod.definition.name;\r\n    }\r\n    ServerStream.prototype.branches = function (key) {\r\n        var _this = this;\r\n        var bList = this._protocol.server.getBranchList(this._repoMethod);\r\n        if (key) {\r\n            if (bList.indexOf(key) > -1) {\r\n                return new ServerBranch(key, this._protocol, this._repoMethod);\r\n            }\r\n            return undefined;\r\n        }\r\n        else {\r\n            return bList.map(function (branchKey) {\r\n                return new ServerBranch(branchKey, _this._protocol, _this._repoMethod);\r\n            });\r\n        }\r\n    };\r\n    ServerStream.prototype.branch = function (key) {\r\n        return this.branches(key);\r\n    };\r\n    ServerStream.prototype.subscriptions = function () {\r\n        var _this = this;\r\n        var subList = this._protocol.server.getSubscriptionList(this._repoMethod);\r\n        return subList.map(function (sub) {\r\n            return new ServerSubscription(_this._protocol, _this._repoMethod, sub);\r\n        });\r\n    };\r\n    Object.defineProperty(ServerStream.prototype, \"definition\", {\r\n        get: function () {\r\n            var _a;\r\n            var def2 = this._repoMethod.definition;\r\n            return {\r\n                accepts: def2.accepts,\r\n                description: def2.description,\r\n                displayName: def2.displayName,\r\n                name: def2.name,\r\n                objectTypes: def2.objectTypes,\r\n                returns: def2.returns,\r\n                supportsStreaming: def2.supportsStreaming,\r\n                flags: (_a = def2.flags) === null || _a === void 0 ? void 0 : _a.metadata,\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ServerStream.prototype.close = function () {\r\n        this._protocol.server.closeAllSubscriptions(this._repoMethod);\r\n        this._server.unregister(this._repoMethod.definition, true);\r\n    };\r\n    ServerStream.prototype.push = function (data, branches) {\r\n        if (typeof branches !== \"string\" && !Array.isArray(branches) && branches !== undefined) {\r\n            throw new Error(\"invalid branches should be string or string array\");\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        this._protocol.server.pushData(this._repoMethod, data, branches);\r\n    };\r\n    ServerStream.prototype.updateRepoMethod = function (repoMethod) {\r\n        this._repoMethod = repoMethod;\r\n    };\r\n    return ServerStream;\r\n}());\n\nvar Server = (function () {\r\n    function Server(protocol, serverRepository) {\r\n        this.protocol = protocol;\r\n        this.serverRepository = serverRepository;\r\n        this.invocations = 0;\r\n        this.currentlyUnregistering = {};\r\n        this.streaming = new ServerStreaming(protocol, this);\r\n        this.protocol.server.onInvoked(this.onMethodInvoked.bind(this));\r\n    }\r\n    Server.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback, existingStream) {\r\n        var _this = this;\r\n        var promise = new Promise(function (resolve, reject) {\r\n            if (!streamDef) {\r\n                reject(\"The stream name must be unique! Please, provide either a unique string for a stream name to \\u201Cglue.interop.createStream()\\u201D or a \\u201CmethodDefinition\\u201D object with a unique \\u201Cname\\u201D property for the stream.\");\r\n                return;\r\n            }\r\n            var streamMethodDefinition;\r\n            if (typeof streamDef === \"string\") {\r\n                streamMethodDefinition = { name: \"\" + streamDef };\r\n            }\r\n            else {\r\n                streamMethodDefinition = __assign({}, streamDef);\r\n            }\r\n            if (!streamMethodDefinition.name) {\r\n                return reject(\"The \\u201Cname\\u201D property is required for the \\u201CstreamDefinition\\u201D object and must be unique. Stream definition: \" + JSON.stringify(streamMethodDefinition));\r\n            }\r\n            var nameAlreadyExists = _this.serverRepository.getList()\r\n                .some(function (serverMethod) { return serverMethod.definition.name === streamMethodDefinition.name; });\r\n            if (nameAlreadyExists) {\r\n                return reject(\"A stream with the name \\\"\" + streamMethodDefinition.name + \"\\\" already exists! Please, provide a unique name for the stream.\");\r\n            }\r\n            streamMethodDefinition.supportsStreaming = true;\r\n            if (!callbacks) {\r\n                callbacks = {};\r\n            }\r\n            if (typeof callbacks.subscriptionRequestHandler !== \"function\") {\r\n                callbacks.subscriptionRequestHandler = function (request) {\r\n                    request.accept();\r\n                };\r\n            }\r\n            var repoMethod = _this.serverRepository.add({\r\n                definition: streamMethodDefinition,\r\n                streamCallbacks: callbacks,\r\n                protocolState: {},\r\n            });\r\n            _this.protocol.server.createStream(repoMethod)\r\n                .then(function () {\r\n                var streamUserObject;\r\n                if (existingStream) {\r\n                    streamUserObject = existingStream;\r\n                    existingStream.updateRepoMethod(repoMethod);\r\n                }\r\n                else {\r\n                    streamUserObject = new ServerStream(_this.protocol, repoMethod, _this);\r\n                }\r\n                repoMethod.stream = streamUserObject;\r\n                resolve(streamUserObject);\r\n            })\r\n                .catch(function (err) {\r\n                if (repoMethod.repoId) {\r\n                    _this.serverRepository.remove(repoMethod.repoId);\r\n                }\r\n                reject(err);\r\n            });\r\n        });\r\n        return promisify(promise, successCallback, errorCallback);\r\n    };\r\n    Server.prototype.register = function (methodDefinition, callback) {\r\n        var _this = this;\r\n        if (!methodDefinition) {\r\n            return Promise.reject(\"Method definition is required. Please, provide either a unique string for a method name or a \\u201CmethodDefinition\\u201D object with a required \\u201Cname\\u201D property.\");\r\n        }\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(\"The second parameter must be a callback function. Method: \" + (typeof methodDefinition === \"string\" ? methodDefinition : methodDefinition.name));\r\n        }\r\n        var wrappedCallbackFunction = function (context, resultCallback) { return __awaiter(_this, void 0, void 0, function () {\r\n            var result, resultValue, e_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 4, , 5]);\r\n                        result = callback(context.args, context.instance);\r\n                        if (!(result && typeof result.then === \"function\")) return [3, 2];\r\n                        return [4, result];\r\n                    case 1:\r\n                        resultValue = _a.sent();\r\n                        resultCallback(undefined, resultValue);\r\n                        return [3, 3];\r\n                    case 2:\r\n                        resultCallback(undefined, result);\r\n                        _a.label = 3;\r\n                    case 3: return [3, 5];\r\n                    case 4:\r\n                        e_1 = _a.sent();\r\n                        if (!e_1) {\r\n                            e_1 = \"\";\r\n                        }\r\n                        resultCallback(e_1, e_1);\r\n                        return [3, 5];\r\n                    case 5: return [2];\r\n                }\r\n            });\r\n        }); };\r\n        wrappedCallbackFunction.userCallback = callback;\r\n        return this.registerCore(methodDefinition, wrappedCallbackFunction);\r\n    };\r\n    Server.prototype.registerAsync = function (methodDefinition, callback) {\r\n        if (!methodDefinition) {\r\n            return Promise.reject(\"Method definition is required. Please, provide either a unique string for a method name or a \\u201CmethodDefinition\\u201D object with a required \\u201Cname\\u201D property.\");\r\n        }\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(\"The second parameter must be a callback function. Method: \" + (typeof methodDefinition === \"string\" ? methodDefinition : methodDefinition.name));\r\n        }\r\n        var wrappedCallback = function (context, resultCallback) {\r\n            try {\r\n                var resultCalled_1 = false;\r\n                var success = function (result) {\r\n                    if (!resultCalled_1) {\r\n                        resultCallback(undefined, result);\r\n                    }\r\n                    resultCalled_1 = true;\r\n                };\r\n                var error = function (e) {\r\n                    if (!resultCalled_1) {\r\n                        if (!e) {\r\n                            e = \"\";\r\n                        }\r\n                        resultCallback(e, e);\r\n                    }\r\n                    resultCalled_1 = true;\r\n                };\r\n                var methodResult = callback(context.args, context.instance, success, error);\r\n                if (methodResult && typeof methodResult.then === \"function\") {\r\n                    methodResult\r\n                        .then(success)\r\n                        .catch(error);\r\n                }\r\n            }\r\n            catch (e) {\r\n                resultCallback(e, undefined);\r\n            }\r\n        };\r\n        wrappedCallback.userCallbackAsync = callback;\r\n        return this.registerCore(methodDefinition, wrappedCallback);\r\n    };\r\n    Server.prototype.unregister = function (methodFilter, forStream) {\r\n        if (forStream === void 0) { forStream = false; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodDefinition, methodToBeRemoved;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (methodFilter === undefined) {\r\n                            return [2, Promise.reject(\"Please, provide either a unique string for a name or an object containing a \\u201Cname\\u201D property.\")];\r\n                        }\r\n                        if (!(typeof methodFilter === \"function\")) return [3, 2];\r\n                        return [4, this.unregisterWithPredicate(methodFilter, forStream)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                    case 2:\r\n                        if (typeof methodFilter === \"string\") {\r\n                            methodDefinition = { name: methodFilter };\r\n                        }\r\n                        else {\r\n                            methodDefinition = methodFilter;\r\n                        }\r\n                        if (methodDefinition.name === undefined) {\r\n                            return [2, Promise.reject(\"Method name is required. Cannot find a method if the method name is undefined!\")];\r\n                        }\r\n                        methodToBeRemoved = this.serverRepository.getList().find(function (serverMethod) {\r\n                            return serverMethod.definition.name === methodDefinition.name\r\n                                && (serverMethod.definition.supportsStreaming || false) === forStream;\r\n                        });\r\n                        if (!methodToBeRemoved) {\r\n                            return [2, Promise.reject(\"Method with a name \\\"\" + methodDefinition.name + \"\\\" does not exist or is not registered by your application!\")];\r\n                        }\r\n                        return [4, this.removeMethodsOrStreams([methodToBeRemoved])];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.unregisterWithPredicate = function (filterPredicate, forStream) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodsOrStreamsToRemove;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        methodsOrStreamsToRemove = this.serverRepository.getList()\r\n                            .filter(function (sm) { return filterPredicate(sm.definition); })\r\n                            .filter(function (serverMethod) {\r\n                            return (serverMethod.definition.supportsStreaming || false) === forStream;\r\n                        });\r\n                        if (!methodsOrStreamsToRemove || methodsOrStreamsToRemove.length === 0) {\r\n                            return [2, Promise.reject(\"Could not find a \" + (forStream ? \"stream\" : \"method\") + \" matching the specified condition!\")];\r\n                        }\r\n                        return [4, this.removeMethodsOrStreams(methodsOrStreamsToRemove)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.removeMethodsOrStreams = function (methodsToRemove) {\r\n        var _this = this;\r\n        var methodUnregPromises = [];\r\n        methodsToRemove.forEach(function (method) {\r\n            var promise = _this.protocol.server.unregister(method)\r\n                .then(function () {\r\n                if (method.repoId) {\r\n                    _this.serverRepository.remove(method.repoId);\r\n                }\r\n            });\r\n            methodUnregPromises.push(promise);\r\n            _this.addAsCurrentlyUnregistering(method.definition.name, promise);\r\n        });\r\n        return Promise.all(methodUnregPromises);\r\n    };\r\n    Server.prototype.addAsCurrentlyUnregistering = function (methodName, promise) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var timeout;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                timeout = new Promise(function (resolve) { return setTimeout(resolve, 5000); });\r\n                this.currentlyUnregistering[methodName] = Promise.race([promise, timeout]).then(function () {\r\n                    delete _this.currentlyUnregistering[methodName];\r\n                });\r\n                return [2];\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.registerCore = function (method, theFunction) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var methodDefinition, unregisterInProgress, nameAlreadyExists, repoMethod;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (typeof method === \"string\") {\r\n                            methodDefinition = { name: \"\" + method };\r\n                        }\r\n                        else {\r\n                            methodDefinition = __assign({}, method);\r\n                        }\r\n                        if (!methodDefinition.name) {\r\n                            return [2, Promise.reject(\"Please, provide a (unique) string value for the \\u201Cname\\u201D property in the \\u201CmethodDefinition\\u201D object: \" + JSON.stringify(method))];\r\n                        }\r\n                        unregisterInProgress = this.currentlyUnregistering[methodDefinition.name];\r\n                        if (!unregisterInProgress) return [3, 2];\r\n                        return [4, unregisterInProgress];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        nameAlreadyExists = this.serverRepository.getList()\r\n                            .some(function (serverMethod) { return serverMethod.definition.name === methodDefinition.name; });\r\n                        if (nameAlreadyExists) {\r\n                            return [2, Promise.reject(\"A method with the name \\\"\" + methodDefinition.name + \"\\\" already exists! Please, provide a unique name for the method.\")];\r\n                        }\r\n                        if (methodDefinition.supportsStreaming) {\r\n                            return [2, Promise.reject(\"When you create methods with \\u201Cglue.interop.register()\\u201D or \\u201Cglue.interop.registerAsync()\\u201D the property \\u201CsupportsStreaming\\u201D cannot be \\u201Ctrue\\u201D. If you want \\u201C\" + methodDefinition.name + \"\\u201D to be a stream, please use the \\u201Cglue.interop.createStream()\\u201D method.\")];\r\n                        }\r\n                        repoMethod = this.serverRepository.add({\r\n                            definition: methodDefinition,\r\n                            theFunction: theFunction,\r\n                            protocolState: {},\r\n                        });\r\n                        return [2, this.protocol.server.register(repoMethod)\r\n                                .catch(function (err) {\r\n                                if (repoMethod === null || repoMethod === void 0 ? void 0 : repoMethod.repoId) {\r\n                                    _this.serverRepository.remove(repoMethod.repoId);\r\n                                }\r\n                                throw err;\r\n                            })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Server.prototype.onMethodInvoked = function (methodToExecute, invocationId, invocationArgs) {\r\n        var _this = this;\r\n        if (!methodToExecute || !methodToExecute.theFunction) {\r\n            return;\r\n        }\r\n        methodToExecute.theFunction(invocationArgs, function (err, result) {\r\n            if (err !== undefined && err !== null) {\r\n                if (err.message && typeof err.message === \"string\") {\r\n                    err = err.message;\r\n                }\r\n                else if (typeof err !== \"string\") {\r\n                    try {\r\n                        err = JSON.stringify(err);\r\n                    }\r\n                    catch (unStrException) {\r\n                        err = \"un-stringifyable error in onMethodInvoked! Top level prop names: \" + Object.keys(err);\r\n                    }\r\n                }\r\n            }\r\n            if (!result) {\r\n                result = {};\r\n            }\r\n            else if (typeof result !== \"object\" || Array.isArray(result)) {\r\n                result = { _value: result };\r\n            }\r\n            _this.protocol.server.methodInvocationResult(methodToExecute, invocationId, err, result);\r\n        });\r\n    };\r\n    return Server;\r\n}());\n\nvar InstanceWrapper = (function () {\r\n    function InstanceWrapper(API, instance, connection) {\r\n        var _this = this;\r\n        this.wrapped = {};\r\n        this.wrapped.getMethods = function () {\r\n            return API.methodsForInstance(this);\r\n        };\r\n        this.wrapped.getStreams = function () {\r\n            return API.methodsForInstance(this).filter(function (m) { return m.supportsStreaming; });\r\n        };\r\n        if (instance) {\r\n            this.refreshWrappedObject(instance);\r\n        }\r\n        if (connection) {\r\n            connection.loggedIn(function () {\r\n                _this.refresh(connection);\r\n            });\r\n            this.refresh(connection);\r\n        }\r\n    }\r\n    InstanceWrapper.prototype.unwrap = function () {\r\n        return this.wrapped;\r\n    };\r\n    InstanceWrapper.prototype.refresh = function (connection) {\r\n        if (!connection) {\r\n            return;\r\n        }\r\n        var resolvedIdentity = connection === null || connection === void 0 ? void 0 : connection.resolvedIdentity;\r\n        var instance = Object.assign({}, resolvedIdentity !== null && resolvedIdentity !== void 0 ? resolvedIdentity : {}, { peerId: connection === null || connection === void 0 ? void 0 : connection.peerId });\r\n        this.refreshWrappedObject(instance);\r\n    };\r\n    InstanceWrapper.prototype.refreshWrappedObject = function (resolvedIdentity) {\r\n        var _a, _b, _c, _d;\r\n        this.wrapped.user = resolvedIdentity.user;\r\n        this.wrapped.instance = resolvedIdentity.instance;\r\n        this.wrapped.application = (_a = resolvedIdentity.application) !== null && _a !== void 0 ? _a : shortid();\r\n        this.wrapped.applicationName = resolvedIdentity.applicationName;\r\n        this.wrapped.pid = (_c = (_b = resolvedIdentity.pid) !== null && _b !== void 0 ? _b : resolvedIdentity.process) !== null && _c !== void 0 ? _c : Math.floor(Math.random() * 10000000000);\r\n        this.wrapped.machine = resolvedIdentity.machine;\r\n        this.wrapped.environment = resolvedIdentity.environment;\r\n        this.wrapped.region = resolvedIdentity.region;\r\n        this.wrapped.windowId = resolvedIdentity.windowId;\r\n        this.wrapped.isLocal = (_d = resolvedIdentity.isLocal) !== null && _d !== void 0 ? _d : true;\r\n        this.wrapped.api = resolvedIdentity.api;\r\n        this.wrapped.service = resolvedIdentity.service;\r\n        this.wrapped.peerId = resolvedIdentity.peerId;\r\n    };\r\n    return InstanceWrapper;\r\n}());\n\nvar hideMethodSystemFlags = function (method) {\r\n    return __assign(__assign({}, method), { flags: method.flags.metadata || {} });\r\n};\r\nvar ClientRepository = (function () {\r\n    function ClientRepository(logger, API) {\r\n        this.logger = logger;\r\n        this.API = API;\r\n        this.servers = {};\r\n        this.methodsCount = {};\r\n        this.callbacks = lib();\r\n        var peerId = this.API.instance.peerId;\r\n        this.myServer = {\r\n            id: peerId,\r\n            methods: {},\r\n            instance: this.API.instance,\r\n            wrapper: this.API.unwrappedInstance,\r\n        };\r\n        this.servers[peerId] = this.myServer;\r\n    }\r\n    ClientRepository.prototype.addServer = function (info, serverId) {\r\n        this.logger.debug(\"adding server \" + serverId);\r\n        var current = this.servers[serverId];\r\n        if (current) {\r\n            return current.id;\r\n        }\r\n        var wrapper = new InstanceWrapper(this.API, info);\r\n        var serverEntry = {\r\n            id: serverId,\r\n            methods: {},\r\n            instance: wrapper.unwrap(),\r\n            wrapper: wrapper,\r\n        };\r\n        this.servers[serverId] = serverEntry;\r\n        this.callbacks.execute(\"onServerAdded\", serverEntry.instance);\r\n        return serverId;\r\n    };\r\n    ClientRepository.prototype.removeServerById = function (id, reason) {\r\n        var _this = this;\r\n        var server = this.servers[id];\r\n        if (!server) {\r\n            this.logger.warn(\"not aware of server \" + id + \", my state \" + JSON.stringify(Object.keys(this.servers)));\r\n            return;\r\n        }\r\n        else {\r\n            this.logger.debug(\"removing server \" + id);\r\n        }\r\n        Object.keys(server.methods).forEach(function (methodId) {\r\n            _this.removeServerMethod(id, methodId);\r\n        });\r\n        delete this.servers[id];\r\n        this.callbacks.execute(\"onServerRemoved\", server.instance, reason);\r\n    };\r\n    ClientRepository.prototype.addServerMethod = function (serverId, method) {\r\n        var _a;\r\n        var server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n        if (server.methods[method.id]) {\r\n            return;\r\n        }\r\n        var identifier = this.createMethodIdentifier(method);\r\n        var that = this;\r\n        var methodDefinition = {\r\n            identifier: identifier,\r\n            gatewayId: method.id,\r\n            name: method.name,\r\n            displayName: method.display_name,\r\n            description: method.description,\r\n            version: method.version,\r\n            objectTypes: method.object_types || [],\r\n            accepts: method.input_signature,\r\n            returns: method.result_signature,\r\n            supportsStreaming: typeof method.flags !== \"undefined\" ? method.flags.streaming : false,\r\n            flags: (_a = method.flags) !== null && _a !== void 0 ? _a : {},\r\n            getServers: function () {\r\n                return that.getServersByMethod(identifier);\r\n            }\r\n        };\r\n        methodDefinition.object_types = methodDefinition.objectTypes;\r\n        methodDefinition.display_name = methodDefinition.displayName;\r\n        methodDefinition.version = methodDefinition.version;\r\n        server.methods[method.id] = methodDefinition;\r\n        var clientMethodDefinition = hideMethodSystemFlags(methodDefinition);\r\n        if (!this.methodsCount[identifier]) {\r\n            this.methodsCount[identifier] = 0;\r\n            this.callbacks.execute(\"onMethodAdded\", clientMethodDefinition);\r\n        }\r\n        this.methodsCount[identifier] = this.methodsCount[identifier] + 1;\r\n        this.callbacks.execute(\"onServerMethodAdded\", server.instance, clientMethodDefinition);\r\n        return methodDefinition;\r\n    };\r\n    ClientRepository.prototype.removeServerMethod = function (serverId, methodId) {\r\n        var server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n        var method = server.methods[methodId];\r\n        delete server.methods[methodId];\r\n        var clientMethodDefinition = hideMethodSystemFlags(method);\r\n        this.methodsCount[method.identifier] = this.methodsCount[method.identifier] - 1;\r\n        if (this.methodsCount[method.identifier] === 0) {\r\n            this.callbacks.execute(\"onMethodRemoved\", clientMethodDefinition);\r\n        }\r\n        this.callbacks.execute(\"onServerMethodRemoved\", server.instance, clientMethodDefinition);\r\n    };\r\n    ClientRepository.prototype.getMethods = function () {\r\n        return this.extractMethodsFromServers(Object.values(this.servers)).map(hideMethodSystemFlags);\r\n    };\r\n    ClientRepository.prototype.getServers = function () {\r\n        return Object.values(this.servers).map(this.hideServerMethodSystemFlags);\r\n    };\r\n    ClientRepository.prototype.onServerAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerAdded\", callback);\r\n        var serversWithMethodsToReplay = this.getServers().map(function (s) { return s.instance; });\r\n        return this.returnUnsubWithDelayedReplay(unsubscribeFunc, serversWithMethodsToReplay, callback);\r\n    };\r\n    ClientRepository.prototype.onMethodAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onMethodAdded\", callback);\r\n        var methodsToReplay = this.getMethods();\r\n        return this.returnUnsubWithDelayedReplay(unsubscribeFunc, methodsToReplay, callback);\r\n    };\r\n    ClientRepository.prototype.onServerMethodAdded = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerMethodAdded\", callback);\r\n        var unsubCalled = false;\r\n        var servers = this.getServers();\r\n        setTimeout(function () {\r\n            servers.forEach(function (server) {\r\n                var methods = server.methods;\r\n                Object.keys(methods).forEach(function (methodId) {\r\n                    if (!unsubCalled) {\r\n                        callback(server.instance, methods[methodId]);\r\n                    }\r\n                });\r\n            });\r\n        }, 0);\r\n        return function () {\r\n            unsubCalled = true;\r\n            unsubscribeFunc();\r\n        };\r\n    };\r\n    ClientRepository.prototype.onMethodRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onMethodRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.onServerMethodRemoved = function (callback) {\r\n        var unsubscribeFunc = this.callbacks.add(\"onServerMethodRemoved\", callback);\r\n        return unsubscribeFunc;\r\n    };\r\n    ClientRepository.prototype.getServerById = function (id) {\r\n        return this.hideServerMethodSystemFlags(this.servers[id]);\r\n    };\r\n    ClientRepository.prototype.reset = function () {\r\n        var _a;\r\n        var _this = this;\r\n        Object.keys(this.servers).forEach(function (key) {\r\n            _this.removeServerById(key, \"reset\");\r\n        });\r\n        this.servers = (_a = {},\r\n            _a[this.myServer.id] = this.myServer,\r\n            _a);\r\n        this.methodsCount = {};\r\n    };\r\n    ClientRepository.prototype.createMethodIdentifier = function (methodInfo) {\r\n        var accepts = methodInfo.input_signature !== undefined ? methodInfo.input_signature : \"\";\r\n        var returns = methodInfo.result_signature !== undefined ? methodInfo.result_signature : \"\";\r\n        return (methodInfo.name + accepts + returns).toLowerCase();\r\n    };\r\n    ClientRepository.prototype.getServersByMethod = function (identifier) {\r\n        var allServers = [];\r\n        Object.values(this.servers).forEach(function (server) {\r\n            Object.values(server.methods).forEach(function (method) {\r\n                if (method.identifier === identifier) {\r\n                    allServers.push(server.instance);\r\n                }\r\n            });\r\n        });\r\n        return allServers;\r\n    };\r\n    ClientRepository.prototype.returnUnsubWithDelayedReplay = function (unsubscribeFunc, collectionToReplay, callback) {\r\n        var unsubCalled = false;\r\n        setTimeout(function () {\r\n            collectionToReplay.forEach(function (item) {\r\n                if (!unsubCalled) {\r\n                    callback(item);\r\n                }\r\n            });\r\n        }, 0);\r\n        return function () {\r\n            unsubCalled = true;\r\n            unsubscribeFunc();\r\n        };\r\n    };\r\n    ClientRepository.prototype.hideServerMethodSystemFlags = function (server) {\r\n        var clientMethods = {};\r\n        Object.entries(server.methods).forEach(function (_a) {\r\n            var name = _a[0], method = _a[1];\r\n            clientMethods[name] = hideMethodSystemFlags(method);\r\n        });\r\n        return __assign(__assign({}, server), { methods: clientMethods });\r\n    };\r\n    ClientRepository.prototype.extractMethodsFromServers = function (servers) {\r\n        var methods = Object.values(servers).reduce(function (clientMethods, server) {\r\n            return __spreadArrays(clientMethods, Object.values(server.methods));\r\n        }, []);\r\n        return methods;\r\n    };\r\n    return ClientRepository;\r\n}());\n\nvar ServerRepository = (function () {\r\n    function ServerRepository() {\r\n        this.nextId = 0;\r\n        this.methods = [];\r\n    }\r\n    ServerRepository.prototype.add = function (method) {\r\n        method.repoId = String(this.nextId);\r\n        this.nextId += 1;\r\n        this.methods.push(method);\r\n        return method;\r\n    };\r\n    ServerRepository.prototype.remove = function (repoId) {\r\n        if (typeof repoId !== \"string\") {\r\n            return new TypeError(\"Expecting a string\");\r\n        }\r\n        this.methods = this.methods.filter(function (m) {\r\n            return m.repoId !== repoId;\r\n        });\r\n    };\r\n    ServerRepository.prototype.getById = function (id) {\r\n        if (typeof id !== \"string\") {\r\n            return undefined;\r\n        }\r\n        return this.methods.find(function (m) {\r\n            return m.repoId === id;\r\n        });\r\n    };\r\n    ServerRepository.prototype.getList = function () {\r\n        return this.methods.map(function (m) { return m; });\r\n    };\r\n    ServerRepository.prototype.length = function () {\r\n        return this.methods.length;\r\n    };\r\n    ServerRepository.prototype.reset = function () {\r\n        this.methods = [];\r\n    };\r\n    return ServerRepository;\r\n}());\n\nvar SUBSCRIPTION_REQUEST = \"onSubscriptionRequest\";\r\nvar SUBSCRIPTION_ADDED = \"onSubscriptionAdded\";\r\nvar SUBSCRIPTION_REMOVED = \"onSubscriptionRemoved\";\r\nvar ServerStreaming$1 = (function () {\r\n    function ServerStreaming(session, repository, serverRepository) {\r\n        var _this = this;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.serverRepository = serverRepository;\r\n        this.ERR_URI_SUBSCRIPTION_FAILED = \"com.tick42.agm.errors.subscription.failure\";\r\n        this.callbacks = lib();\r\n        this.nextStreamId = 0;\r\n        session.on(\"add-interest\", function (msg) {\r\n            _this.handleAddInterest(msg);\r\n        });\r\n        session.on(\"remove-interest\", function (msg) {\r\n            _this.handleRemoveInterest(msg);\r\n        });\r\n    }\r\n    ServerStreaming.prototype.acceptRequestOnBranch = function (requestContext, streamingMethod, branch) {\r\n        if (typeof branch !== \"string\") {\r\n            branch = \"\";\r\n        }\r\n        if (typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            throw new TypeError(\"The streaming method is missing its subscriptions.\");\r\n        }\r\n        if (!Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            throw new TypeError(\"The streaming method is missing its branches.\");\r\n        }\r\n        var streamId = this.getStreamId(streamingMethod, branch);\r\n        var key = requestContext.msg.subscription_id;\r\n        var subscription = {\r\n            id: key,\r\n            arguments: requestContext.arguments,\r\n            instance: requestContext.instance,\r\n            branchKey: branch,\r\n            streamId: streamId,\r\n            subscribeMsg: requestContext.msg,\r\n        };\r\n        streamingMethod.protocolState.subscriptionsMap[key] = subscription;\r\n        this.session.sendFireAndForget({\r\n            type: \"accepted\",\r\n            subscription_id: key,\r\n            stream_id: streamId,\r\n        });\r\n        this.callbacks.execute(SUBSCRIPTION_ADDED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.rejectRequest = function (requestContext, streamingMethod, reason) {\r\n        if (typeof reason !== \"string\") {\r\n            reason = \"\";\r\n        }\r\n        this.sendSubscriptionFailed(\"Subscription rejected by user. \" + reason, requestContext.msg.subscription_id);\r\n    };\r\n    ServerStreaming.prototype.pushData = function (streamingMethod, data, branches) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        if (typeof branches === \"string\") {\r\n            branches = [branches];\r\n        }\r\n        else if (!Array.isArray(branches) || branches.length <= 0) {\r\n            branches = [];\r\n        }\r\n        var streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap\r\n            .filter(function (br) {\r\n            if (!branches || branches.length === 0) {\r\n                return true;\r\n            }\r\n            return branches.indexOf(br.key) >= 0;\r\n        }).map(function (br) {\r\n            return br.streamId;\r\n        });\r\n        streamIdList.forEach(function (streamId) {\r\n            var publishMessage = {\r\n                type: \"publish\",\r\n                stream_id: streamId,\r\n                data: data,\r\n            };\r\n            _this.session.sendFireAndForget(publishMessage);\r\n        });\r\n    };\r\n    ServerStreaming.prototype.pushDataToSingle = function (method, subscription, data) {\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        var postMessage = {\r\n            type: \"post\",\r\n            subscription_id: subscription.id,\r\n            data: data,\r\n        };\r\n        this.session.sendFireAndForget(postMessage);\r\n    };\r\n    ServerStreaming.prototype.closeSingleSubscription = function (streamingMethod, subscription) {\r\n        if (streamingMethod.protocolState.subscriptionsMap) {\r\n            delete streamingMethod.protocolState.subscriptionsMap[subscription.id];\r\n        }\r\n        var dropSubscriptionMessage = {\r\n            type: \"drop-subscription\",\r\n            subscription_id: subscription.id,\r\n            reason: \"Server dropping a single subscription\",\r\n        };\r\n        this.session.sendFireAndForget(dropSubscriptionMessage);\r\n        var subscriber = subscription.instance;\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.closeMultipleSubscriptions = function (streamingMethod, branchKey) {\r\n        var _this = this;\r\n        if (typeof streamingMethod !== \"object\" || typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            return;\r\n        }\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return;\r\n        }\r\n        var subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;\r\n        var subscriptionsToClose = Object.keys(subscriptionsMap)\r\n            .map(function (key) {\r\n            return subscriptionsMap[key];\r\n        });\r\n        if (typeof branchKey === \"string\") {\r\n            subscriptionsToClose = subscriptionsToClose.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        subscriptionsToClose.forEach(function (subscription) {\r\n            delete subscriptionsMap[subscription.id];\r\n            var drop = {\r\n                type: \"drop-subscription\",\r\n                subscription_id: subscription.id,\r\n                reason: \"Server dropping all subscriptions on stream_id: \" + subscription.streamId,\r\n            };\r\n            _this.session.sendFireAndForget(drop);\r\n        });\r\n    };\r\n    ServerStreaming.prototype.getSubscriptionList = function (streamingMethod, branchKey) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        var subscriptions = [];\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return [];\r\n        }\r\n        var subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;\r\n        var allSubscriptions = Object.keys(subscriptionsMap)\r\n            .map(function (key) {\r\n            return subscriptionsMap[key];\r\n        });\r\n        if (typeof branchKey !== \"string\") {\r\n            subscriptions = allSubscriptions;\r\n        }\r\n        else {\r\n            subscriptions = allSubscriptions.filter(function (sub) {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n        return subscriptions;\r\n    };\r\n    ServerStreaming.prototype.getBranchList = function (streamingMethod) {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return [];\r\n        }\r\n        var subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;\r\n        var allSubscriptions = Object.keys(subscriptionsMap)\r\n            .map(function (key) {\r\n            return subscriptionsMap[key];\r\n        });\r\n        var result = [];\r\n        allSubscriptions.forEach(function (sub) {\r\n            var branch = \"\";\r\n            if (typeof sub === \"object\" && typeof sub.branchKey === \"string\") {\r\n                branch = sub.branchKey;\r\n            }\r\n            if (result.indexOf(branch) === -1) {\r\n                result.push(branch);\r\n            }\r\n        });\r\n        return result;\r\n    };\r\n    ServerStreaming.prototype.onSubAdded = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_ADDED, callback);\r\n    };\r\n    ServerStreaming.prototype.onSubRequest = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REQUEST, callback);\r\n    };\r\n    ServerStreaming.prototype.onSubRemoved = function (callback) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REMOVED, callback);\r\n    };\r\n    ServerStreaming.prototype.handleRemoveInterest = function (msg) {\r\n        var streamingMethod = this.serverRepository.getById(msg.method_id);\r\n        if (typeof msg.subscription_id !== \"string\" ||\r\n            typeof streamingMethod !== \"object\") {\r\n            return;\r\n        }\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return;\r\n        }\r\n        if (typeof streamingMethod.protocolState.subscriptionsMap[msg.subscription_id] !== \"object\") {\r\n            return;\r\n        }\r\n        var subscription = streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n        delete streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.onSubscriptionLifetimeEvent = function (eventName, handlerFunc) {\r\n        this.callbacks.add(eventName, handlerFunc);\r\n    };\r\n    ServerStreaming.prototype.getNextStreamId = function () {\r\n        return this.nextStreamId++ + \"\";\r\n    };\r\n    ServerStreaming.prototype.handleAddInterest = function (msg) {\r\n        var caller = this.repository.getServerById(msg.caller_id);\r\n        var instance = caller.instance;\r\n        var requestContext = {\r\n            msg: msg,\r\n            arguments: msg.arguments_kv || {},\r\n            instance: instance,\r\n        };\r\n        var streamingMethod = this.serverRepository.getById(msg.method_id);\r\n        if (streamingMethod === undefined) {\r\n            var errorMsg = \"No method with id \" + msg.method_id + \" on this server.\";\r\n            this.sendSubscriptionFailed(errorMsg, msg.subscription_id);\r\n            return;\r\n        }\r\n        if (streamingMethod.protocolState.subscriptionsMap &&\r\n            streamingMethod.protocolState.subscriptionsMap[msg.subscription_id]) {\r\n            this.sendSubscriptionFailed(\"A subscription with id \" + msg.subscription_id + \" already exists.\", msg.subscription_id);\r\n            return;\r\n        }\r\n        this.callbacks.execute(SUBSCRIPTION_REQUEST, requestContext, streamingMethod);\r\n    };\r\n    ServerStreaming.prototype.sendSubscriptionFailed = function (reason, subscriptionId) {\r\n        var errorMessage = {\r\n            type: \"error\",\r\n            reason_uri: this.ERR_URI_SUBSCRIPTION_FAILED,\r\n            reason: reason,\r\n            request_id: subscriptionId,\r\n        };\r\n        this.session.sendFireAndForget(errorMessage);\r\n    };\r\n    ServerStreaming.prototype.getStreamId = function (streamingMethod, branchKey) {\r\n        if (typeof branchKey !== \"string\") {\r\n            branchKey = \"\";\r\n        }\r\n        if (!streamingMethod.protocolState.branchKeyToStreamIdMap) {\r\n            throw new Error(\"streaming \" + streamingMethod.definition.name + \" method without protocol state\");\r\n        }\r\n        var needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {\r\n            return branch.key === branchKey;\r\n        })[0];\r\n        var streamId = (needleBranch ? needleBranch.streamId : undefined);\r\n        if (typeof streamId !== \"string\" || streamId === \"\") {\r\n            streamId = this.getNextStreamId();\r\n            streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });\r\n        }\r\n        return streamId;\r\n    };\r\n    return ServerStreaming;\r\n}());\n\nvar ServerProtocol = (function () {\r\n    function ServerProtocol(session, clientRepository, serverRepository, logger) {\r\n        var _this = this;\r\n        this.session = session;\r\n        this.clientRepository = clientRepository;\r\n        this.serverRepository = serverRepository;\r\n        this.logger = logger;\r\n        this.callbacks = lib();\r\n        this.streaming = new ServerStreaming$1(session, clientRepository, serverRepository);\r\n        this.session.on(\"invoke\", function (msg) { return _this.handleInvokeMessage(msg); });\r\n    }\r\n    ServerProtocol.prototype.createStream = function (repoMethod) {\r\n        repoMethod.protocolState.subscriptionsMap = {};\r\n        repoMethod.protocolState.branchKeyToStreamIdMap = [];\r\n        return this.register(repoMethod, true);\r\n    };\r\n    ServerProtocol.prototype.register = function (repoMethod, isStreaming) {\r\n        var _this = this;\r\n        var _a;\r\n        var methodDef = repoMethod.definition;\r\n        var flags = Object.assign({}, { metadata: (_a = methodDef.flags) !== null && _a !== void 0 ? _a : {} }, { streaming: isStreaming || false });\r\n        var registerMsg = {\r\n            type: \"register\",\r\n            methods: [{\r\n                    id: repoMethod.repoId,\r\n                    name: methodDef.name,\r\n                    display_name: methodDef.displayName,\r\n                    description: methodDef.description,\r\n                    version: methodDef.version,\r\n                    flags: flags,\r\n                    object_types: methodDef.objectTypes || methodDef.object_types,\r\n                    input_signature: methodDef.accepts,\r\n                    result_signature: methodDef.returns,\r\n                    restrictions: undefined,\r\n                }],\r\n        };\r\n        return this.session.send(registerMsg, { methodId: repoMethod.repoId })\r\n            .then(function () {\r\n            _this.logger.debug(\"registered method \" + repoMethod.definition.name + \" with id \" + repoMethod.repoId);\r\n        })\r\n            .catch(function (msg) {\r\n            _this.logger.warn(\"failed to register method \" + repoMethod.definition.name + \" with id \" + repoMethod.repoId + \" - \" + JSON.stringify(msg));\r\n            throw msg;\r\n        });\r\n    };\r\n    ServerProtocol.prototype.onInvoked = function (callback) {\r\n        this.callbacks.add(\"onInvoked\", callback);\r\n    };\r\n    ServerProtocol.prototype.methodInvocationResult = function (method, invocationId, err, result) {\r\n        var msg;\r\n        if (err || err === \"\") {\r\n            msg = {\r\n                type: \"error\",\r\n                request_id: invocationId,\r\n                reason_uri: \"agm.errors.client_error\",\r\n                reason: err,\r\n                context: result,\r\n                peer_id: undefined,\r\n            };\r\n        }\r\n        else {\r\n            msg = {\r\n                type: \"yield\",\r\n                invocation_id: invocationId,\r\n                peer_id: this.session.peerId,\r\n                result: result,\r\n                request_id: undefined,\r\n            };\r\n        }\r\n        this.session.sendFireAndForget(msg);\r\n    };\r\n    ServerProtocol.prototype.unregister = function (method) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var msg;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        msg = {\r\n                            type: \"unregister\",\r\n                            methods: [method.repoId],\r\n                        };\r\n                        return [4, this.session.send(msg)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ServerProtocol.prototype.getBranchList = function (method) {\r\n        return this.streaming.getBranchList(method);\r\n    };\r\n    ServerProtocol.prototype.getSubscriptionList = function (method, branchKey) {\r\n        return this.streaming.getSubscriptionList(method, branchKey);\r\n    };\r\n    ServerProtocol.prototype.closeAllSubscriptions = function (method, branchKey) {\r\n        this.streaming.closeMultipleSubscriptions(method, branchKey);\r\n    };\r\n    ServerProtocol.prototype.pushData = function (method, data, branches) {\r\n        this.streaming.pushData(method, data, branches);\r\n    };\r\n    ServerProtocol.prototype.pushDataToSingle = function (method, subscription, data) {\r\n        this.streaming.pushDataToSingle(method, subscription, data);\r\n    };\r\n    ServerProtocol.prototype.closeSingleSubscription = function (method, subscription) {\r\n        this.streaming.closeSingleSubscription(method, subscription);\r\n    };\r\n    ServerProtocol.prototype.acceptRequestOnBranch = function (requestContext, method, branch) {\r\n        this.streaming.acceptRequestOnBranch(requestContext, method, branch);\r\n    };\r\n    ServerProtocol.prototype.rejectRequest = function (requestContext, method, reason) {\r\n        this.streaming.rejectRequest(requestContext, method, reason);\r\n    };\r\n    ServerProtocol.prototype.onSubRequest = function (callback) {\r\n        this.streaming.onSubRequest(callback);\r\n    };\r\n    ServerProtocol.prototype.onSubAdded = function (callback) {\r\n        this.streaming.onSubAdded(callback);\r\n    };\r\n    ServerProtocol.prototype.onSubRemoved = function (callback) {\r\n        this.streaming.onSubRemoved(callback);\r\n    };\r\n    ServerProtocol.prototype.handleInvokeMessage = function (msg) {\r\n        var invocationId = msg.invocation_id;\r\n        var callerId = msg.caller_id;\r\n        var methodId = msg.method_id;\r\n        var args = msg.arguments_kv;\r\n        var methodList = this.serverRepository.getList();\r\n        var method = methodList.filter(function (m) {\r\n            return m.repoId === methodId;\r\n        })[0];\r\n        if (method === undefined) {\r\n            return;\r\n        }\r\n        var client = this.clientRepository.getServerById(callerId).instance;\r\n        var invocationArgs = { args: args, instance: client };\r\n        this.callbacks.execute(\"onInvoked\", method, invocationId, invocationArgs);\r\n    };\r\n    return ServerProtocol;\r\n}());\n\nvar UserSubscription = (function () {\r\n    function UserSubscription(repository, subscriptionData) {\r\n        this.repository = repository;\r\n        this.subscriptionData = subscriptionData;\r\n    }\r\n    Object.defineProperty(UserSubscription.prototype, \"requestArguments\", {\r\n        get: function () {\r\n            return this.subscriptionData.params.arguments || {};\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(UserSubscription.prototype, \"servers\", {\r\n        get: function () {\r\n            var _this = this;\r\n            return this.subscriptionData.trackedServers\r\n                .filter(function (pair) { return pair.subscriptionId; })\r\n                .map(function (pair) { return _this.repository.getServerById(pair.serverId).instance; });\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(UserSubscription.prototype, \"serverInstance\", {\r\n        get: function () {\r\n            return this.servers[0];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(UserSubscription.prototype, \"stream\", {\r\n        get: function () {\r\n            return this.subscriptionData.method;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    UserSubscription.prototype.onData = function (dataCallback) {\r\n        if (typeof dataCallback !== \"function\") {\r\n            throw new TypeError(\"The data callback must be a function.\");\r\n        }\r\n        this.subscriptionData.handlers.onData.push(dataCallback);\r\n        if (this.subscriptionData.handlers.onData.length === 1 && this.subscriptionData.queued.data.length > 0) {\r\n            this.subscriptionData.queued.data.forEach(function (dataItem) {\r\n                dataCallback(dataItem);\r\n            });\r\n        }\r\n    };\r\n    UserSubscription.prototype.onClosed = function (closedCallback) {\r\n        if (typeof closedCallback !== \"function\") {\r\n            throw new TypeError(\"The callback must be a function.\");\r\n        }\r\n        this.subscriptionData.handlers.onClosed.push(closedCallback);\r\n    };\r\n    UserSubscription.prototype.onFailed = function (callback) {\r\n    };\r\n    UserSubscription.prototype.onConnected = function (callback) {\r\n        if (typeof callback !== \"function\") {\r\n            throw new TypeError(\"The callback must be a function.\");\r\n        }\r\n        this.subscriptionData.handlers.onConnected.push(callback);\r\n    };\r\n    UserSubscription.prototype.close = function () {\r\n        this.subscriptionData.close();\r\n    };\r\n    UserSubscription.prototype.setNewSubscription = function (newSub) {\r\n        this.subscriptionData = newSub;\r\n    };\r\n    return UserSubscription;\r\n}());\n\nvar STATUS_AWAITING_ACCEPT = \"awaitingAccept\";\r\nvar STATUS_SUBSCRIBED = \"subscribed\";\r\nvar ERR_MSG_SUB_FAILED = \"Subscription failed.\";\r\nvar ERR_MSG_SUB_REJECTED = \"Subscription rejected.\";\r\nvar ON_CLOSE_MSG_SERVER_INIT = \"ServerInitiated\";\r\nvar ON_CLOSE_MSG_CLIENT_INIT = \"ClientInitiated\";\r\nvar ClientStreaming = (function () {\r\n    function ClientStreaming(session, repository, logger) {\r\n        var _this = this;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.logger = logger;\r\n        this.subscriptionsList = {};\r\n        this.subscriptionIdToLocalKeyMap = {};\r\n        this.nextSubLocalKey = 0;\r\n        this.handleErrorSubscribing = function (errorResponse) {\r\n            var tag = errorResponse._tag;\r\n            var subLocalKey = tag.subLocalKey;\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (typeof pendingSub !== \"object\") {\r\n                return;\r\n            }\r\n            pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {\r\n                return server.serverId !== tag.serverId;\r\n            });\r\n            if (pendingSub.trackedServers.length <= 0) {\r\n                clearTimeout(pendingSub.timeoutId);\r\n                if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                    var reason = (typeof errorResponse.reason === \"string\" && errorResponse.reason !== \"\") ?\r\n                        ' Publisher said \"' + errorResponse.reason + '\".' :\r\n                        \" No reason given.\";\r\n                    var callArgs = typeof pendingSub.params.arguments === \"object\" ?\r\n                        JSON.stringify(pendingSub.params.arguments) :\r\n                        \"{}\";\r\n                    pendingSub.error({\r\n                        message: ERR_MSG_SUB_REJECTED + reason + \" Called with:\" + callArgs,\r\n                        called_with: pendingSub.params.arguments,\r\n                        method: pendingSub.method,\r\n                    });\r\n                }\r\n                else if (pendingSub.status === STATUS_SUBSCRIBED) {\r\n                    _this.callOnClosedHandlers(pendingSub);\r\n                }\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n        };\r\n        this.handleSubscribed = function (msg) {\r\n            var subLocalKey = msg._tag.subLocalKey;\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (typeof pendingSub !== \"object\") {\r\n                return;\r\n            }\r\n            var serverId = msg._tag.serverId;\r\n            var acceptingServer = pendingSub.trackedServers\r\n                .filter(function (server) {\r\n                return server.serverId === serverId;\r\n            })[0];\r\n            if (typeof acceptingServer !== \"object\") {\r\n                return;\r\n            }\r\n            acceptingServer.subscriptionId = msg.subscription_id;\r\n            _this.subscriptionIdToLocalKeyMap[msg.subscription_id] = subLocalKey;\r\n            var isFirstResponse = (pendingSub.status === STATUS_AWAITING_ACCEPT);\r\n            pendingSub.status = STATUS_SUBSCRIBED;\r\n            if (isFirstResponse) {\r\n                var reconnect = false;\r\n                var sub = pendingSub.subscription;\r\n                if (sub) {\r\n                    sub.setNewSubscription(pendingSub);\r\n                    pendingSub.success(sub);\r\n                    reconnect = true;\r\n                }\r\n                else {\r\n                    sub = new UserSubscription(_this.repository, pendingSub);\r\n                    pendingSub.subscription = sub;\r\n                    pendingSub.success(sub);\r\n                }\r\n                for (var _i = 0, _a = pendingSub.handlers.onConnected; _i < _a.length; _i++) {\r\n                    var handler = _a[_i];\r\n                    try {\r\n                        handler(sub.serverInstance, reconnect);\r\n                    }\r\n                    catch (e) {\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        this.handleEventData = function (msg) {\r\n            var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n            if (typeof subLocalKey === \"undefined\") {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subLocalKey];\r\n            if (typeof subscription !== \"object\") {\r\n                return;\r\n            }\r\n            var trackedServersFound = subscription.trackedServers.filter(function (server) {\r\n                return server.subscriptionId === msg.subscription_id;\r\n            });\r\n            if (trackedServersFound.length !== 1) {\r\n                return;\r\n            }\r\n            var isPrivateData = msg.oob;\r\n            var sendingServerId = trackedServersFound[0].serverId;\r\n            var receivedStreamData = function () {\r\n                return {\r\n                    data: msg.data,\r\n                    server: _this.repository.getServerById(sendingServerId).instance,\r\n                    requestArguments: subscription.params.arguments,\r\n                    message: undefined,\r\n                    private: isPrivateData,\r\n                };\r\n            };\r\n            var onDataHandlers = subscription.handlers.onData;\r\n            var queuedData = subscription.queued.data;\r\n            if (onDataHandlers.length > 0) {\r\n                onDataHandlers.forEach(function (callback) {\r\n                    if (typeof callback === \"function\") {\r\n                        callback(receivedStreamData());\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                queuedData.push(receivedStreamData());\r\n            }\r\n        };\r\n        this.handleSubscriptionCancelled = function (msg) {\r\n            var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n            if (typeof subLocalKey === \"undefined\") {\r\n                return;\r\n            }\r\n            var subscription = _this.subscriptionsList[subLocalKey];\r\n            if (typeof subscription !== \"object\") {\r\n                return;\r\n            }\r\n            var expectedNewLength = subscription.trackedServers.length - 1;\r\n            subscription.trackedServers = subscription.trackedServers.filter(function (server) {\r\n                if (server.subscriptionId === msg.subscription_id) {\r\n                    subscription.queued.closers.push(server.serverId);\r\n                    return false;\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            });\r\n            if (subscription.trackedServers.length !== expectedNewLength) {\r\n                return;\r\n            }\r\n            if (subscription.trackedServers.length <= 0) {\r\n                clearTimeout(subscription.timeoutId);\r\n                _this.callOnClosedHandlers(subscription);\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n            delete _this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n        };\r\n        session.on(\"subscribed\", this.handleSubscribed);\r\n        session.on(\"event\", this.handleEventData);\r\n        session.on(\"subscription-cancelled\", this.handleSubscriptionCancelled);\r\n    }\r\n    ClientStreaming.prototype.subscribe = function (streamingMethod, params, targetServers, success, error, existingSub) {\r\n        var _this = this;\r\n        if (targetServers.length === 0) {\r\n            error({\r\n                method: streamingMethod,\r\n                called_with: params.arguments,\r\n                message: ERR_MSG_SUB_FAILED + \" No available servers matched the target params.\",\r\n            });\r\n            return;\r\n        }\r\n        var subLocalKey = this.getNextSubscriptionLocalKey();\r\n        var pendingSub = this.registerSubscription(subLocalKey, streamingMethod, params, success, error, params.methodResponseTimeout || 10000, existingSub);\r\n        if (typeof pendingSub !== \"object\") {\r\n            error({\r\n                method: streamingMethod,\r\n                called_with: params.arguments,\r\n                message: ERR_MSG_SUB_FAILED + \" Unable to register the user callbacks.\",\r\n            });\r\n            return;\r\n        }\r\n        targetServers.forEach(function (target) {\r\n            var serverId = target.server.id;\r\n            var method = target.methods.find(function (m) { return m.name === streamingMethod.name; });\r\n            if (!method) {\r\n                _this.logger.error(\"can not find method \" + streamingMethod.name + \" for target \" + target.server.id);\r\n                return;\r\n            }\r\n            pendingSub.trackedServers.push({\r\n                serverId: serverId,\r\n                subscriptionId: undefined,\r\n            });\r\n            var msg = {\r\n                type: \"subscribe\",\r\n                server_id: serverId,\r\n                method_id: method.gatewayId,\r\n                arguments_kv: params.arguments,\r\n            };\r\n            _this.session.send(msg, { serverId: serverId, subLocalKey: subLocalKey })\r\n                .then(function (m) { return _this.handleSubscribed(m); })\r\n                .catch(function (err) { return _this.handleErrorSubscribing(err); });\r\n        });\r\n    };\r\n    ClientStreaming.prototype.drainSubscriptions = function () {\r\n        var existing = Object.values(this.subscriptionsList);\r\n        this.subscriptionsList = {};\r\n        this.subscriptionIdToLocalKeyMap = {};\r\n        return existing;\r\n    };\r\n    ClientStreaming.prototype.getNextSubscriptionLocalKey = function () {\r\n        var current = this.nextSubLocalKey;\r\n        this.nextSubLocalKey += 1;\r\n        return current;\r\n    };\r\n    ClientStreaming.prototype.registerSubscription = function (subLocalKey, method, params, success, error, timeout, existingSub) {\r\n        var _this = this;\r\n        var subsInfo = {\r\n            localKey: subLocalKey,\r\n            status: STATUS_AWAITING_ACCEPT,\r\n            method: method,\r\n            params: params,\r\n            success: success,\r\n            error: error,\r\n            trackedServers: [],\r\n            handlers: {\r\n                onData: (existingSub === null || existingSub === void 0 ? void 0 : existingSub.handlers.onData) || [],\r\n                onClosed: (existingSub === null || existingSub === void 0 ? void 0 : existingSub.handlers.onClosed) || [],\r\n                onConnected: (existingSub === null || existingSub === void 0 ? void 0 : existingSub.handlers.onConnected) || [],\r\n            },\r\n            queued: {\r\n                data: [],\r\n                closers: [],\r\n            },\r\n            timeoutId: undefined,\r\n            close: function () { return _this.closeSubscription(subLocalKey); },\r\n            subscription: existingSub === null || existingSub === void 0 ? void 0 : existingSub.subscription\r\n        };\r\n        if (!existingSub) {\r\n            if (params.onData) {\r\n                subsInfo.handlers.onData.push(params.onData);\r\n            }\r\n            if (params.onClosed) {\r\n                subsInfo.handlers.onClosed.push(params.onClosed);\r\n            }\r\n            if (params.onConnected) {\r\n                subsInfo.handlers.onConnected.push(params.onConnected);\r\n            }\r\n        }\r\n        this.subscriptionsList[subLocalKey] = subsInfo;\r\n        subsInfo.timeoutId = setTimeout(function () {\r\n            if (_this.subscriptionsList[subLocalKey] === undefined) {\r\n                return;\r\n            }\r\n            var pendingSub = _this.subscriptionsList[subLocalKey];\r\n            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                error({\r\n                    method: method,\r\n                    called_with: params.arguments,\r\n                    message: ERR_MSG_SUB_FAILED + \" Subscription attempt timed out after \" + timeout + \" ms.\",\r\n                });\r\n                delete _this.subscriptionsList[subLocalKey];\r\n            }\r\n            else if (pendingSub.status === STATUS_SUBSCRIBED && pendingSub.trackedServers.length > 0) {\r\n                pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {\r\n                    return (typeof server.subscriptionId !== \"undefined\");\r\n                });\r\n                delete pendingSub.timeoutId;\r\n                if (pendingSub.trackedServers.length <= 0) {\r\n                    _this.callOnClosedHandlers(pendingSub);\r\n                    delete _this.subscriptionsList[subLocalKey];\r\n                }\r\n            }\r\n        }, timeout);\r\n        return subsInfo;\r\n    };\r\n    ClientStreaming.prototype.callOnClosedHandlers = function (subscription, reason) {\r\n        var closersCount = subscription.queued.closers.length;\r\n        var closingServerId = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;\r\n        var closingServer;\r\n        if (closingServerId !== undefined && typeof closingServerId === \"string\") {\r\n            closingServer = this.repository.getServerById(closingServerId).instance;\r\n        }\r\n        subscription.handlers.onClosed.forEach(function (callback) {\r\n            if (typeof callback !== \"function\") {\r\n                return;\r\n            }\r\n            callback({\r\n                message: reason || ON_CLOSE_MSG_SERVER_INIT,\r\n                requestArguments: subscription.params.arguments || {},\r\n                server: closingServer,\r\n                stream: subscription.method,\r\n            });\r\n        });\r\n    };\r\n    ClientStreaming.prototype.closeSubscription = function (subLocalKey) {\r\n        var _this = this;\r\n        var subscription = this.subscriptionsList[subLocalKey];\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n        subscription.trackedServers.forEach(function (server) {\r\n            if (typeof server.subscriptionId === \"undefined\") {\r\n                return;\r\n            }\r\n            subscription.queued.closers.push(server.serverId);\r\n            _this.session.sendFireAndForget({\r\n                type: \"unsubscribe\",\r\n                subscription_id: server.subscriptionId,\r\n                reason_uri: \"\",\r\n                reason: ON_CLOSE_MSG_CLIENT_INIT,\r\n            });\r\n            delete _this.subscriptionIdToLocalKeyMap[server.subscriptionId];\r\n        });\r\n        subscription.trackedServers = [];\r\n        this.callOnClosedHandlers(subscription, ON_CLOSE_MSG_CLIENT_INIT);\r\n        delete this.subscriptionsList[subLocalKey];\r\n    };\r\n    return ClientStreaming;\r\n}());\n\nvar ClientProtocol = (function () {\r\n    function ClientProtocol(session, repository, logger) {\r\n        var _this = this;\r\n        this.session = session;\r\n        this.repository = repository;\r\n        this.logger = logger;\r\n        session.on(\"peer-added\", function (msg) { return _this.handlePeerAdded(msg); });\r\n        session.on(\"peer-removed\", function (msg) { return _this.handlePeerRemoved(msg); });\r\n        session.on(\"methods-added\", function (msg) { return _this.handleMethodsAddedMessage(msg); });\r\n        session.on(\"methods-removed\", function (msg) { return _this.handleMethodsRemovedMessage(msg); });\r\n        this.streaming = new ClientStreaming(session, repository, logger);\r\n    }\r\n    ClientProtocol.prototype.subscribe = function (stream, options, targetServers, success, error, existingSub) {\r\n        this.streaming.subscribe(stream, options, targetServers, success, error, existingSub);\r\n    };\r\n    ClientProtocol.prototype.invoke = function (id, method, args, target) {\r\n        var _this = this;\r\n        var serverId = target.id;\r\n        var methodId = method.gatewayId;\r\n        var msg = {\r\n            type: \"call\",\r\n            server_id: serverId,\r\n            method_id: methodId,\r\n            arguments_kv: args,\r\n        };\r\n        return this.session.send(msg, { invocationId: id, serverId: serverId })\r\n            .then(function (m) { return _this.handleResultMessage(m); })\r\n            .catch(function (err) { return _this.handleInvocationError(err); });\r\n    };\r\n    ClientProtocol.prototype.drainSubscriptions = function () {\r\n        return this.streaming.drainSubscriptions();\r\n    };\r\n    ClientProtocol.prototype.handlePeerAdded = function (msg) {\r\n        var newPeerId = msg.new_peer_id;\r\n        var remoteId = msg.identity;\r\n        var isLocal = msg.meta ? msg.meta.local : true;\r\n        var pid = Number(remoteId.process);\r\n        var serverInfo = {\r\n            machine: remoteId.machine,\r\n            pid: isNaN(pid) ? remoteId.process : pid,\r\n            instance: remoteId.instance,\r\n            application: remoteId.application,\r\n            applicationName: remoteId.applicationName,\r\n            environment: remoteId.environment,\r\n            region: remoteId.region,\r\n            user: remoteId.user,\r\n            windowId: remoteId.windowId,\r\n            peerId: newPeerId,\r\n            api: remoteId.api,\r\n            isLocal: isLocal\r\n        };\r\n        this.repository.addServer(serverInfo, newPeerId);\r\n    };\r\n    ClientProtocol.prototype.handlePeerRemoved = function (msg) {\r\n        var removedPeerId = msg.removed_id;\r\n        var reason = msg.reason;\r\n        this.repository.removeServerById(removedPeerId, reason);\r\n    };\r\n    ClientProtocol.prototype.handleMethodsAddedMessage = function (msg) {\r\n        var _this = this;\r\n        var serverId = msg.server_id;\r\n        var methods = msg.methods;\r\n        methods.forEach(function (method) {\r\n            _this.repository.addServerMethod(serverId, method);\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleMethodsRemovedMessage = function (msg) {\r\n        var _this = this;\r\n        var serverId = msg.server_id;\r\n        var methodIdList = msg.methods;\r\n        var server = this.repository.getServerById(serverId);\r\n        var serverMethodKeys = Object.keys(server.methods);\r\n        serverMethodKeys.forEach(function (methodKey) {\r\n            var method = server.methods[methodKey];\r\n            if (methodIdList.indexOf(method.gatewayId) > -1) {\r\n                _this.repository.removeServerMethod(serverId, methodKey);\r\n            }\r\n        });\r\n    };\r\n    ClientProtocol.prototype.handleResultMessage = function (msg) {\r\n        var invocationId = msg._tag.invocationId;\r\n        var result = msg.result;\r\n        var serverId = msg._tag.serverId;\r\n        var server = this.repository.getServerById(serverId);\r\n        return {\r\n            invocationId: invocationId,\r\n            result: result,\r\n            instance: server.instance,\r\n            status: InvokeStatus.Success,\r\n            message: \"\"\r\n        };\r\n    };\r\n    ClientProtocol.prototype.handleInvocationError = function (msg) {\r\n        this.logger.debug(\"handle invocation error \" + JSON.stringify(msg));\r\n        if (\"_tag\" in msg) {\r\n            var invocationId = msg._tag.invocationId;\r\n            var serverId = msg._tag.serverId;\r\n            var server = this.repository.getServerById(serverId);\r\n            var message = msg.reason;\r\n            var context_1 = msg.context;\r\n            return {\r\n                invocationId: invocationId,\r\n                result: context_1,\r\n                instance: server.instance,\r\n                status: InvokeStatus.Error,\r\n                message: message\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                invocationId: \"\",\r\n                message: msg.message,\r\n                status: InvokeStatus.Error,\r\n                error: msg\r\n            };\r\n        }\r\n    };\r\n    return ClientProtocol;\r\n}());\n\nfunction gW3ProtocolFactory (instance, connection, clientRepository, serverRepository, libConfig, interop) {\r\n    var logger = libConfig.logger.subLogger(\"gw3-protocol\");\r\n    var resolveReadyPromise;\r\n    var readyPromise = new Promise(function (resolve) {\r\n        resolveReadyPromise = resolve;\r\n    });\r\n    var session = connection.domain(\"agm\", [\"subscribed\"]);\r\n    var server = new ServerProtocol(session, clientRepository, serverRepository, logger.subLogger(\"server\"));\r\n    var client = new ClientProtocol(session, clientRepository, logger.subLogger(\"client\"));\r\n    function handleReconnect() {\r\n        logger.info(\"reconnected - will replay registered methods and subscriptions\");\r\n        var existingSubscriptions = client.drainSubscriptions();\r\n        for (var _i = 0, existingSubscriptions_1 = existingSubscriptions; _i < existingSubscriptions_1.length; _i++) {\r\n            var sub = existingSubscriptions_1[_i];\r\n            var methodInfo = sub.method;\r\n            var params = Object.assign({}, sub.params);\r\n            logger.info(\"trying to re-subscribe to method \" + methodInfo.name);\r\n            interop.client.subscribe(methodInfo, params, undefined, undefined, sub);\r\n        }\r\n        var registeredMethods = serverRepository.getList();\r\n        serverRepository.reset();\r\n        for (var _a = 0, registeredMethods_1 = registeredMethods; _a < registeredMethods_1.length; _a++) {\r\n            var method = registeredMethods_1[_a];\r\n            var def = method.definition;\r\n            logger.info(\"re-publishing method \" + def.name);\r\n            if (method.stream) {\r\n                interop.server.createStream(def, method.streamCallbacks, undefined, undefined, method.stream);\r\n            }\r\n            else if (method.theFunction && method.theFunction.userCallback) {\r\n                interop.register(def, method.theFunction.userCallback);\r\n            }\r\n            else if (method.theFunction && method.theFunction.userCallbackAsync) {\r\n                interop.registerAsync(def, method.theFunction.userCallbackAsync);\r\n            }\r\n        }\r\n    }\r\n    function handleInitialJoin() {\r\n        if (resolveReadyPromise) {\r\n            resolveReadyPromise({\r\n                client: client,\r\n                server: server,\r\n            });\r\n            resolveReadyPromise = undefined;\r\n        }\r\n    }\r\n    session.onJoined(function (reconnect) {\r\n        clientRepository.addServer(instance, connection.peerId);\r\n        if (reconnect) {\r\n            handleReconnect();\r\n        }\r\n        else {\r\n            handleInitialJoin();\r\n        }\r\n    });\r\n    session.onLeft(function () {\r\n        clientRepository.reset();\r\n    });\r\n    session.join();\r\n    return readyPromise;\r\n}\n\nvar Interop = (function () {\r\n    function Interop(configuration) {\r\n        var _this = this;\r\n        if (typeof configuration === \"undefined\") {\r\n            throw new Error(\"configuration is required\");\r\n        }\r\n        if (typeof configuration.connection === \"undefined\") {\r\n            throw new Error(\"configuration.connections is required\");\r\n        }\r\n        var connection = configuration.connection;\r\n        if (typeof configuration.methodResponseTimeout !== \"number\") {\r\n            configuration.methodResponseTimeout = 30 * 1000;\r\n        }\r\n        if (typeof configuration.waitTimeoutMs !== \"number\") {\r\n            configuration.waitTimeoutMs = 30 * 1000;\r\n        }\r\n        this.unwrappedInstance = new InstanceWrapper(this, undefined, connection);\r\n        this.instance = this.unwrappedInstance.unwrap();\r\n        this.clientRepository = new ClientRepository(configuration.logger.subLogger(\"cRep\"), this);\r\n        this.serverRepository = new ServerRepository();\r\n        var protocolPromise;\r\n        if (connection.protocolVersion === 3) {\r\n            protocolPromise = gW3ProtocolFactory(this.instance, connection, this.clientRepository, this.serverRepository, configuration, this);\r\n        }\r\n        else {\r\n            throw new Error(\"protocol \" + connection.protocolVersion + \" not supported\");\r\n        }\r\n        this.readyPromise = protocolPromise.then(function (protocol) {\r\n            _this.protocol = protocol;\r\n            _this.client = new Client(_this.protocol, _this.clientRepository, _this.instance, configuration);\r\n            _this.server = new Server(_this.protocol, _this.serverRepository);\r\n            return _this;\r\n        });\r\n    }\r\n    Interop.prototype.ready = function () {\r\n        return this.readyPromise;\r\n    };\r\n    Interop.prototype.serverRemoved = function (callback) {\r\n        return this.client.serverRemoved(callback);\r\n    };\r\n    Interop.prototype.serverAdded = function (callback) {\r\n        return this.client.serverAdded(callback);\r\n    };\r\n    Interop.prototype.serverMethodRemoved = function (callback) {\r\n        return this.client.serverMethodRemoved(callback);\r\n    };\r\n    Interop.prototype.serverMethodAdded = function (callback) {\r\n        return this.client.serverMethodAdded(callback);\r\n    };\r\n    Interop.prototype.methodRemoved = function (callback) {\r\n        return this.client.methodRemoved(callback);\r\n    };\r\n    Interop.prototype.methodAdded = function (callback) {\r\n        return this.client.methodAdded(callback);\r\n    };\r\n    Interop.prototype.methodsForInstance = function (instance) {\r\n        return this.client.methodsForInstance(instance);\r\n    };\r\n    Interop.prototype.methods = function (methodFilter) {\r\n        return this.client.methods(methodFilter);\r\n    };\r\n    Interop.prototype.servers = function (methodFilter) {\r\n        return this.client.servers(methodFilter);\r\n    };\r\n    Interop.prototype.subscribe = function (method, options, successCallback, errorCallback) {\r\n        return this.client.subscribe(method, options, successCallback, errorCallback);\r\n    };\r\n    Interop.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback) {\r\n        return this.server.createStream(streamDef, callbacks, successCallback, errorCallback);\r\n    };\r\n    Interop.prototype.unregister = function (methodFilter) {\r\n        return this.server.unregister(methodFilter);\r\n    };\r\n    Interop.prototype.registerAsync = function (methodDefinition, callback) {\r\n        return this.server.registerAsync(methodDefinition, callback);\r\n    };\r\n    Interop.prototype.register = function (methodDefinition, callback) {\r\n        return this.server.register(methodDefinition, callback);\r\n    };\r\n    Interop.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {\r\n        return this.client.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);\r\n    };\r\n    Interop.prototype.waitForMethod = function (name) {\r\n        var pw = new PromiseWrapper();\r\n        var unsubscribe = this.client.methodAdded(function (m) {\r\n            if (m.name === name) {\r\n                unsubscribe();\r\n                pw.resolve(m);\r\n            }\r\n        });\r\n        return pw.promise;\r\n    };\r\n    return Interop;\r\n}());\n\nvar successMessages = [\"subscribed\", \"success\"];\r\nvar MessageBus = (function () {\r\n    function MessageBus(connection, logger) {\r\n        var _this = this;\r\n        this.publish = function (topic, data, options) {\r\n            var _a = options || {}, routingKey = _a.routingKey, target = _a.target;\r\n            var args = _this.removeEmptyValues({\r\n                type: \"publish\",\r\n                topic: topic,\r\n                data: data,\r\n                peer_id: _this.peerId,\r\n                routing_key: routingKey,\r\n                target_identity: target\r\n            });\r\n            _this.session.send(args);\r\n        };\r\n        this.subscribe = function (topic, callback, options) {\r\n            return new Promise(function (resolve, reject) {\r\n                var _a = options || {}, routingKey = _a.routingKey, target = _a.target;\r\n                var args = _this.removeEmptyValues({\r\n                    type: \"subscribe\",\r\n                    topic: topic,\r\n                    peer_id: _this.peerId,\r\n                    routing_key: routingKey,\r\n                    source: target\r\n                });\r\n                _this.session.send(args)\r\n                    .then(function (response) {\r\n                    var subscription_id = response.subscription_id;\r\n                    _this.subscriptions.push({ subscription_id: subscription_id, topic: topic, callback: callback, source: target });\r\n                    resolve({\r\n                        unsubscribe: function () {\r\n                            _this.session.send({ type: \"unsubscribe\", subscription_id: subscription_id, peer_id: _this.peerId });\r\n                            _this.subscriptions = _this.subscriptions.filter(function (s) { return s.subscription_id !== subscription_id; });\r\n                            return Promise.resolve();\r\n                        }\r\n                    });\r\n                })\r\n                    .catch(function (error) { return reject(error); });\r\n            });\r\n        };\r\n        this.watchOnEvent = function () {\r\n            _this.session.on(\"event\", function (args) {\r\n                var data = args.data, subscription_id = args.subscription_id;\r\n                var source = args[\"publisher-identity\"];\r\n                var subscription = _this.subscriptions.find(function (s) { return s.subscription_id === subscription_id; });\r\n                if (subscription) {\r\n                    if (!subscription.source) {\r\n                        subscription.callback(data, subscription.topic, source);\r\n                    }\r\n                    else {\r\n                        if (_this.keysMatch(subscription.source, source)) {\r\n                            subscription.callback(data, subscription.topic, source);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        };\r\n        this.connection = connection;\r\n        this.logger = logger;\r\n        this.peerId = connection.peerId;\r\n        this.subscriptions = [];\r\n        this.session = connection.domain(\"bus\", successMessages);\r\n        this.readyPromise = this.session.join();\r\n        this.readyPromise.then(function () {\r\n            _this.watchOnEvent();\r\n        });\r\n    }\r\n    MessageBus.prototype.ready = function () {\r\n        return this.readyPromise;\r\n    };\r\n    MessageBus.prototype.removeEmptyValues = function (obj) {\r\n        var cleaned = {};\r\n        Object.keys(obj).forEach(function (key) {\r\n            if (obj[key] !== undefined && obj[key] !== null) {\r\n                cleaned[key] = obj[key];\r\n            }\r\n        });\r\n        return cleaned;\r\n    };\r\n    MessageBus.prototype.keysMatch = function (obj1, obj2) {\r\n        var keysObj1 = Object.keys(obj1);\r\n        var allMatch = true;\r\n        keysObj1.forEach(function (key) {\r\n            if (obj1[key] !== obj2[key]) {\r\n                allMatch = false;\r\n            }\r\n        });\r\n        return allMatch;\r\n    };\r\n    return MessageBus;\r\n}());\n\nvar GlueCore = function (userConfig, ext) {\r\n    var gdVersion = Utils.getGDMajorVersion();\r\n    var glue42gd;\r\n    var preloadPromise = Promise.resolve();\r\n    if (gdVersion) {\r\n        if (gdVersion < 3) {\r\n            throw new Error(\"GD v2 is not supported. Use v4 of the API to run in that context.\");\r\n        }\r\n        else if (gdVersion >= 3) {\r\n            glue42gd = window.glue42gd;\r\n            preloadPromise = window.gdPreloadPromise || preloadPromise;\r\n        }\r\n    }\r\n    var glueInitTimer = timer(\"glue\");\r\n    userConfig = userConfig || {};\r\n    ext = ext || {};\r\n    var internalConfig = prepareConfig(userConfig, ext, glue42gd);\r\n    var _connection;\r\n    var _interop;\r\n    var _logger;\r\n    var _metrics;\r\n    var _contexts;\r\n    var _bus;\r\n    var _allowTrace;\r\n    var libs = {};\r\n    function registerLib(name, inner, t) {\r\n        _allowTrace = _logger.canPublish(\"trace\");\r\n        if (_allowTrace) {\r\n            _logger.trace(\"registering \" + name + \" module\");\r\n        }\r\n        var done = function () {\r\n            inner.initTime = t.stop();\r\n            inner.initEndTime = t.endTime;\r\n            inner.marks = t.marks;\r\n            if (_allowTrace) {\r\n                _logger.trace(name + \" is ready - \" + (t.endTime - t.startTime));\r\n            }\r\n        };\r\n        inner.initStartTime = t.startTime;\r\n        if (inner.ready) {\r\n            inner.ready().then(function () {\r\n                done();\r\n            });\r\n        }\r\n        else {\r\n            done();\r\n        }\r\n        if (!Array.isArray(name)) {\r\n            name = [name];\r\n        }\r\n        name.forEach(function (n) {\r\n            libs[n] = inner;\r\n            GlueCore[n] = inner;\r\n        });\r\n    }\r\n    function setupConnection() {\r\n        var initTimer = timer(\"connection\");\r\n        _connection = new Connection(internalConfig.connection, _logger.subLogger(\"connection\"));\r\n        var authPromise = Promise.resolve(internalConfig.auth);\r\n        if (internalConfig.connection && !internalConfig.auth) {\r\n            if (glue42gd) {\r\n                authPromise = glue42gd.getGWToken()\r\n                    .then(function (token) {\r\n                    return {\r\n                        gatewayToken: token\r\n                    };\r\n                });\r\n            }\r\n            else {\r\n                authPromise = Promise.reject(\"You need to provide auth information\");\r\n            }\r\n        }\r\n        return authPromise\r\n            .then(function (authConfig) {\r\n            initTimer.mark(\"auth-promise-resolved\");\r\n            var authRequest;\r\n            if (Object.prototype.toString.call(authConfig) === \"[object Object]\") {\r\n                authRequest = authConfig;\r\n            }\r\n            else {\r\n                throw new Error(\"Invalid auth object - \" + JSON.stringify(authConfig));\r\n            }\r\n            return _connection.login(authRequest);\r\n        })\r\n            .then(function () {\r\n            registerLib(\"connection\", _connection, initTimer);\r\n            return internalConfig;\r\n        })\r\n            .catch(function (e) {\r\n            if (_connection) {\r\n                _connection.logout();\r\n            }\r\n            throw e;\r\n        });\r\n    }\r\n    function setupLogger() {\r\n        var _a;\r\n        var initTimer = timer(\"logger\");\r\n        _logger = new Logger(\"\" + ((_a = internalConfig.connection.identity) === null || _a === void 0 ? void 0 : _a.application), undefined, internalConfig.customLogger);\r\n        _logger.consoleLevel(internalConfig.logger.console);\r\n        _logger.publishLevel(internalConfig.logger.publish);\r\n        if (_logger.canPublish(\"debug\")) {\r\n            _logger.debug(\"initializing glue...\");\r\n        }\r\n        registerLib(\"logger\", _logger, initTimer);\r\n        return Promise.resolve(undefined);\r\n    }\r\n    function setupMetrics() {\r\n        var _a, _b, _c, _d, _e;\r\n        var initTimer = timer(\"metrics\");\r\n        var config = internalConfig.metrics;\r\n        var metricsPublishingEnabledFunc = glue42gd === null || glue42gd === void 0 ? void 0 : glue42gd.getMetricsPublishingEnabled;\r\n        var identity = internalConfig.connection.identity;\r\n        var canUpdateMetric = metricsPublishingEnabledFunc ? metricsPublishingEnabledFunc : function () { return true; };\r\n        var disableAutoAppSystem = (_a = (typeof config !== \"boolean\" && config.disableAutoAppSystem)) !== null && _a !== void 0 ? _a : false;\r\n        _metrics = metrics({\r\n            connection: config ? _connection : undefined,\r\n            logger: _logger.subLogger(\"metrics\"),\r\n            canUpdateMetric: canUpdateMetric,\r\n            system: \"Glue42\",\r\n            service: (_c = (_b = identity === null || identity === void 0 ? void 0 : identity.service) !== null && _b !== void 0 ? _b : glue42gd === null || glue42gd === void 0 ? void 0 : glue42gd.applicationName) !== null && _c !== void 0 ? _c : internalConfig.application,\r\n            instance: (_e = (_d = identity === null || identity === void 0 ? void 0 : identity.instance) !== null && _d !== void 0 ? _d : identity === null || identity === void 0 ? void 0 : identity.windowId) !== null && _e !== void 0 ? _e : shortid(),\r\n            disableAutoAppSystem: disableAutoAppSystem,\r\n            pagePerformanceMetrics: typeof config !== \"boolean\" ? config === null || config === void 0 ? void 0 : config.pagePerformanceMetrics : undefined\r\n        });\r\n        registerLib(\"metrics\", _metrics, initTimer);\r\n        return Promise.resolve();\r\n    }\r\n    function setupInterop() {\r\n        var initTimer = timer(\"interop\");\r\n        var agmConfig = {\r\n            connection: _connection,\r\n            logger: _logger.subLogger(\"interop\"),\r\n        };\r\n        _interop = new Interop(agmConfig);\r\n        Logger.Interop = _interop;\r\n        registerLib([\"interop\", \"agm\"], _interop, initTimer);\r\n        return Promise.resolve();\r\n    }\r\n    function setupContexts() {\r\n        var hasActivities = (internalConfig.activities && _connection.protocolVersion === 3);\r\n        var needsContexts = internalConfig.contexts || hasActivities;\r\n        if (needsContexts) {\r\n            var initTimer = timer(\"contexts\");\r\n            _contexts = new ContextsModule({\r\n                connection: _connection,\r\n                logger: _logger.subLogger(\"contexts\")\r\n            });\r\n            registerLib(\"contexts\", _contexts, initTimer);\r\n            return _contexts;\r\n        }\r\n        else {\r\n            var replayer = _connection.replayer;\r\n            if (replayer) {\r\n                replayer.drain(ContextMessageReplaySpec.name);\r\n            }\r\n        }\r\n    }\r\n    function setupBus() {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var initTimer;\r\n            return __generator(this, function (_a) {\r\n                if (!internalConfig.bus) {\r\n                    return [2, Promise.resolve()];\r\n                }\r\n                initTimer = timer(\"bus\");\r\n                _bus = new MessageBus(_connection, _logger.subLogger(\"bus\"));\r\n                registerLib(\"bus\", _bus, initTimer);\r\n                return [2, Promise.resolve()];\r\n            });\r\n        });\r\n    }\r\n    function setupExternalLibs(externalLibs) {\r\n        try {\r\n            externalLibs.forEach(function (lib) {\r\n                setupExternalLib(lib.name, lib.create);\r\n            });\r\n            return Promise.resolve();\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    function setupExternalLib(name, createCallback) {\r\n        var initTimer = timer(name);\r\n        var lib = createCallback(libs);\r\n        if (lib) {\r\n            registerLib(name, lib, initTimer);\r\n        }\r\n    }\r\n    function waitForLibs() {\r\n        var libsReadyPromises = Object.keys(libs).map(function (key) {\r\n            var lib = libs[key];\r\n            return lib.ready ?\r\n                lib.ready() : Promise.resolve();\r\n        });\r\n        return Promise.all(libsReadyPromises);\r\n    }\r\n    function constructGlueObject() {\r\n        var feedbackFunc = function (feedbackInfo) {\r\n            if (!_interop) {\r\n                return;\r\n            }\r\n            _interop.invoke(\"T42.ACS.Feedback\", feedbackInfo, \"best\");\r\n        };\r\n        var info = {\r\n            coreVersion: version,\r\n            version: internalConfig.version\r\n        };\r\n        glueInitTimer.stop();\r\n        var glue = {\r\n            feedback: feedbackFunc,\r\n            info: info,\r\n            logger: _logger,\r\n            interop: _interop,\r\n            agm: _interop,\r\n            connection: _connection,\r\n            metrics: _metrics,\r\n            contexts: _contexts,\r\n            bus: _bus,\r\n            version: internalConfig.version,\r\n            userConfig: userConfig,\r\n            done: function () {\r\n                _logger === null || _logger === void 0 ? void 0 : _logger.info(\"done called by user...\");\r\n                return _connection.logout();\r\n            }\r\n        };\r\n        glue.performance = {\r\n            get glueVer() {\r\n                return internalConfig.version;\r\n            },\r\n            get glueConfig() {\r\n                return JSON.stringify(userConfig);\r\n            },\r\n            get browser() {\r\n                return window.performance.timing.toJSON();\r\n            },\r\n            get memory() {\r\n                return window.performance.memory;\r\n            },\r\n            get initTimes() {\r\n                var all = getAllTimers();\r\n                return Object.keys(all).map(function (key) {\r\n                    var t = all[key];\r\n                    return {\r\n                        name: key,\r\n                        duration: t.endTime - t.startTime,\r\n                        marks: t.marks,\r\n                        startTime: t.startTime,\r\n                        endTime: t.endTime\r\n                    };\r\n                });\r\n            }\r\n        };\r\n        Object.keys(libs).forEach(function (key) {\r\n            var lib = libs[key];\r\n            glue[key] = lib;\r\n        });\r\n        glue.config = {};\r\n        Object.keys(internalConfig).forEach(function (k) {\r\n            glue.config[k] = internalConfig[k];\r\n        });\r\n        if (ext && ext.extOptions) {\r\n            Object.keys(ext.extOptions).forEach(function (k) {\r\n                glue.config[k] = ext === null || ext === void 0 ? void 0 : ext.extOptions[k];\r\n            });\r\n        }\r\n        if (ext === null || ext === void 0 ? void 0 : ext.enrichGlue) {\r\n            ext.enrichGlue(glue);\r\n        }\r\n        if (glue42gd && glue42gd.updatePerfData) {\r\n            glue42gd.updatePerfData(glue.performance);\r\n        }\r\n        if (glue.agm) {\r\n            var deprecatedDecorator = function (fn, wrong, proper) {\r\n                return function () {\r\n                    glue.logger.warn(\"glue.js - 'glue.agm.\" + wrong + \"' method is deprecated, use 'glue.interop.\" + proper + \"' instead.\");\r\n                    return fn.apply(glue.agm, arguments);\r\n                };\r\n            };\r\n            var agmAny = glue.agm;\r\n            agmAny.method_added = deprecatedDecorator(glue.agm.methodAdded, \"method_added\", \"methodAdded\");\r\n            agmAny.method_removed = deprecatedDecorator(glue.agm.methodRemoved, \"method_removed\", \"methodRemoved\");\r\n            agmAny.server_added = deprecatedDecorator(glue.agm.serverAdded, \"server_added\", \"serverAdded\");\r\n            agmAny.server_method_aded = deprecatedDecorator(glue.agm.serverMethodAdded, \"server_method_aded\", \"serverMethodAdded\");\r\n            agmAny.server_method_removed = deprecatedDecorator(glue.agm.serverMethodRemoved, \"server_method_removed\", \"serverMethodRemoved\");\r\n        }\r\n        return glue;\r\n    }\r\n    return preloadPromise\r\n        .then(setupLogger)\r\n        .then(setupConnection)\r\n        .then(function () { return Promise.all([setupMetrics(), setupInterop(), setupContexts(), setupBus()]); })\r\n        .then(function () { return _interop.readyPromise; })\r\n        .then(function () {\r\n        return setupExternalLibs(internalConfig.libs || []);\r\n    })\r\n        .then(waitForLibs)\r\n        .then(constructGlueObject)\r\n        .catch(function (err) {\r\n        return Promise.reject({\r\n            err: err,\r\n            libs: libs\r\n        });\r\n    });\r\n};\r\nif (typeof window !== \"undefined\") {\r\n    window.GlueCore = GlueCore;\r\n}\r\nGlueCore.version = version;\r\nGlueCore.default = GlueCore;\n\nexport default GlueCore;\n//# sourceMappingURL=core.es.js.map\n","\"use strict\";\r\nfunction createRegistry(options) {\r\n    if (options && options.errorHandling\r\n        && typeof options.errorHandling !== \"function\"\r\n        && options.errorHandling !== \"log\"\r\n        && options.errorHandling !== \"silent\"\r\n        && options.errorHandling !== \"throw\") {\r\n        throw new Error(\"Invalid options passed to createRegistry. Prop errorHandling should be [\\\"log\\\" | \\\"silent\\\" | \\\"throw\\\" | (err) => void], but \" + typeof options.errorHandling + \" was passed\");\r\n    }\r\n    var _userErrorHandler = options && typeof options.errorHandling === \"function\" && options.errorHandling;\r\n    var callbacks = {};\r\n    function add(key, callback) {\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey) {\r\n            callbacksForKey = [];\r\n            callbacks[key] = callbacksForKey;\r\n        }\r\n        callbacksForKey.push(callback);\r\n        return function () {\r\n            var allForKey = callbacks[key];\r\n            if (!allForKey) {\r\n                return;\r\n            }\r\n            allForKey = allForKey.reduce(function (acc, element, index) {\r\n                if (!(element === callback && acc.length === index)) {\r\n                    acc.push(element);\r\n                }\r\n                return acc;\r\n            }, []);\r\n            callbacks[key] = allForKey;\r\n        };\r\n    }\r\n    function execute(key) {\r\n        var argumentsArr = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            argumentsArr[_i - 1] = arguments[_i];\r\n        }\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey || callbacksForKey.length === 0) {\r\n            return [];\r\n        }\r\n        var results = [];\r\n        callbacksForKey.forEach(function (callback) {\r\n            try {\r\n                var result = callback.apply(undefined, argumentsArr);\r\n                results.push(result);\r\n            }\r\n            catch (err) {\r\n                results.push(undefined);\r\n                _handleError(err, key);\r\n            }\r\n        });\r\n        return results;\r\n    }\r\n    function _handleError(exceptionArtifact, key) {\r\n        var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);\r\n        if (_userErrorHandler) {\r\n            _userErrorHandler(errParam);\r\n            return;\r\n        }\r\n        var msg = \"[ERROR] callback-registry: User callback for key \\\"\" + key + \"\\\" failed: \" + errParam.stack;\r\n        if (options) {\r\n            switch (options.errorHandling) {\r\n                case \"log\":\r\n                    return console.error(msg);\r\n                case \"silent\":\r\n                    return;\r\n                case \"throw\":\r\n                    throw new Error(msg);\r\n            }\r\n        }\r\n        console.error(msg);\r\n    }\r\n    function clear() {\r\n        callbacks = {};\r\n    }\r\n    return {\r\n        add: add,\r\n        execute: execute,\r\n        clear: clear\r\n    };\r\n}\r\n;\r\ncreateRegistry.default = createRegistry;\r\nmodule.exports = createRegistry;\r\n//# sourceMappingURL=index.js.map","'use strict';\nmodule.exports = require('./lib/index');\n","'use strict';\n\nvar randomFromSeed = require('./random/random-from-seed');\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nmodule.exports = {\n    characters: characters,\n    seed: setSeed,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n","'use strict';\nvar alphabet = require('./alphabet');\n\n/**\n * Decode the id to get the version and worker\n * Mainly for debugging and testing.\n * @param id - the shortid-generated id.\n */\nfunction decode(id) {\n    var characters = alphabet.shuffled();\n    return {\n        version: characters.indexOf(id.substr(0, 1)) & 0x0f,\n        worker: characters.indexOf(id.substr(1, 1)) & 0x0f\n    };\n}\n\nmodule.exports = decode;\n","'use strict';\n\nvar randomByte = require('./random/random-byte');\n\nfunction encode(lookup, number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nmodule.exports = encode;\n","'use strict';\n\nvar alphabet = require('./alphabet');\nvar encode = require('./encode');\nvar decode = require('./decode');\nvar isValid = require('./is-valid');\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1459707606518;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 6;\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId = require('./util/cluster-worker-id') || 0;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + encode(alphabet.lookup, version);\n    str = str + encode(alphabet.lookup, clusterWorkerId);\n    if (counter > 0) {\n        str = str + encode(alphabet.lookup, counter);\n    }\n    str = str + encode(alphabet.lookup, seconds);\n\n    return str;\n}\n\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet.characters(newCharacters);\n    }\n\n    return alphabet.shuffled();\n}\n\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.decode = decode;\nmodule.exports.isValid = isValid;\n","'use strict';\nvar alphabet = require('./alphabet');\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var characters = alphabet.characters();\n    var len = id.length;\n    for(var i = 0; i < len;i++) {\n        if (characters.indexOf(id[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nmodule.exports = isShortId;\n","'use strict';\n\nvar crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto\n\nfunction randomByte() {\n    if (!crypto || !crypto.getRandomValues) {\n        return Math.floor(Math.random() * 256) & 0x30;\n    }\n    var dest = new Uint8Array(1);\n    crypto.getRandomValues(dest);\n    return dest[0] & 0x30;\n}\n\nmodule.exports = randomByte;\n","'use strict';\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nmodule.exports = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n","'use strict';\n\nmodule.exports = 0;\n","'use strict';\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n","import { Glue42Office } from \"../glue4office\";\nimport { InternalConfig, LibConfigObject } from \"./types\";\n\ninterface InputModeObject {\n    mode?: boolean | string;\n}\n\ndeclare var global: any;\n\nexport default (options: Glue42Office.Config): InternalConfig => {\n\n    // Possible options per lib (this is InputLibConfig type)\n    // * false - library is disabled (e.g. config.appManager = false)\n    // * true - library is enabled in running in default mode (e.g config.appManager = true).\n    //          Exception is if default mode is false - in that case it runs default true mode.\n    // * string - start in some mode (e.g. config.appManager = \"full\")\n    // * object - allows further customization (e.g config.appManager = {mode: \"full\", someSetting: 42})\n    //\n    // Some libs support different running modes, some do not.\n    //\n    // Currently defaults are:\n    // appManager: disabled\n    // layouts: enabled in 'slim' mode\n    // activities: enabled in 'trackMyTypeAndInitiatedFromMe' mode\n    // windows: enabled (does not support modes)\n    // contexts: enabled (does not support modes)\n    //\n    // InputLibConfig is transformed to LibConfigObject\n\n    type InputLibConfig = boolean | string | InputModeObject;\n\n    /**\n     * Transforms InputLibConfig (the config as specified from the user)\n     * to LibConfigObject(internal library configuration)\n     */\n    function getLibConfig<T extends LibConfigObject>(value: InputLibConfig,\n                                                     defaultMode: boolean | string,\n                                                     trueMode?: boolean | string): T {\n\n        // if value is false return undefined\n        if (typeof value === \"boolean\" && !value) {\n            return undefined;\n        }\n\n        // find the mode of the library\n        const mode = getModeAsString(value, defaultMode, trueMode);\n\n        // if object we will replace the mode because appManager = {mode: true, setting: 42}\n        // should be turned into appManager = {mode: 'slim', setting: 42}\n        if (typeof value === \"object\") {\n            value.mode = mode;\n            return value as T;\n        }\n\n        return {\n            mode,\n        } as T;\n    }\n\n    /**\n     * Finds the mode based for a given library\n     * 1. If object we call recursively using object.mode for value\n     * 1. If the user hasn't specified anything we use the hard coded defaults\n     * 3. If the value is false or it got defaulted to false, we return undefined\n     * 4. If the value is true we return trueMode or defaultMode (if trueMode is undefined)\n     */\n    function getModeAsString(value: InputLibConfig,\n                             defaultMode: boolean | string,\n                             trueMode?: boolean | string): string {\n\n        // 1. if object\n        if (typeof value === \"object\") {\n            return getModeAsString(value.mode, defaultMode, trueMode) + \"\";\n        } else if (typeof value === \"undefined\") {\n            // 2. if the user does not pass anything\n\n            // 3. if gets defaulted to false, the library should be off\n            if (typeof defaultMode === \"boolean\" && !defaultMode) {\n                return undefined;\n            } else {\n                return defaultMode + \"\";\n            }\n        } else if (typeof value === \"boolean\") {\n            // 4. if the user passes true, use trueMode or defaultMode\n            if (value) {\n                // if the user passes true, use trueMode or defaultMode\n                return ((trueMode === undefined) ? defaultMode : trueMode) + \"\";\n            } else {\n                 // 3. if the user passes false, the library should be off\n                return undefined;\n            }\n        }\n\n        return value + \"\";\n    }\n\n    return {\n        outlook: getLibConfig<LibConfigObject>(options.outlook, true),\n        excel: getLibConfig<LibConfigObject>(options.excel, true),\n        word: getLibConfig<LibConfigObject>(options.word, true),\n    };\n};\n","export const ShowGridMethodName: string = \"T42.ExcelPad.ShowGrid\";\r\nexport const ValidateShowGridMethodName: string = \"ValidateShowGrid\";\r\n","import CallbackFactory, { CallbackRegistry, UnsubscribeFunction } from \"callback-registry\";\nimport { Glue42Office } from \"../../glue4office\";\nimport { ShowGridMethodName, ValidateShowGridMethodName } from \"./const\";\nimport SheetFactory from \"./sheet\";\nimport { Excel, ShowGridParams, ValidateShowGridInvocationArgs } from \"./types\";\nimport { convertParams, parseAgmResult, getSheetId, sheetIdSeparator } from \"./utils\";\n\nimport { Glue42Core } from \"@glue42/core\";\n\nimport { version } from \"../version\";\nimport SheetImpl from \"./sheet\";\nimport ColumnConfig = Glue42Office.Excel.ColumnConfig;\nimport OpenSheetOptions = Glue42Office.Excel.OpenSheetOptions;\n\nexport default class ExcelImp implements Excel {\n    public get all(): Glue42Office.Excel.Sheet[] {\n        return Object.keys(this._sheets).map((k) => {\n            return this._sheets[k].asSheetAPI;\n        });\n    }\n\n    public get addinStatus(): boolean {\n        return this._isExcelStarted;\n    }\n\n    private _registry: CallbackRegistry = CallbackFactory();\n    private _agm: Glue42Core.AGM.API;\n    private _sheets: { [key: string]: SheetFactory } = {};\n    private _isExcelStarted: boolean = false;\n\n    constructor(agm: Glue42Core.AGM.API) {\n        this._agm = agm;\n    }\n\n    public init = (): Promise<void> => {\n        return this.registerAgmMethod();\n    }\n\n    public openSheet = (sheetData: Glue42Office.Excel.OpenSheetConfig): Promise<Glue42Office.Excel.Sheet> => {\n        return new Promise((resolve, reject) => {\n            if (!sheetData) {\n                reject(\"Can not open a sheet without config\");\n                return;\n            }\n\n            if (!sheetData.columnConfig || !Array.isArray(sheetData.columnConfig)) {\n                reject(\"Missing or incorrect type `columnConfig` property\");\n                return;\n            }\n\n            if (!sheetData.data || !Array.isArray(sheetData.data)) {\n                reject(\"Missing or incorrect type of `data` property\");\n                return;\n            }\n            const convertedParams = convertParams(sheetData.columnConfig, sheetData.data, sheetData.options);\n            const successHandler = (r: any) => {\n                if (parseAgmResult(r)) {\n                    const { worksheet, workbook } = sheetData.options;\n                    const id = convertedParams.params.cookie || getSheetId(workbook, worksheet);\n                    const sheet = this.createSheet(id, sheetData, false);\n                    resolve(sheet.asSheetAPI);\n                }\n            };\n\n            const errorHandler = (err: any) => {\n                reject(err);\n            };\n            return this.invokeShowGridMethod(convertedParams.params, convertedParams.agmOptions).then(successHandler).catch(errorHandler);\n        });\n    }\n\n    public onAddinStatusChanged = (callback: (connected: boolean) => void): UnsubscribeFunction => {\n        return this._registry.add(\"onAddinStatusChanged\", callback);\n    }\n\n    public getWorkbooks = async (): Promise<Glue42Office.Excel.Book[]> => {\n        const result = await this._agm.invoke(\"T42.ExcelScript.GetState\");\n        const workbooks = result.returned.state;\n\n        const parsed = workbooks.map((book: any) => {\n            const worksheets = book.worksheets.map(({ name }: { name: string }) => {\n                const id = this.getCookieFromState(book) || getSheetId(book.name, name);\n                let sheet = this._sheets[id];\n                if (!sheet) {\n                    sheet = this.createSheet(id, { columnConfig: [], options: { worksheet: name, workbook: book.name } }, false);\n                }\n                return sheet.asSheetAPI;\n            });\n            return { ...book, worksheets };\n        });\n\n        return parsed;\n    }\n\n    public getWorksheets = async (): Promise<Glue42Office.Excel.Sheet[]> => {\n        const result = await this._agm.invoke(\"T42.ExcelScript.GetState\");\n        const workbooks = result.returned.state;\n\n        const workSheets: Glue42Office.Excel.Sheet[] = [];\n        workbooks.forEach((book: any) => {\n            book.worksheets.forEach(({ name }: { name: string }) => {\n                const id = this.getCookieFromState(book) || getSheetId(book.name, name);\n                let sheet = this._sheets[id];\n                if (!sheet) {\n                    sheet = this.createSheet(id, { columnConfig: [], options: { worksheet: name, workbook: book.name } }, false);\n                }\n                workSheets.push(sheet.asSheetAPI);\n            });\n        });\n\n        return workSheets;\n    }\n\n    public onNewWorksheet = (callback: (sheet: Glue42Office.Excel.Sheet) => void): UnsubscribeFunction => {\n        return this._registry.add(\"onNewWorksheet\", callback);\n    }\n\n    private getCookieFromState = (book: any) => {\n        const keyName = \"ExcelPad.cookie\";\n\n        const cookieState = book?.modulesState?.find((state: { key: string, value: any }) => state?.key === keyName);\n        return cookieState?.value;\n    }\n\n    private createSheet = (id: string, sheetData: Glue42Office.Excel.OpenSheetConfig = { columnConfig: [] }, fireEvent = true): SheetImpl => {\n        const sheet = new SheetFactory(id, sheetData, this.invokeShowGridMethod.bind(this));\n        this._sheets[id] = sheet;\n\n        if (fireEvent) {\n            this._registry.execute(\"onNewWorksheet\", sheet.asSheetAPI);\n        }\n\n        return sheet;\n    }\n\n    private createExcelFirstSheet = (id: string, args: ValidateShowGridInvocationArgs, fireEvent = true): SheetImpl => {\n        const { worksheet, workbook } = args;\n        // Excel First\n        // this._workbooks[workbook][worksheet] = {};\n        const columnConfig: ColumnConfig[] = JSON.parse(args.columnsAsJSON)\n            .map((columnName: string) => ({ fieldName: columnName?.toLowerCase(), header: columnName }));\n\n        const data = JSON.parse(args.dataAsJSON);\n        // TODO: refactor\n        const options: OpenSheetOptions = { worksheet, workbook, response: \"image\" };\n\n        return this.createSheet(id, { columnConfig, data, options }, fireEvent);\n    }\n\n    private async registerAgmMethod(): Promise<void> {\n        await this._agm.register({\n            name: ValidateShowGridMethodName,\n            accepts: \"string cookie, string workbook, string worksheet, string updateType, string dataAsJSON\",\n        }, async (args: ValidateShowGridInvocationArgs, caller: Glue42Core.AGM.Instance) => {\n            // tslint:disable-next-line:no-console\n            console.log(\"args\", args, this._sheets);\n            const { cookie, workbook, worksheet } = args;\n            if (workbook && worksheet) {\n                const id = cookie || getSheetId(workbook, worksheet);\n                let currentSheet = this._sheets[id];\n                if (!currentSheet) {\n                    currentSheet = this.createExcelFirstSheet(id, args);\n                } else {\n                    const asSheetAPI = currentSheet.asSheetAPI;\n                    const wasPartiallyCreatedOnGet = !asSheetAPI.columnConfig || asSheetAPI.columnConfig.length === 0 || !asSheetAPI.workbook;\n\n                    if (wasPartiallyCreatedOnGet) {\n                        currentSheet = this.createExcelFirstSheet(id, args);\n                    }\n                }\n                const result = await currentSheet._onUpdate(args);\n                return result;\n            }\n            return undefined;\n        });\n\n        const methods = await this._agm.methods({ name: ShowGridMethodName });\n\n        const waitForMethod = () => new Promise((resolve) => {\n            this._agm.methodAdded((method) => {\n                if (method.name === ShowGridMethodName) {\n                    this._isExcelStarted = true;\n                    this._registry.execute(\"onAddinStatusChanged\", true);\n                    resolve();\n                }\n            });\n        });\n\n        if (methods.length !== 0) {\n            this._isExcelStarted = true;\n            this._registry.execute(\"onAddinStatusChanged\", true);\n        } else {\n            // not awaited because we want to resolve the factory function\n            waitForMethod();\n        }\n\n        this._agm.methodRemoved((method) => {\n            if (method.name === ShowGridMethodName) {\n                waitForMethod();\n                this._isExcelStarted = false;\n                this._registry.execute(\"onAddinStatusChanged\", false);\n            }\n        });\n    }\n\n    private invokeShowGridMethod(params: ShowGridParams, agmOptions: Glue42Core.AGM.InvokeOptions): Promise<object> {\n        params.g4oVersion = version;\n        return new Promise<object>((resolve, reject) => {\n            if (this._isExcelStarted) {\n                (agmOptions as any).method_response_timeout = agmOptions.methodResponseTimeoutMs;\n                this._agm.invoke(ShowGridMethodName, params, null, agmOptions)\n                    .then((response) => {\n                        resolve(response);\n                    }).catch((e) => {\n                    reject(e);\n                });\n            } else {\n                reject(\"Microsoft Excel with Tick42 Add-in is not running\");\n            }\n        });\n    }\n}\n","import { Glue42Office } from \"../../glue4office\";\nimport { Config } from \"./types\";\nimport Excel from \"./excel\";\n\nexport default (config: Config): Glue42Office.Excel.API => {\n    const excel = new Excel(config.agm);\n\n    const methodsRegistered = excel.init();\n\n    async function ready(): Promise<Glue42Office.Excel.API> {\n        await methodsRegistered;\n        return api;\n    }\n\n    const api: Glue42Office.Excel.API = {\n        ready,\n        openSheet: excel.openSheet,\n        get sheets(): Glue42Office.Excel.Sheet[] {\n            return excel.all;\n        },\n        onAddinStatusChanged: excel.onAddinStatusChanged,\n        onNewWorksheet: excel.onNewWorksheet,\n        get addinStatus() {\n            return excel.addinStatus;\n        },\n        getWorkbooks: excel.getWorkbooks,\n        getWorksheets: excel.getWorksheets,\n    };\n\n    return api;\n};\n","import { CallbackRegistry, default as CallbackFactory, UnsubscribeFunction } from \"callback-registry\";\nimport { Glue42Office } from \"../../glue4office\";\nimport {\n    InternalSheetAPI, ShowGridParams, ValidateShowGridInvocationArgs, ValidationResponse,\n} from \"./types\";\n\nimport { convertParams, flatten, camelize } from \"./utils\";\n\nasync function executeAsync(registry: CallbackRegistry, key: any, ...args: any[]): Promise<any> {\n    const results: any[] = registry.execute(key, ...args);\n    // tslint:disable-next-line:no-console\n    await Promise.all(results.map(async (result) => {\n        if (result && typeof result.then === \"function\") {\n            await result;\n        }\n        return result;\n    }));\n}\n\nexport default class SheetImpl implements InternalSheetAPI {\n    public get asSheetAPI(): Glue42Office.Excel.Sheet {\n        const that = this;\n        if (!this._sheet) {\n            this._sheet = {\n                name: this._name,\n                workbook: this._workbook,\n                options: this._options,\n                get data() {\n                    return that._data;\n                },\n                get columnConfig() {\n                    return that._columns;\n                },\n                update: (data: object[]): Promise<void> => this.update(data),\n                onChanged: (callback: (data: object[], errorCallback: (errors: Glue42Office.Excel.ValidationError[]) => void, doneCallback: () => void, delta: Glue42Office.Excel.DeltaItem[]) => Promise<void>): UnsubscribeFunction => this.onChanged(callback),\n                onChanging: (callback: (info: Glue42Office.Excel.SheetChangingInfo) => void): UnsubscribeFunction => this.onChanging(callback),\n                changeColumnConfig: (columnConfig: Glue42Office.Excel.ColumnConfig[], data?: object[]): Promise<void> => this.changeColumnConfig(columnConfig, data),\n            };\n        }\n        return this._sheet;\n    }\n\n    private _sheet: Glue42Office.Excel.Sheet;\n    private _registry: CallbackRegistry = CallbackFactory({ errorHandling: \"throw\" });\n\n    private _id: string;\n    private _name: string;\n    private _data: any;\n    private _workbook: string;\n    private _columns: Glue42Office.Excel.ColumnConfig[];\n    private _options: Glue42Office.Excel.OpenSheetOptions;\n    private _validationResponse: ValidationResponse;\n    private _invokeMethod: (params: any, options: any) => Promise<object>;\n    private _deltaCache: Glue42Office.Excel.DeltaItem[][];\n\n    constructor(id: string, config: Glue42Office.Excel.OpenSheetConfig, invokeShowGrid: (params: any, options: any) => Promise<object>) {\n        this._id = id;\n        this._name = config.options ? config.options.worksheet : \"\";\n        this._data = config.data;\n        this._workbook = config.options ? config.options.workbook : \"\";\n        this._columns = config.columnConfig;\n        this._options = config.options;\n        this._invokeMethod = invokeShowGrid;\n    }\n\n    public changeColumnConfig(columnConfig: Glue42Office.Excel.ColumnConfig[], data?: object[]): Promise<void> {\n        return new Promise<void>((resolve, reject): void => {\n            if (!columnConfig) {\n                reject(\"Can not change column in the sheet without columnConfig\");\n                return;\n            }\n            if (!data) {\n                data = this._data;\n            }\n            const convertedParams = convertParams(columnConfig, data, this._options, this._id);\n            const successHandler = () => {\n                this._data = data;\n                resolve();\n            };\n            this._invokeMethod(convertedParams.params, convertedParams.agmOptions)\n                .then(successHandler)\n                .catch(reject);\n        });\n    }\n\n    public update(data: object[]): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            if (!data || !Array.isArray(data)) {\n                reject(\"Can not update sheet with empty or incorrect type `data`\");\n                return;\n            }\n            const convertedParams = convertParams(this._columns, data, this._options, this._id);\n\n            this._invokeMethod(convertedParams.params, convertedParams.agmOptions)\n                .then(() => {\n                    // this._data = [...data];\n                    resolve();\n                })\n                .catch(reject);\n        });\n    }\n\n    public onChanged(\n        callback: (\n            data: object,\n            errorCallback: (errors: Glue42Office.Excel.ValidationError[]) => void,\n            doneCallback: () => void,\n            delta: Glue42Office.Excel.DeltaItem[]) => Promise<void>): UnsubscribeFunction {\n        return this._registry.add(\"on-changed\", (data, error, done, delta) => callback(data, error, done, delta));\n    }\n\n    public onChanging(\n        callback: (info: Glue42Office.Excel.SheetChangingInfo) => void): UnsubscribeFunction {\n        return this._registry.add(\"on-changing\", callback);\n    }\n\n    public async _onUpdate(args: ValidateShowGridInvocationArgs): Promise<ValidationResponse> {\n        this._name = args.worksheet;\n        this._workbook = args.workbook;\n        let delta: Glue42Office.Excel.DeltaItem[];\n        let columns: any;\n\n        this._registry.execute(\n            \"on-changing\",\n            {\n                chunkIndex: args.chunkIndex,\n                totalChunks: args.totalChunks,\n            });\n\n        try {\n            delta = JSON.parse(args.dataAsJSON);\n            columns = JSON.parse(args.columnsAsJSON);\n        } catch (error) {\n            this._deltaCache = null;\n            // tslint:disable-next-line:no-console\n            console.error(error);\n            return;\n        }\n\n        // Merge with current data\n        this._data = this.mergeData(args, delta, columns);\n\n        if (!args.totalChunks ||\n            args.updateType !== \"row\") {\n            this._deltaCache = null;\n        } else {\n            if (args.chunkIndex === 0) {\n                this._deltaCache = [delta];\n            } else if (this._deltaCache) {\n                this._deltaCache.push(delta);\n            }\n        }\n\n        if (!args.totalChunks ||\n            args.chunkIndex === args.totalChunks - 1) {\n            try {\n                const allDeltas = this._deltaCache && flatten(this._deltaCache);\n                await executeAsync(this._registry,\n                    \"on-changed\",\n                    this._data,\n                    this.errorCallback,\n                    this.doneCallback,\n                    allDeltas);\n\n            } finally {\n                this._deltaCache = null;\n            }\n\n        } else {\n            this._validationResponse = {\n                isValid: true,\n            };\n        }\n        return this._validationResponse;\n    }\n\n    private errorCallback = (errors: Glue42Office.Excel.ValidationError[]) => {\n        this._validationResponse = {\n            isValid: false,\n            errorsAsJSON: JSON.stringify(errors),\n        };\n    }\n\n    private doneCallback = () => {\n        this._validationResponse = {\n            isValid: true,\n        };\n    }\n\n    private mergeData(\n        args: ValidateShowGridInvocationArgs,\n        delta: Glue42Office.Excel.DeltaItem[],\n        columnConfig: Glue42Office.Excel.ColumnConfig[]): object[] {\n        if (args.updateType === \"image\") {\n            let columnHeaderRow = delta.find((d) => d.rowAfterIndex === 1)?.row;\n            // tslint:disable-next-line:no-console\n\n            if (!columnHeaderRow) {\n                columnHeaderRow = [...columnConfig];\n                if (!columnHeaderRow || columnHeaderRow.length === 0) {\n                    // tslint:disable-next-line:no-console\n                    console.error(\"No columns received update will be ignored !\");\n                }\n            }\n\n            const data = delta.reduce((res, currDelta, index) => {\n                if (index !== 0) {\n                    const row: any = {};\n                    currDelta.row.forEach((rowValue, col) => {\n                        const colHeader = columnHeaderRow[col];\n                        if (colHeader !== undefined && colHeader !== null) {\n                            const headerSameAsConfig = columnConfig.find((c) => c.header === colHeader);\n                            let colName;\n                            if (headerSameAsConfig) {\n                                colName = headerSameAsConfig.fieldName || camelize(colHeader);\n                            } else {\n                                colName = camelize(colHeader);\n                            }\n                            row[colName] = rowValue;\n                        }\n                    });\n\n                    res.push(row);\n                }\n                return res;\n            }, [] as object[]);\n\n            return data;\n        }\n\n        let dataAfterMerged: object[] = [];\n        const isRowMode: boolean = (args.updateType === \"row\");\n        if (isRowMode) {\n            // We need to add the old data, because our mode is row, so we\n            // will receive only the rows, which are modified, deleted and inserted\n            dataAfterMerged = [...this._data];\n        }\n\n        // G4E-1089 - in case of deletion, apply changes back-to-front to avoid having to recalculate\n        // indices after every deletion\n        // NB:  we're expecting changed chunks to come in reverse order for the same reason (otherwise the Excel plugin\n        // would have to do the recalculation itself)\n        const from = (delta[0].action === \"deleted\" ? delta.length - 1 : 0);\n        const toExclusive = (delta[0].action === \"deleted\" ? -1 : delta.length);\n        const step = (delta[0].action === \"deleted\" ? -1 : +1);\n        for (let ii = from; ii !== toExclusive; ii += step) {\n            const deltaItem = delta[ii];\n\n            const { rowBeforeIndex, rowAfterIndex, action, row, rowAfter: deltaRowAfter } = deltaItem;\n\n            const beforeActualIndex = rowBeforeIndex - 1;\n            const afterActualIndex = rowAfterIndex - 1;\n            const rowAfter = deltaRowAfter || row;\n\n            // delta between rowAfter and rowBefore in case of 'row'\n            // in case of 'image', the actual row\n            if (!action || !isRowMode) {\n                if (rowAfter.length) {\n                    const obj = {};\n                    this._columns.forEach((x, i) => {\n                        obj[x.fieldName] = rowAfter[i];\n                    });\n                    dataAfterMerged[afterActualIndex] = obj;\n                } else {\n                    dataAfterMerged[afterActualIndex] = rowAfter;\n                }\n            } else if (action === \"unchanged\") {\n                // This action is used only in image mode, so we need to copy the unchanged data to the updated index\n                dataAfterMerged[afterActualIndex] = this._data[beforeActualIndex];\n            } else if (action === \"deleted\") {\n                // We need to delete a certain row, only if we are in row mode\n                // if we are in image mode, we don't care for deleted rows\n                if (isRowMode) {\n                    dataAfterMerged.splice(beforeActualIndex >= 0 ? beforeActualIndex : 0, deltaItem.count || 1);\n                }\n            } else if (action === \"modified\") {\n                Object.keys(row).forEach((i) => {\n                    const updateFieldData = row[i];\n                    if (updateFieldData === null &&\n                        (!rowAfter || rowAfter[i] || rowAfter[i] === \"\" || rowAfter[i] === 0)) {\n                        // this means that the data in this field is unchanged\n                        return;\n                    }\n                    const fieldName: string = this._columns[i].fieldName;\n                    const rowData: any = this._data[beforeActualIndex];\n                    rowData[fieldName] = updateFieldData;\n                    dataAfterMerged[beforeActualIndex] = rowData;\n                });\n            } else if (action === \"inserted\") {\n                const insertedObj: any = {};\n                Object.keys(rowAfter).forEach((updateFieldDataIx, i) => {\n                    const fieldName: string = this._columns[i].fieldName;\n                    insertedObj[fieldName] = rowAfter[updateFieldDataIx] || undefined;\n                });\n                dataAfterMerged.splice(beforeActualIndex, 0, insertedObj);\n            }\n        }\n\n        return dataAfterMerged;\n    }\n}\n","import { Glue42Core } from \"@glue42/core\";\nimport { Glue42Office } from \"../../glue4office\";\nimport { ColumnsAsJson, DataAsJson, ShowGridInvocationResult, ShowGridParams, ValidationObject } from \"./types\";\n\nconst shortid = require(\"shortid\");\n\nfunction getColumnsAsJson(columns: Glue42Office.Excel.ColumnConfig[]): ColumnsAsJson[] {\n    const modifiedColumns = columns.map((col: Glue42Office.Excel.ColumnConfig) => {\n        const column: ColumnsAsJson = {\n            name: col.fieldName || \"\",\n            text: col.header || col.fieldName,\n            foregroundColor: col.foregroundColor || \"\",\n            backgroundColor: col.backgroundColor || \"\",\n            width: isNumber(col.width) ? col.width : null,\n        };\n\n        if (col.validation) {\n            column.validation = {\n                type: (\"xlValidate\" + col.validation.type) as any,\n                alert: (\"xlValidAlert\" + col.validation.alert) as any,\n                list: col.validation.list || null,\n            };\n        }\n\n        return column;\n    });\n\n    return modifiedColumns;\n}\n\n// https://stackoverflow.com/a/36643588/1527706\nfunction formatDate(date: Date) {\n    const timezoneOffsetInHours = -(date.getTimezoneOffset() / 60); // UTC minus local time\n    const sign = timezoneOffsetInHours >= 0 ? \"+\" : \"-\";\n    const leadingZero = (Math.abs(timezoneOffsetInHours) < 10) ? \"0\" : \"\";\n\n    const correctedDate = new Date(date.getFullYear(), date.getMonth(),\n        date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(),\n        date.getMilliseconds());\n    correctedDate.setHours(date.getHours() + timezoneOffsetInHours);\n    const iso = correctedDate.toISOString().replace(\"Z\", \"\");\n\n    let suffix = (date.getTimezoneOffset() % 60) + \"\";\n    if (suffix.length < 2) {\n        suffix = \"0\" + suffix;\n    }\n    return iso + sign + leadingZero + Math.abs(timezoneOffsetInHours).toString() + \":\" + suffix;\n}\n\nfunction getDataAsJson(columns: Glue42Office.Excel.ColumnConfig[], data: object[]): DataAsJson[] {\n    const modifiedData = data.map((row: any) => {\n        const dataList: any = [];\n        columns\n            .map((col: Glue42Office.Excel.ColumnConfig) => ({ forceText: col.forceText, preserveEmptyString: col.preserveEmptyString, name: col.fieldName }))\n            .forEach(({ forceText, preserveEmptyString, name }: { forceText: boolean, preserveEmptyString: boolean, name: string }) => {\n                const rowValue = row[name] || row[name.toLowerCase()]\n                    || row[Object.keys(row).find((key) => key.toLowerCase() === name.toLowerCase())];\n\n                let item;\n                if (forceText && isFinite(rowValue)) {\n                    item = \"'\" + rowValue;\n                } else if (preserveEmptyString && (rowValue === null || rowValue === undefined || rowValue === \"\")) {\n                    item = \"'\";\n                } else if (typeof rowValue === \"number\" && isFinite(rowValue)) {\n                    item = rowValue;\n                } else if (rowValue instanceof Date) {\n                    item = formatDate(rowValue);\n                } else {\n                    item = rowValue || \"\";\n                }\n                dataList.push(item);\n            });\n\n        return { data: dataList };\n    });\n\n    return modifiedData;\n}\n\nfunction getShowGridParams(options: Glue42Office.Excel.OpenSheetOptions): Partial<ShowGridParams> {\n    // This is object, which is used to convert options from friendly name to the method\"s params and sets the default value\n    const methodOptions: any = {\n        clearGrid: {\n            default: true,\n            friendlyName: undefined,\n        },\n        workbook: {\n            default: shortid.generate(),\n            friendlyName: undefined,\n        },\n        dataWorksheet: {\n            default: shortid.generate(),\n            friendlyName: \"worksheet\",\n        },\n        templateWorkbook: undefined,\n        viewWorksheet: {\n            friendlyName: \"templateWorksheet\",\n        },\n        inhibitLocalSave: undefined,\n        glueMethod: {\n            default: \"ValidateShowGrid\",\n            friendlyName: undefined,\n        },\n        buttonText: undefined,\n        buttonRange: {\n            default: \"A1\",\n            friendlyName: undefined,\n        },\n        topLeft: {\n            default: \"A1\",\n            friendlyName: undefined,\n        },\n        triggers: {\n            default: [\"save\"],\n            friendlyName: \"updateTrigger\",\n        },\n        dataRangeName: undefined,\n        window: undefined,\n        chunkSize: {\n            default: 1000,\n            friendlyName: undefined,\n        },\n        disableErrorViewer: undefined,\n        autostart: undefined,\n        displayName: undefined,\n        timeoutMs: undefined,\n    };\n\n    const updatedOptions: Partial<ShowGridParams> = {};\n    options = options || {};\n\n    Object.keys(methodOptions).forEach((key: string) => {\n        const value = methodOptions[key];\n        const friendlyName = value ? value.friendlyName : undefined;\n        const defaultValue = value ? value.default : undefined;\n\n        if (friendlyName) {\n            updatedOptions[key] = (options as any)[friendlyName];\n        } else {\n            updatedOptions[key] = (options as any)[key];\n        }\n\n        if (value && updatedOptions[key] === undefined) {\n            updatedOptions[key] = defaultValue;\n        }\n    });\n\n    for (const key in options) {\n        if ((!(key in methodOptions) ||\n            (methodOptions[key] &&\n                methodOptions[key].friendlyName &&\n                methodOptions[key].friendlyName !== key)) &&\n            !Object.keys(methodOptions).some((x) => methodOptions[x] && methodOptions[x].friendlyName === key)) {\n            updatedOptions[key] = options[key];\n        }\n    }\n\n    return updatedOptions;\n}\n\nfunction isNumber(n: any) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nexport function parseAgmResult(r: Glue42Core.AGM.InvocationResult<ShowGridInvocationResult>): boolean {\n    let resp: boolean;\n    try {\n        resp = JSON.parse(r.returned.result).success;\n    } catch (error) {\n        resp = false;\n    }\n    return resp;\n}\n\nexport function convertParams(\n    columns: Glue42Office.Excel.ColumnConfig[],\n    data: object[],\n    options: Glue42Office.Excel.OpenSheetOptions,\n    cookie?: string): { params: ShowGridParams, agmOptions: Glue42Core.AGM.InvokeOptions } {\n    const params: ShowGridParams = {\n        columnsAsJSON: JSON.stringify(getColumnsAsJson(columns)),\n        dataAsJSON: JSON.stringify(getDataAsJson(columns, data)),\n        cookie: cookie ? cookie : shortid.generate(),\n        response: options.response === \"image\" ? \"image\" : \"row\",\n    };\n    const agmOptions = options && { methodResponseTimeoutMs: options.timeoutMs };\n\n    // the point of this call is to populate defaults and map friendly names to agm names\n    const mappedParams: Partial<ShowGridParams> = getShowGridParams(options);\n    // Workaround for Object.assign(params, op);\n    const combinedParams = { ...params, ...mappedParams };\n\n    // get rid of AGM options\n    delete combinedParams.timeoutMs;\n\n    return {\n        params: combinedParams,\n        agmOptions,\n    };\n}\n\nexport function flatten(arr: any[][]) {\n    const flattenedArray = [];\n    // tslint:disable-next-line:prefer-for-of\n    for (let ii = 0; ii < arr.length; ++ii) {\n        const current = arr[ii];\n        flattenedArray.push.apply(flattenedArray, current);\n    }\n    return flattenedArray;\n}\n\nexport function camelize(str: string) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w|\\s+)/g, (match, index) => {\n        if (+match === 0) {\n            return \"\";\n        }\n        // or if (/\\s+/.test(match)) for white spaces\n        return index === 0 ? match.toLowerCase() : match.toUpperCase();\n    });\n}\n\nexport const sheetIdSeparator = \"_\";\n\nexport function getSheetId(workbook: string, worksheet: string) {\n    return workbook + sheetIdSeparator + worksheet;\n}\n","import CoreFactory, { Glue42Core } from \"@glue42/core\";\nimport { Glue42Office } from \"../glue4office\";\nimport word from \"./word/main\";\nimport excel from \"./excel/main\";\nimport outlook from \"./outlook/main\";\n\nimport prepareConfig from \"./config\";\nimport { version } from \"./version\";\n\nexport default (options: Glue42Office.Config): Promise<Glue42Office.Glue4Office> => {\n\n    // get config object\n    // basically selecting some properties (and defaulting them)\n    // it's used to extract things like layouts, appManager, activities etc things\n    // that glueCore itself doesn't know about\n    options = options || {};\n    const glueConfig = prepareConfig(options);\n\n    function createOutlook(core: Glue42Core.GlueCore) {\n        if (glueConfig.outlook) {\n            return outlook({ agm: core.agm });\n        }\n    }\n\n    function createExcel(core: Glue42Core.GlueCore): Glue42Office.Excel.API {\n        if (glueConfig.excel) {\n            return excel({ agm: core.agm });\n        }\n    }\n\n    function createWord(core: Glue42Core.GlueCore) {\n        if (glueConfig.word) {\n            return word({ agm: core.agm });\n        }\n    }\n\n    const ext: Glue42Core.Extension = {\n        // define extra libraries for glue-core to raise\n        libs: [\n            { name: \"outlook\", create: createOutlook },\n            { name: \"excel\", create: createExcel },\n            { name: \"word\", create: createWord },\n        ],\n\n        version,\n\n        enrichGlue: (glue: Glue42Core.GlueCore) => {\n            // put some data to config\n            glue.config.outlook = glueConfig.outlook;\n            glue.config.excel = glueConfig.excel;\n            glue.config.word = glueConfig.word;\n        },\n    };\n\n    function extendExistingGlue(glue: any) {\n        glue.outlook = createOutlook(glue);\n        glue.excel = createExcel(glue);\n        glue.word = createWord(glue);\n\n        ext.enrichGlue(glue);\n    }\n\n    // users can pass existing glue object (that can be glue-core or glue)\n    // in that case it will be extended with office libs\n    if (options.glue) {\n        extendExistingGlue(options.glue);\n        return Promise.resolve(options.glue);\n    }\n\n    return CoreFactory(options, ext) as any as Promise<Glue42Office.Glue4Office>;\n};\n","// we need to use export = to simulate default export for CommonJS format\n// this file is the main entry point for CommonJS modules, the rest use main.ts\nimport Glue4Office from \"./main\";\nexport = Glue4Office;\n","import CreateGlue4Office from \"./glue4office\";\nimport { version } from \"./version\";\n\n// add version num to factory function\n(CreateGlue4Office as any).version = version;\n\nif (typeof window !== \"undefined\") {\n    (window as any).Glue4Office = CreateGlue4Office;\n}\n\n// add default library for ES6 modules\n(CreateGlue4Office as any).default = CreateGlue4Office;\n\nexport default CreateGlue4Office;\n","import {ChunkData} from \"../types\";\r\n\r\nexport class ChunkDataDictionary implements ChunkData {\r\n    private items: { [key: string]: string[] } = {};\r\n\r\n    public containsKey(key: string): boolean {\r\n        return this.items.hasOwnProperty(key);\r\n    }\r\n\r\n    public add(key: string, value: string): void {\r\n        if (this.containsKey(key)) {\r\n            this.items[key].push(value);\r\n        } else {\r\n            this.items[key] = [value];\r\n        }\r\n    }\r\n\r\n    public remove(key: string): void {\r\n        delete this.items[key];\r\n    }\r\n\r\n    public get(key: string): string[] {\r\n        return this.items[key];\r\n    }\r\n}\r\n\r\nexport default new ChunkDataDictionary();\r\n","import {CreateItem, CreateItemCallbacks} from \"../types\";\r\n\r\nexport class CreateItemDictionary implements CreateItem {\r\n    private items: { [key: string]: CreateItemCallbacks } = {};\r\n\r\n    public containsKey(key: string): boolean {\r\n        return this.items.hasOwnProperty(key);\r\n    }\r\n\r\n    public add(key: string, value: CreateItemCallbacks): void {\r\n        this.items[key] = value;\r\n    }\r\n\r\n    public remove(key: string): void {\r\n        delete this.items[key];\r\n    }\r\n\r\n    public get(key: string): CreateItemCallbacks {\r\n        return this.items[key];\r\n    }\r\n}\r\n\r\nexport default new CreateItemDictionary();\r\n","import {GetAttachment, GetAttachmentCallback} from \"../types\";\r\n\r\nexport class GetAttachmentDictionary implements GetAttachment {\r\n    private items: { [key: string]: GetAttachmentCallback } = {};\r\n\r\n    public containsKey(key: string): boolean {\r\n        return this.items.hasOwnProperty(key);\r\n    }\r\n\r\n    public add(key: string, value: GetAttachmentCallback): void {\r\n        this.items[key] = value;\r\n    }\r\n\r\n    public remove(key: string): void {\r\n        delete this.items[key];\r\n    }\r\n\r\n    public get(key: string): GetAttachmentCallback {\r\n        return this.items[key];\r\n    }\r\n}\r\n\r\nexport default new GetAttachmentDictionary();\r\n","import {GetItemAsMsg, PromiseCallback} from \"../types\";\r\n\r\nexport class GetItemAsMsgDictionary implements GetItemAsMsg {\r\n    private items: { [key: string]: PromiseCallback } = {};\r\n\r\n    public containsKey(key: string): boolean {\r\n        return this.items.hasOwnProperty(key);\r\n    }\r\n\r\n    public add(key: string, value: PromiseCallback): void {\r\n        this.items[key] = value;\r\n    }\r\n\r\n    public remove(key: string): void {\r\n        delete this.items[key];\r\n    }\r\n\r\n    public get(key: string): PromiseCallback {\r\n        return this.items[key];\r\n    }\r\n}\r\n\r\nexport default new GetItemAsMsgDictionary();\r\n","import {TrackItem} from \"../types\";\nimport {Glue42Office} from \"../../../glue4office\";\n\nexport class TrackEmailDictionary implements TrackItem {\n    private items: { [key: string]: Glue42Office.Outlook.T42Id[] } = {};\n\n    public containsIds(ids: Glue42Office.Outlook.T42Id[]): boolean {\n        const key = this.getOutlookId(ids);\n        return this.items.hasOwnProperty(key);\n    }\n\n    public add(emailIds: Glue42Office.Outlook.T42Id[], ids: Glue42Office.Outlook.T42Id[]): void {\n        const key = this.getOutlookId(emailIds);\n        this.items[key] = ids;\n    }\n\n    public remove(ids: Glue42Office.Outlook.T42Id[]): void {\n        const key = this.getOutlookId(ids);\n        delete this.items[key];\n    }\n\n    public get(ids: Glue42Office.Outlook.T42Id[]): Glue42Office.Outlook.T42Id[] {\n        const key = this.getOutlookId(ids);\n        return this.items[key];\n    }\n\n    private getOutlookId(ids: Glue42Office.Outlook.T42Id[]): string {\n        return ids.filter((id) => id.systemName.indexOf(\"Outlook\") === 0)[0].nativeId;\n    }\n}\n\nexport default new TrackEmailDictionary();\n","import {TrackItem} from \"../types\";\nimport {Glue42Office} from \"../../../glue4office\";\n\nexport class TrackItemDictionary implements TrackItem {\n    private items: { [key: string]: Glue42Office.Outlook.T42Id[] } = {};\n\n    public containsIds(ids: Glue42Office.Outlook.T42Id[]): boolean {\n        const key = this.getOutlookId(ids);\n        return this.items.hasOwnProperty(key);\n    }\n\n    public add(emailIds: Glue42Office.Outlook.T42Id[], ids: Glue42Office.Outlook.T42Id[]): void {\n        const key = this.getOutlookId(emailIds);\n        this.items[key] = ids;\n    }\n\n    public remove(ids: Glue42Office.Outlook.T42Id[]): void {\n        const key = this.getOutlookId(ids);\n        delete this.items[key];\n    }\n\n    public get(ids: Glue42Office.Outlook.T42Id[]): Glue42Office.Outlook.T42Id[] {\n        const key = this.getOutlookId(ids);\n        return this.items[key];\n    }\n\n    private getOutlookId(ids: Glue42Office.Outlook.T42Id[]): string {\n        return ids.filter((id) => id.systemName.indexOf(\"Outlook\") === 0)[0].nativeId;\n    }\n}\n\nexport default new TrackItemDictionary();\n","import {Glue42Core} from \"@glue42/core\";\nimport {Glue42Office} from \"../../../glue4office\";\nimport {validateAttachments, validateDate, validateNewItemOptions, validatePriority} from \"./validations\";\nimport {ChunkFileParams, CreateItemObject} from \"../types\";\nimport {\n    CreateItemMethodName,\n    OnCancelMethodName,\n    OnSendMethodName,\n    ShowItemMethodName,\n    TmpFilesAppendMethodName,\n} from \"./methodNames\";\nimport {attachmentsErrorMessage, convertToT42Email, convertToT42Task} from \"./index\";\nimport createItemDictionary from \"../dictionaries/CreateItemDictionary\";\n\nconst chunkSize: number = 800000;\n\n// TODO add action for test purposes\n// export const createItem = (agm: Glue42Core.AGM.API,\n//                            item: EmailParams | TaskParams,\n//                            itemType: string,\n//                            options?: NewEmailOptions | NewTaskOptions,\n//                            action?: number) => {\nexport const createItem = (agm: Glue42Core.AGM.API,\n                           item: Glue42Office.Outlook.EmailParams | Glue42Office.Outlook.TaskParams,\n                           itemType: string,\n                           options?: Glue42Office.Outlook.NewEmailOptions | Glue42Office.Outlook.NewTaskOptions) => {\n    const isT42Email: boolean = itemType === \"email\";\n    const isT42Task: boolean = itemType === \"task\";\n    options = options ? options : {};\n    const {onCanceled} = options;\n\n    return new Promise((resolve, reject) => {\n        const validItem = validateAndParseCreateItemParams(item);\n        validateNewItemOptions(options);\n\n        const internalCookie: string = new Date().getTime().toString();\n        const createItemObject: CreateItemObject = {\n            ItemType: itemType,\n            Cookie: internalCookie,\n            OnSendMethod: OnSendMethodName,\n            OnCancelMethod: OnCancelMethodName,\n        };\n\n        if (isT42Email) {\n            createItemObject.t42value = convertToT42Email(validItem as Glue42Office.Outlook.EmailParams);\n        } else if (isT42Task) {\n            createItemObject.t42value = convertToT42Task(validItem as Glue42Office.Outlook.TaskParams);\n        }\n\n        const successHandler = () => {\n            const onSent: (item: Glue42Office.Outlook.T42Email | Glue42Office.Outlook.T42Task) => any = isT42Email\n                ? (options as Glue42Office.Outlook.NewEmailOptions).onSent\n                : (options as Glue42Office.Outlook.NewTaskOptions).onSaved;\n            createItemDictionary.add(internalCookie, {onSent, onCanceled});\n            resolve();\n        };\n\n        const errorHandler = (err: any) => {\n            reject(err.message);\n            return;\n        };\n\n        // TODO add action for test purposes\n        // const showItem = (r: { returned: { ItemID: object, displaySettings?: { action: number } } }) => {\n        const showItem = (r: { returned: { ItemID: object } }) => {\n            const showItemObject = r.returned;\n            // if (action) {\n            //     r.returned.displaySettings = {action};\n            // }\n            agm.invoke(ShowItemMethodName, showItemObject)\n                .then(successHandler)\n                .catch(errorHandler);\n        };\n\n        const {attachments} = validItem;\n        if (attachments && attachments.length > 0) {\n            if (isT42Email) {\n                createItemObject.t42value.attachments = [];\n            } else {\n                createItemObject.AttachFiles = [];\n            }\n\n            const att = attachments[0] as Glue42Office.Outlook.AttachmentParams;\n            const createNewFile = typeof att.data === \"string\";\n            if (createNewFile) {\n                Promise.all((attachments as Glue42Office.Outlook.AttachmentParams[])\n                    .map(async (file: Glue42Office.Outlook.AttachmentParams) => {\n                        file.truncate = true;\n                        file.encoding = \"base64\";\n                        // chunk by 1 MB\n                        if (new Blob([file.data]).size > 1000000) {\n                            return chunkAndAppendAttachment(agm, file, file.data, isT42Email, createItemObject);\n                        } else {\n                            return agm.invoke(TmpFilesAppendMethodName, file)\n                                .then((returnedFile: { returned: { Filename: string } }) => {\n                                    const fileName: string = returnedFile.returned.Filename;\n                                    if (isT42Email) {\n                                        (createItemObject.t42value.attachments as Glue42Office.Outlook.T42Attachment[])\n                                            .push({name: fileName});\n                                    } else {\n                                        (createItemObject.AttachFiles as string[]).push(fileName as string);\n                                    }\n                                })\n                                .catch((err) => window.console.warn(\"Not able to create attachment file\"));\n                        }\n                    }))\n                    .then(() => {\n                        agm.invoke(CreateItemMethodName, createItemObject)\n                            .then(showItem)\n                            .catch((err) => reject(err.message));\n                    })\n                    .catch((err) => reject(err.message));\n            } else if (typeof attachments[0] === \"string\") {\n                // Attach existing file(s)\n                (attachments as string[]).map((file: string) => {\n                    return isT42Email\n                        ? (createItemObject.t42value.attachments as Glue42Office.Outlook.T42Attachment[])\n                            .push({name: file as string})\n                        : (createItemObject.AttachFiles as string[]).push(file as string);\n                });\n                agm.invoke(CreateItemMethodName, createItemObject)\n                    .then(showItem)\n                    .catch((err) => reject(err.message));\n            } else {\n                reject(attachmentsErrorMessage);\n            }\n        } else {\n            agm.invoke(CreateItemMethodName, createItemObject)\n                .then(showItem)\n                .catch((err) => reject(err.message));\n        }\n    });\n};\n\nconst validateAndParseCreateItemParams = (params: Glue42Office.Outlook.EmailParams | Glue42Office.Outlook.TaskParams) => {\n    const validParams: Glue42Office.Outlook.EmailParams | Glue42Office.Outlook.TaskParams = parseCreateItemParams(params);\n    if (validParams.attachments) {\n        validParams.attachments = validateAttachments(params.attachments);\n    }\n    if ((validParams as Glue42Office.Outlook.TaskParams).startDate) {\n        validParams.startDate = validateDate((validParams as Glue42Office.Outlook.TaskParams).startDate, \"startDate\");\n    }\n    if ((validParams as Glue42Office.Outlook.TaskParams).dueDate) {\n        validParams.dueDate = validateDate((validParams as Glue42Office.Outlook.TaskParams).dueDate, \"dueDate\");\n    }\n    if ((validParams as Glue42Office.Outlook.TaskParams).reminderTime) {\n        validParams.reminderTime = validateDate((validParams as Glue42Office.Outlook.TaskParams).reminderTime, \"reminderTime\");\n    }\n    if ((validParams as Glue42Office.Outlook.TaskParams).priority) {\n        validParams.priority = validatePriority((validParams as Glue42Office.Outlook.TaskParams).priority);\n    }\n    return validParams;\n};\n\nconst parseCreateItemParams = (params: Glue42Office.Outlook.EmailParams | Glue42Office.Outlook.TaskParams) => {\n    const newParams: Glue42Office.Outlook.EmailParams | Glue42Office.Outlook.TaskParams = Object.keys(params)\n        .reduce((prev: Glue42Office.Outlook.EmailParams | Glue42Office.Outlook.TaskParams, curr: string) => {\n            prev[curr] = params[curr];\n            return prev;\n        }, {});\n\n    if (newParams.subject) {\n        newParams.subject = newParams.subject.toString();\n    }\n    if (newParams.body) {\n        newParams.body = newParams.body.toString();\n    }\n    if ((newParams as Glue42Office.Outlook.EmailParams).bodyHtml) {\n        (newParams as Glue42Office.Outlook.EmailParams).bodyHtml = (newParams as Glue42Office.Outlook.EmailParams)\n            .bodyHtml.toString();\n    }\n    if ((newParams as Glue42Office.Outlook.TaskParams).sender) {\n        (newParams as Glue42Office.Outlook.TaskParams).sender.toString();\n    }\n    return newParams;\n};\n\nconst chunkAndAppendAttachment = (agm: Glue42Core.AGM.API,\n                                  file: Glue42Office.Outlook.AttachmentParams,\n                                  data: string,\n                                  isT42Email: boolean,\n                                  createItemObject: CreateItemObject): Promise<any> => {\n    return new Promise((resolve: () => void) => {\n        const {chunkFile, chunkData} = updateChunkFile(file, data);\n        invokeFileAppend(agm, chunkFile, chunkData, resolve, isT42Email, createItemObject);\n    });\n};\n\nconst invokeFileAppend = (agm: Glue42Core.AGM.API,\n                          file: Glue42Office.Outlook.AttachmentParams,\n                          data: string,\n                          resolve: () => void,\n                          isT42Email: boolean,\n                          createItemObject: CreateItemObject): void => {\n    agm.invoke(TmpFilesAppendMethodName, file)\n        .then((returnedFile: any) => {\n            if (data.length > 0) {\n                file.truncate = false;\n                const {chunkFile, chunkData} = updateChunkFile(file, data);\n                return invokeFileAppend(agm, chunkFile, chunkData, resolve, isT42Email, createItemObject);\n            } else {\n                const fileName: string = returnedFile.returned.Filename;\n                if (isT42Email) {\n                    (createItemObject.t42value.attachments as Glue42Office.Outlook.T42Attachment[])\n                        .push({name: fileName});\n                } else {\n                    (createItemObject.AttachFiles as string[]).push(fileName as string);\n                }\n                resolve();\n            }\n        })\n        .catch(() => {\n            window.console.warn(\"Not able to create attachment file\");\n        });\n};\n\nconst updateChunkFile = (file: Glue42Office.Outlook.AttachmentParams, data: string): ChunkFileParams => {\n    file.data = data.slice(0, chunkSize);\n    data = data.slice(chunkSize, data.length);\n    return {chunkFile: file, chunkData: data};\n};\n","import { Glue42Core } from \"@glue42/core\";\n\nimport {Glue42Office} from \"../../../glue4office\";\nimport {T42ValueEmail, T42ValueTask, TaskPriority} from \"../types\";\nimport {CreateItemMethodName} from \"./methodNames\";\nimport {validateRecipients} from \"./validations\";\n\nexport const attachmentsErrorMessage = `Invalid type of \"attachments\" element, expected array of strings for ` +\n    `existing attachments or array of \"{data: string, fileName: string}\" for dynamically created attachments`;\n\nexport const isOutlookEnabled = (agm: Glue42Core.AGM.API) => agm.methods({name: CreateItemMethodName}).length > 0;\n\nexport const getOlDefaultFolders = () => {\n    return {\n        $SentMail: 5,\n        $Inbox: 6,\n    };\n};\n\nexport const concatChunkData = (data: string[]) => {\n    let result = \"\";\n    data.forEach((chunk: string) => {\n        result += encodeData(chunk);\n    });\n    return result;\n};\n\nexport const encodeData = (data: string) => atob(data);\n\nexport const decodeData = (data: string) => btoa(data);\n\nexport const generateConversationId = () => {\n    return {\n        systemName: Math.random().toString(36).substr(2, 10),\n        nativeId: new Date().getTime().toString(),\n    };\n};\n\nexport const convertToT42Email = (email: Glue42Office.Outlook.EmailParams): T42ValueEmail => {\n    const t42ValueEmail: T42ValueEmail = {\n        attachments: email.attachments || [],\n        body: email.body,\n        bodyHtml: email.bodyHtml,\n        subject: email.subject,\n    };\n\n    const newEmail: Glue42Office.Outlook.EmailParams = validateRecipients(email);\n    [\"to\", \"cc\", \"bcc\"].forEach((contactListName: string) => {\n        const receiver = newEmail[contactListName];\n        if (receiver) {\n            const newList: object[] = [];\n\n            receiver.forEach((contactEmail: string) => {\n                newList.push({emails: [contactEmail]});\n            });\n            t42ValueEmail[contactListName] = newList;\n        }\n\n        if (newEmail.sender) {\n            t42ValueEmail.sender = {emails: [newEmail.sender]};\n        }\n    });\n    return t42ValueEmail;\n};\n\nexport const convertToT42Task = (task: Glue42Office.Outlook.TaskParams): T42ValueTask => {\n    return {\n        attachments: task.attachments || [],\n        body: task.body,\n        dueDate: task.dueDate,\n        importance: getTaskImportance(task.priority),\n        reminderTime: task.reminderTime,\n        startDate: task.startDate,\n        subject: task.subject,\n    };\n};\n\nconst getTaskImportance = (priority: \"low\" | \"normal\" | \"high\") => {\n    return typeof TaskPriority[priority] === \"number\" ? TaskPriority[priority] : TaskPriority.normal;\n};\n\nexport const getTaskPriority = (importance: number) => {\n    if (TaskPriority.low === importance) {\n        return \"low\";\n    } else if (TaskPriority.high === importance) {\n        return \"high\";\n    }\n\n    return \"normal\";\n};\n","export const CreateItemMethodName: string              = \"T42.Outlook.CreateItem\";\r\nexport const ShowItemMethodName: string                = \"T42.Outlook.ShowItem\";\r\nexport const SaveItemMethodName: string                = \"T42.Outlook.SaveItem\";\r\nexport const OnSendMethodName: string                  = \"T42.Outlook.OnSendMethod\";\r\nexport const OnCancelMethodName: string                = \"T42.Outlook.OnCancelMethod\";\r\nexport const OnEmailReceivedMethodName: string         = \"T42.Outlook.OnEmailReceived\";\r\nexport const OnTaskCreatedMethodName: string           = \"T42.Outlook.OnTaskCreated\";\r\nexport const OutlookGetAttachmentMethodName: string    = \"T42.Outlook.GetAttachment\";\r\nexport const CreateLocalEmailMethodName: string        = \"T42.Outlook.CreateLocalEmail\";\r\nexport const OutlookGetItemAsMsgMethodName: string     = \"T42.Outlook.GetItemAsMsgMethod\";\r\nexport const TmpFilesAppendMethodName: string          = \"T42.TmpFiles.Append\";\r\nexport const OnTrackEmailMethodName: string            = \"T42.CRM.TrackEmail\";\r\nexport const OnUntrackEmailMethodName: string          = \"T42.CRM.UntrackEmail\";\r\nexport const OnTrackItemMethodName: string             = \"T42.CRM.TrackCalendarItem\";\r\nexport const OnUntrackItemMethodName: string           = \"T42.CRM.UntrackCalendarItem\";\r\nexport const CRMGetAttachmentMethodName: string        = \"T42.CRM.GetAttachment\";\r\nexport const CRMGetItemAsMsgMethodName: string         = \"T42.CRM.GetItemAsMsg\";\r\nexport const SyncTrackEmailMethodName: string          = \"T42.CRM.SyncTrackEmail\";\r\nexport const SyncUntrackEmailMethodName: string        = \"T42.CRM.SyncUntrackEmail\";\r\nexport const SyncTrackCalendarItemMethodName: string   = \"T42.CRM.SyncTrackCalendarItem\";\r\nexport const SyncUntrackCalendarItemMethodName: string = \"T42.CRM.SyncUntrackCalendarItem\";\r\nexport const SecureReplyMethodName: string             = \"T42.CRM.SecureReply\";\r\nexport const DisplaySecureMailMethodName: string       = \"T42.CRM.DisplaySecureMail\";\r\n","import { Glue42Core } from \"@glue42/core\";\n\nimport {\n    Glue42Office,\n} from \"../../../glue4office\";\nimport {attachmentsErrorMessage, getOlDefaultFolders, isOutlookEnabled} from \"./index\";\n\nimport {OlDefaultFolders} from \"../types\";\n\nexport const validateRecipients = (email: Glue42Office.Outlook.EmailParams | Glue42Office.Outlook.LocalEmailParams) => {\n    const recipientProps = [\"to\", \"cc\", \"bcc\"];\n    return Object.keys(email).reduce((prev: Glue42Office.Outlook.EmailParams, curr: string) => {\n        if (recipientProps.indexOf(curr) >= 0) {\n            const receiver = email[curr];\n            if (!Array.isArray(receiver)) {\n                prev[curr] = [receiver.toString()];\n                return prev;\n            } else {\n                prev[curr] = [];\n                receiver.forEach((contactEmail: string) => {\n                    prev[curr].push(contactEmail.toString());\n                });\n            }\n        }\n\n        prev[curr] = email[curr];\n        return prev;\n    }, {});\n};\n\nexport const validateAttachments = (attachments: Glue42Office.Outlook.AttachmentParams[] | string[]) => {\n    if (!Array.isArray(attachments)) {\n        throw new Error(attachmentsErrorMessage);\n    }\n    if (attachments.length === 0) {\n        return attachments;\n    }\n\n    let isValid = true;\n    const firstAtt = (attachments as Glue42Office.Outlook.AttachmentParams[])[0];\n    if (firstAtt.data !== undefined || firstAtt.fileName !== undefined) {\n        (attachments as Glue42Office.Outlook.AttachmentParams[]).forEach((att: Glue42Office.Outlook.AttachmentParams) => {\n            if (typeof att.data !== \"string\" || typeof att.fileName !== \"string\") {\n                window.console.warn(attachmentsErrorMessage);\n                isValid = false;\n            }\n        });\n    } else {\n        (attachments as string[]).forEach((att: string) => {\n            if (typeof att !== \"string\") {\n                window.console.warn(attachmentsErrorMessage);\n                isValid = false;\n            }\n        });\n    }\n    return isValid ? attachments : null;\n};\n\nexport const validateDate = (date: Date | string | number, propertyName: string) => {\n    const newDate = new Date(date as number);\n    const dateUnix = newDate.getTime();\n    if (isNaN(dateUnix)) {\n        window.console.warn(`Invalid type of \"${propertyName}\", expected \"Date\" or unix timestamp number`);\n        return null;\n    }\n    return date;\n};\n\nexport const validatePriority = (priority: string) => {\n    const listOfPriorities = [\"low\", \"normal\", \"high\"];\n    if (typeof priority !== \"string\") {\n        window.console.warn(`Invalid type of \"priority\", expected \"string\", one of: \"low\", \"normal\" or \"high\"`);\n        return \"normal\";\n    }\n    if (listOfPriorities.indexOf(priority) < 0) {\n        throw new Error(`Invalid type of \"priority\", expected \"string\", one of: \"low\", \"normal\" or \"high\"`);\n    }\n    return priority;\n};\n\nexport const validateNewItemOptions = (options: Glue42Office.Outlook.NewEmailOptions | Glue42Office.Outlook.NewTaskOptions) => {\n    if ((options as Glue42Office.Outlook.NewEmailOptions).onSent && typeof (options as Glue42Office.Outlook.NewEmailOptions).onSent !== \"function\") {\n        throw new Error(`Invalid type of \"onSent\" callback, expected function`);\n    }\n    if ((options as Glue42Office.Outlook.NewTaskOptions).onSaved && typeof (options as Glue42Office.Outlook.NewTaskOptions).onSaved !== \"function\") {\n        throw new Error(`Invalid type of \"onSaved\" callback, expected function`);\n    }\n    if (options.onCanceled && typeof options.onCanceled !== \"function\") {\n        throw new Error(`Invalid type of \"onCanceled\" callback, expected function`);\n    }\n};\n\nexport const validateLocalEmailParameters = (agm: Glue42Core.AGM.API, localEmailParams: Glue42Office.Outlook.LocalEmailParams) => {\n    if (!isOutlookEnabled(agm)) {\n        throw new Error(`The method \"createLocalEmail\" is not available`);\n    }\n    if (!localEmailParams) {\n        throw new Error(`\"localEmailParams\" of type object are mandatory`);\n    }\n    if (!localEmailParams.sender) {\n        throw new Error(`The property \"sender\" in \"localEmailParams\" is mandatory`);\n    } else if (typeof localEmailParams.sender !== \"string\") {\n        throw new Error(`Invalid type of \"sender\", expected string`);\n    }\n    if (!localEmailParams.to) {\n        throw new Error(`The property \"to\" in \"localEmailParams\" is mandatory`);\n    } else if (typeof localEmailParams.to !== \"string\" && !Array.isArray(localEmailParams.to)) {\n        throw new Error(`Invalid type of \"to\", expected string or string[]`);\n    }\n    if (!localEmailParams.subject) {\n        throw new Error(`The property \"subject\" in \"localEmailParams\" is mandatory`);\n    } else if (typeof localEmailParams.subject !== \"string\") {\n        throw new Error(`Invalid type of \"subject\", expected string`);\n    }\n};\n\nexport const validateLocation = (location: Glue42Office.Outlook.Email | Glue42Office.Outlook.CommonOutlookFolder | string) => {\n    if (typeof location !== \"string\" && !(location as Glue42Office.Outlook.Email).ids) {\n        throw new Error(\"Invalid location\");\n    }\n    if (typeof location === \"string\" && location.indexOf(\"$\") === 0) {\n        const defaultFolders: OlDefaultFolders = getOlDefaultFolders();\n        if (typeof defaultFolders[location] !== \"number\") {\n            throw new Error(\"Invalid location\");\n        }\n    }\n};\n\nexport const validateCalendarEventParameters = (\n    agm: Glue42Core.AGM.API,\n    action: string,\n    event: Glue42Office.Outlook.T42Appointment | Glue42Office.Outlook.T42Meeting) => {\n    if (!isOutlookEnabled(agm)) {\n        const methodName = action === \"track\" ? \"trackEmail\" : \"untrackEmail\";\n        throw new Error(`The method ${methodName} is not available`);\n    }\n    if (!event || (!event.ids || event.ids.length === 0)) {\n        throw new Error(\"Invalid meeting / appointment\");\n    }\n};\n\nexport const validateId = (id: Glue42Office.Outlook.T42Id): Glue42Office.Outlook.T42Id => {\n    if (!id.systemName || !id.nativeId) {\n        throw new Error(`Invalid type of conversationId, expected \"{systemName: string, nativeId: string\"`);\n    }\n\n    const systemName = id.systemName.toString();\n    const nativeId = id.nativeId.toString();\n    return {systemName, nativeId};\n};\n","import { Glue42Core } from \"@glue42/core\";\n\nimport {Glue42Office} from \"../../../glue4office\";\nimport {getAttachment} from \"../methods/getAttachment\";\n\nexport class AttachmentImpl implements Glue42Office.Outlook.Attachment {\n    public cookie: string;\n    public emailIds: Glue42Office.Outlook.T42Id[];\n    public data: string;\n    public ids: Glue42Office.Outlook.T42Id[];\n    public name: string;\n    public sizeHint: number;\n    public errorMessage: string;\n    public more: boolean;\n    public success: boolean;\n    public parent: Glue42Office.Outlook.Email | Glue42Office.Outlook.Task;\n    private agm: Glue42Core.AGM.API;\n\n    constructor(attachment: Glue42Office.Outlook.T42Attachment, agm: Glue42Core.AGM.API, parent?: Glue42Office.Outlook.Email | Glue42Office.Outlook.Task) {\n        this.cookie = attachment.cookie;\n        this.emailIds = attachment.emailIds;\n        this.data = attachment.data;\n        this.ids = attachment.ids;\n        this.name = attachment.name;\n        this.sizeHint = attachment.sizeHint;\n        this.errorMessage = attachment.errorMessage;\n        this.more = attachment.more;\n        this.success = attachment.success;\n        this.agm = agm;\n\n        if (parent) {\n            this.parent = parent;\n        }\n    }\n\n    public getData(callback?: (percent: number) => number): Promise<string> {\n        return getAttachment(this.agm, this.emailIds, this.ids, callback);\n    }\n}\n","import { Glue42Core } from \"@glue42/core\";\n\nimport manager from \"./Manager\";\nimport {Glue42Office} from \"../../../glue4office\";\nimport {AttachmentImpl} from \"./AttachmentImplementation\";\n\nexport class EmailImpl implements Glue42Office.Outlook.Email {\n    public attachments: Glue42Office.Outlook.Attachment[];\n    public bcc: Glue42Office.Outlook.T42Contact | Glue42Office.Outlook.T42Contact[];\n    public body: string;\n    public bodyHtml: string;\n    public cc: Glue42Office.Outlook.T42Contact | Glue42Office.Outlook.T42Contact[];\n    public date: Date;\n    public ids: Glue42Office.Outlook.T42Id[];\n    public sender: Glue42Office.Outlook.T42Contact;\n    public subject: string;\n    public to: Glue42Office.Outlook.T42Contact | Glue42Office.Outlook.T42Contact[];\n    public entityType: number;\n\n    constructor(email: Glue42Office.Outlook.T42Email, agm: Glue42Core.AGM.API) {\n        if (email.attachments && email.attachments.length > 0) {\n            this.attachments = [];\n            email.attachments.forEach((att: Glue42Office.Outlook.T42Attachment) => {\n                this.attachments.push(new AttachmentImpl(att, agm, this));\n            });\n        }\n        this.bcc = email.bcc;\n        this.body = email.body;\n        this.bodyHtml = email.bodyHtml;\n        this.cc = email.cc;\n        this.date = email.date;\n        this.ids = email.ids;\n        this.sender = email.sender;\n        this.subject = email.subject;\n        this.to = email.to;\n        this.entityType = email.entityType;\n    }\n\n    public show(): Promise<Glue42Office.Outlook.T42Id[]> {\n        return manager.showItemMethod(this.ids, \"showEmail\");\n    }\n\n    public saveToFile(): Promise<string> {\n        return manager.saveItemMethod(this.ids, \"saveEmail\");\n    }\n\n    public getAsMsg(): Promise<string> {\n        return manager.getItemAsMsg(this.ids);\n    }\n\n    public track(conversationId?: Glue42Office.Outlook.T42Id): Promise<{ emailIds: Glue42Office.Outlook.T42Id[], conversationIds: Glue42Office.Outlook.T42Id[] }> {\n        return manager.handleTrackingEmails(\"track\", this.ids, conversationId);\n    }\n\n    public untrack(): Promise<{ emailIds: Glue42Office.Outlook.T42Id[], conversationIds: Glue42Office.Outlook.T42Id[] }> {\n        return manager.handleTrackingEmails(\"untrack\", this.ids);\n    }\n}\n","import { Glue42Core } from \"@glue42/core\";\n\nimport {Glue42Office} from \"../../../glue4office\";\nimport {generateConversationId, isOutlookEnabled} from \"../helpers/index\";\nimport {\n    CRMGetItemAsMsgMethodName,\n    OutlookGetItemAsMsgMethodName,\n    SaveItemMethodName,\n    ShowItemMethodName,\n    SyncTrackEmailMethodName,\n    SyncUntrackEmailMethodName,\n} from \"../helpers/methodNames\";\nimport {validateId} from \"../helpers/validations\";\nimport getItemAsMsgDictionary from \"../dictionaries/GetItemAsMsgDictionary\";\nimport trackEmailDictionary from \"../dictionaries/TrackEmailDictionary\";\n\nexport class Manager {\n    private agm: Glue42Core.AGM.API;\n\n    public init(agm: Glue42Core.AGM.API): void {\n        this.agm = agm;\n    }\n\n    public showItemMethod(ids: Glue42Office.Outlook.T42Id[], methodName: string): Promise<Glue42Office.Outlook.T42Id[]> {\n        return new Promise((resolve, reject) => {\n            if (!isOutlookEnabled(this.agm)) {\n                reject(`The method \"${methodName}\" is not available`);\n                return;\n            }\n\n            ids = this.validateIds(ids);\n\n            const successHandler = () => {\n                resolve(ids);\n            };\n\n            const errorHandler = (err: { message: string }) => {\n                reject(err.message);\n                return;\n            };\n\n            this.agm.invoke(ShowItemMethodName, {itemT42Ids: ids})\n                .then(() => successHandler())\n                .catch((err: any) => errorHandler(err));\n        });\n    }\n\n    public saveItemMethod(ids: Glue42Office.Outlook.T42Id[], methodName: string): Promise<string> {\n        return new Promise((resolve, reject) => {\n            if (!isOutlookEnabled(this.agm)) {\n                reject(`The method \"${methodName}\" is not available`);\n                return;\n            }\n\n            const successHandler = (r: { returned: any }) => {\n                resolve(r.returned.url);\n            };\n\n            const errorHandler = (err: { message: string }) => {\n                reject(err.message);\n                return;\n            };\n\n            this.agm.invoke(SaveItemMethodName, {itemT42Ids: ids})\n                .then((r: { returned: any }) => successHandler(r))\n                .catch((err: any) => errorHandler(err));\n        });\n    }\n\n    public getItemAsMsg(ids: Glue42Office.Outlook.T42Id[]): Promise<string> {\n        return new Promise((resolve, reject) => {\n            if (!isOutlookEnabled(this.agm)) {\n                reject(`The method \"getAsMsg\" is not available`);\n                return;\n            }\n\n            const cookie: string = new Date().getTime().toString();\n\n            const successHandler = () => {\n                getItemAsMsgDictionary.add(cookie, {resolve, reject});\n            };\n\n            const errorHandler = (err: { message: string }) => {\n                reject(err.message);\n                return;\n            };\n\n            const getItemOptions = {\n                itemIds: ids,\n                callback: OutlookGetItemAsMsgMethodName,\n                cookie,\n            };\n\n            this.agm.invoke(CRMGetItemAsMsgMethodName, getItemOptions)\n                .then(() => successHandler())\n                .catch((err: any) => errorHandler(err));\n        });\n    }\n\n    public handleTrackingEmails(action: string,\n                                emailIds: Glue42Office.Outlook.T42Id[],\n                                conversationId?: Glue42Office.Outlook.T42Id): Promise<{ emailIds: Glue42Office.Outlook.T42Id[], conversationIds: Glue42Office.Outlook.T42Id[] }> {\n        return new Promise((resolve, reject) => {\n            if (!isOutlookEnabled(this.agm)) {\n                reject(`The method \"${action}\" is not available`);\n                return;\n            }\n\n            const id = conversationId ? validateId(conversationId) : null;\n            const isTrackEmail: boolean = action === \"track\";\n            const conversationIds = this.combineConversationIds(emailIds, id, isTrackEmail);\n\n            const successHandler = () => {\n                resolve({emailIds, conversationIds});\n\n                if (!isTrackEmail) {\n                    trackEmailDictionary.remove(emailIds);\n                    const untrackIds = emailIds.filter((ids: Glue42Office.Outlook.T42Id) => ids.systemName === (\"Outlook.ConversationId\"));\n                    trackEmailDictionary.add(emailIds, untrackIds);\n                }\n            };\n\n            const errorHandler = (err: { message: string }) => {\n                reject(err.message);\n                return;\n            };\n\n            const methodName = isTrackEmail ? SyncTrackEmailMethodName : SyncUntrackEmailMethodName;\n            const params = {emailIds, conversationIds};\n            return this.agm.invoke(methodName, params)\n                .then(successHandler)\n                .catch(errorHandler);\n        });\n    }\n\n    private validateIds(ids: Glue42Office.Outlook.T42Id[]): Glue42Office.Outlook.T42Id[] {\n        if (!ids) {\n            throw new Error(`\"ids\" are mandatory`);\n        }\n        if (!Array.isArray(ids) || ids.length === 0) {\n            throw new Error(\"Invalid type of ids\");\n        }\n        return ids.map((id: Glue42Office.Outlook.T42Id) => validateId(id));\n    }\n\n    private combineConversationIds(ids: Glue42Office.Outlook.T42Id[], conversationId: Glue42Office.Outlook.T42Id, isTrackEmail: boolean) {\n        const conversationIds = trackEmailDictionary.containsIds(ids) ? trackEmailDictionary.get(ids) : [];\n\n        if (isTrackEmail) {\n            const newConversationIds = conversationId ? conversationId : generateConversationId();\n            conversationIds.push(newConversationIds);\n\n            if (!trackEmailDictionary.containsIds(ids)) {\n                trackEmailDictionary.add(ids, conversationIds);\n            }\n        }\n        return conversationIds;\n    }\n}\n\nexport default new Manager();\n","import { Glue42Core } from \"@glue42/core\";\n\nimport manager from \"./Manager\";\nimport {Glue42Office} from \"../../../glue4office\";\nimport {AttachmentImpl} from \"./AttachmentImplementation\";\nimport {getTaskPriority} from \"../helpers/index\";\n\nexport class TaskImpl implements Glue42Office.Outlook.Task {\n    public actualWork: number;\n    public attachments: Glue42Office.Outlook.Attachment[];\n    public body: string;\n    public creationTime: Date;\n    public dateCompleted: Date;\n    public dueDate: Date;\n    public ids: Glue42Office.Outlook.T42Id[];\n    public priority: string;\n    public reminderTime: Date;\n    public startDate: Date;\n    public subject: string;\n    public entityType: number;\n\n    constructor(task: Glue42Office.Outlook.T42Task, agm: Glue42Core.AGM.API) {\n        if (task.attachments && task.attachments.length > 0) {\n            this.attachments = [];\n            task.attachments.forEach((att: Glue42Office.Outlook.T42Attachment) => {\n                this.attachments.push(new AttachmentImpl(att, agm, this));\n            });\n        }\n        this.actualWork = task.actualWork;\n        this.body = task.body;\n        this.creationTime = task.creationTime;\n        this.dateCompleted = task.dateCompleted;\n        this.dueDate = task.dueDate;\n        this.ids = task.ids;\n        this.priority = getTaskPriority(task.importance);\n        this.reminderTime = task.reminderTime;\n        this.startDate = task.startDate;\n        this.subject = task.subject;\n        this.entityType = task.entityType;\n    }\n\n    public show(): Promise<Glue42Office.Outlook.T42Id[]> {\n        return manager.showItemMethod(this.ids, \"showTask\");\n    }\n\n    public saveToFile(): Promise<string> {\n        return manager.saveItemMethod(this.ids, \"saveTask\");\n    }\n}\n","import { Glue42Core } from \"@glue42/core\";\n\nimport { default as CallbackRegistryFactory, CallbackRegistry } from \"callback-registry\";\n\nimport manager from \"./items/Manager\";\nimport { createEmail } from \"./methods/createEmail\";\nimport { createLocalEmailMethod } from \"./methods/createLocalEmail\";\nimport { createTask } from \"./methods/createTask\";\nimport { registerAgmMethods } from \"./registerAgmMethods\";\nimport { handleTrackingItems } from \"./methods/handleTrackingItems\";\nimport { itemFromJSON } from \"./methods/itemFromJSON\";\nimport {\n    Glue42Office,\n} from \"../../glue4office\";\nimport {\n    connected,\n    registerDisplaySecureEmail,\n    registerEventListeners,\n    registerOnAddinStatusChanged,\n    registerOnEmailReceived,\n    registerOnTaskCreated,\n    registerSecureReply,\n    registerTrackEmail,\n    registerTrackItem,\n    registerUntrackEmail,\n    registerUntrackItem,\n} from \"./registerEventListeners\";\nimport {\n    OnAddinStatusChangedCallback,\n    OnDisplaySecureEmailCallback,\n    OnEmailReceivedCallback,\n    OnSecureReplyCallback,\n    OnTaskCreatedCallback,\n    TrackCalendarEventCallback,\n    TrackEmailCallback,\n    UntrackCalendarEventCallback,\n    UntrackEmailCallback,\n    Config,\n} from \"./types\";\n\nexport default function(config: Config) {\n    let outlook: Glue42Office.Outlook.API;\n    if (!config.agm) {\n        throw Error(\"config.agm is required\");\n    }\n\n    const callbacks: CallbackRegistry = CallbackRegistryFactory();\n    const agm: Glue42Core.AGM.API = config.agm;\n    manager.init(agm);\n\n    registerAgmMethods(agm, callbacks);\n    registerEventListeners(agm, callbacks);\n\n    const onAddinStatusChanged = (callback: OnAddinStatusChangedCallback): () => void => {\n        return registerOnAddinStatusChanged(agm, callback, callbacks);\n    };\n\n    const onEmailReceived = (callback: OnEmailReceivedCallback) => {\n        return registerOnEmailReceived(agm, callback, callbacks);\n    };\n    const onTaskCreated = (callback: OnTaskCreatedCallback) => {\n        return registerOnTaskCreated(agm, callback, callbacks);\n    };\n\n    const onTrackEmail = (callback: TrackEmailCallback) => {\n        return registerTrackEmail(agm, callback, callbacks);\n    };\n    const onUntrackEmail = (callback: UntrackEmailCallback) => {\n        return registerUntrackEmail(agm, callback, callbacks);\n    };\n\n    const onTrackCalendarEvent = (callback: TrackCalendarEventCallback) => {\n        return registerTrackItem(agm, callback, callbacks);\n    };\n    const onUntrackCalendarEvent = (callback: UntrackCalendarEventCallback) => {\n        return registerUntrackItem(agm, callback, callbacks);\n    };\n\n    const onSecureReply = (callback: OnSecureReplyCallback) => {\n        return registerSecureReply(agm, callback, callbacks);\n    };\n\n    const onDisplaySecureEmail = (callback: OnDisplaySecureEmailCallback) => {\n        return registerDisplaySecureEmail(agm, callback, callbacks);\n    };\n\n    const ready = (): Promise<Glue42Office.Outlook.API> => new Promise((resolve) => {\n        resolve(outlook);\n    });\n\n    // TODO add action for test purposes\n    // const newEmail = (emailParams: EmailParams = {}, options: NewEmailOptions, action?: number): Promise<void> =>\n    //     createEmail(agm, emailParams, options, action);\n    const newEmail = (emailParams: Glue42Office.Outlook.EmailParams = {}, options: Glue42Office.Outlook.NewEmailOptions): Promise<void> =>\n        createEmail(agm, emailParams, options);\n    const trackCalendarEvent = (event: Glue42Office.Outlook.T42Appointment | Glue42Office.Outlook.T42Meeting, conversationId?: Glue42Office.Outlook.T42Id):\n        Promise<{ event: Glue42Office.Outlook.T42Appointment | Glue42Office.Outlook.T42Meeting, conversationIds: Glue42Office.Outlook.T42Id[] }> =>\n        handleTrackingItems(agm, \"track\", event, conversationId);\n    const untrackCalendarEvent = (event: Glue42Office.Outlook.T42Appointment | Glue42Office.Outlook.T42Meeting): Promise<{ event: Glue42Office.Outlook.T42Appointment | Glue42Office.Outlook.T42Meeting }> =>\n        handleTrackingItems(agm, \"untrack\", event);\n    const createLocalEmail = (localEmailParams: Glue42Office.Outlook.LocalEmailParams): Promise<Glue42Office.Outlook.Email> =>\n        createLocalEmailMethod(agm, localEmailParams);\n    const newTask = (taskParams: Glue42Office.Outlook.TaskParams = {}, options: Glue42Office.Outlook.NewTaskOptions): Promise<void> =>\n        createTask(agm, taskParams, options);\n    const emailFromJSON = (email: Glue42Office.Outlook.T42Email): Glue42Office.Outlook.Email => itemFromJSON(email, agm, \"email\");\n    const taskFromJSON = (task: Glue42Office.Outlook.T42Task): Glue42Office.Outlook.Task => itemFromJSON(task, agm, \"task\");\n    const attachmentFromJSON = (attachment: Glue42Office.Outlook.T42Attachment): Glue42Office.Outlook.Attachment => itemFromJSON(attachment, agm, \"attachment\");\n    const showEmail = (ids: Glue42Office.Outlook.T42Id[]): Promise<Glue42Office.Outlook.T42Id[]> =>\n        manager.showItemMethod(ids, \"showEmail\");\n    const showTask = (ids: Glue42Office.Outlook.T42Id[]): Promise<Glue42Office.Outlook.T42Id[]> =>\n        manager.showItemMethod(ids, \"showTask\");\n\n    outlook = {\n        ready,\n        newEmail,\n        trackCalendarEvent,\n        untrackCalendarEvent,\n        createLocalEmail,\n        newTask,\n        emailFromJSON,\n        taskFromJSON,\n        attachmentFromJSON,\n        showEmail,\n        showTask,\n\n        onAddinStatusChanged,\n        onEmailReceived,\n        onTaskCreated,\n        onTrackEmail,\n        onUntrackEmail,\n        onTrackCalendarEvent,\n        onUntrackCalendarEvent,\n        onSecureReply,\n        onDisplaySecureEmail,\n        get addinStatus() {\n            return connected;\n        },\n    };\n\n    return outlook;\n}\n","import { Glue42Core } from \"@glue42/core\";\n\nimport {Glue42Office} from \"../../../glue4office\";\nimport {isOutlookEnabled} from \"../helpers\";\nimport {createItem} from \"../helpers/createItem\";\n\n// TODO add action for test purposes\n// export const createEmail = (\n//  agm: Glue42Core.AGM.API,\n//  email?: EmailParams,\n//  options?: NewEmailOptions,\n//  action?: number):\n// Promise<void> =>\nexport const createEmail = (\n    agm: Glue42Core.AGM.API,\n    email?: Glue42Office.Outlook.EmailParams,\n    options?: Glue42Office.Outlook.NewEmailOptions): Promise<void> =>\n    new Promise<void>((resolve, reject) => {\n        if (!isOutlookEnabled(agm)) {\n            reject(`The method \"newEmail\" is not available`);\n            return;\n        }\n\n        // TODO add action for test purposes\n        // return createItem(agm, email, \"email\", options, action)\n        return createItem(agm, email, \"email\", options)\n            .then(() => resolve())\n            .catch(reject);\n    });\n","import { Glue42Core } from \"@glue42/core\";\n\nimport { Glue42Office } from \"../../../glue4office\";\nimport { convertToT42Email, getOlDefaultFolders } from \"../helpers/index\";\nimport { CreateLocalEmailParams, OlDefaultFolders, T42ValueEmail } from \"../types\";\nimport { EmailImpl } from \"../items/EmailImplementation\";\nimport { CreateLocalEmailMethodName } from \"../helpers/methodNames\";\nimport { validateLocalEmailParameters, validateLocation } from \"../helpers/validations\";\n\nconst createLocalEmail = (ids: Glue42Office.Outlook.T42Id, emailParams: Glue42Office.Outlook.LocalEmailParams) => {\n    const localEmail: any = { ...convertToT42Email(emailParams), ids };\n    Object.keys(localEmail).forEach((key) => {\n        if (!localEmail[key]) {\n            delete localEmail[key];\n        }\n    });\n    return localEmail;\n};\n\nexport const createLocalEmailMethod = (agm: Glue42Core.AGM.API, localEmailParams: Glue42Office.Outlook.LocalEmailParams): Promise<Glue42Office.Outlook.Email> =>\n    new Promise((resolve, reject) => {\n        validateLocalEmailParameters(agm, localEmailParams);\n        const successHandler = (res: { returned: { localEmailIds: any } }, emailParams: Glue42Office.Outlook.LocalEmailParams) => {\n            const localEmail = new EmailImpl(createLocalEmail(res.returned.localEmailIds, emailParams), agm);\n            resolve(localEmail);\n        };\n\n        const errorHandler = (err: any) => {\n            reject(err.message);\n            return;\n        };\n\n        if (localEmailParams.location) {\n            validateLocation(localEmailParams.location);\n        }\n\n        return agm.invoke(CreateLocalEmailMethodName, getParams(localEmailParams))\n            .then((res) => successHandler(res, localEmailParams))\n            .catch((err) => errorHandler(err));\n    });\n\nconst getT42Email = (localEmailParams?: Glue42Office.Outlook.LocalEmailParams): Glue42Office.Outlook.EmailParams => {\n    return Object.keys(localEmailParams).reduce<Glue42Office.Outlook.EmailParams>((obj: Glue42Office.Outlook.EmailParams, key: string) => {\n        if (key === \"additionalProps\") {\n            return obj;\n        }\n        obj[key] = localEmailParams[key];\n        return obj;\n    }, {});\n};\n\nconst getLocation = (location: Glue42Office.Outlook.Email | Glue42Office.Outlook.CommonOutlookFolder | string) => {\n    const defaultFolders: OlDefaultFolders = getOlDefaultFolders();\n\n    if (!location) {\n        return { defaultFolderIndex: defaultFolders.$Inbox };\n    }\n\n    const emailIds = (location as Glue42Office.Outlook.Email).ids;\n    if (emailIds && emailIds[0].nativeId && emailIds[0].systemName) {\n        return { parentItemIds: emailIds };\n    }\n\n    if (typeof location === \"string\") {\n        if (location.indexOf(\"$\") < 0) {\n            return { folderPath: location };\n        }\n\n        if (typeof defaultFolders[location] === \"number\") {\n            return { defaultFolderIndex: defaultFolders[location] };\n        }\n    }\n\n    return { defaultFolderIndex: defaultFolders.$Inbox };\n};\n\nconst getParams = (localEmailParams?: Glue42Office.Outlook.LocalEmailParams) => {\n    const params: CreateLocalEmailParams = {\n        location: getLocation(localEmailParams.location),\n        email: convertToT42Email(getT42Email(localEmailParams)) as T42ValueEmail,\n    };\n\n    if (localEmailParams.additionalProps) {\n        params.additionalProps = localEmailParams.additionalProps;\n    }\n\n    return params;\n};\n","import { Glue42Core } from \"@glue42/core\";\n\nimport { Glue42Office} from \"../../../glue4office\";\nimport {isOutlookEnabled} from \"../helpers/index\";\nimport {createItem} from \"../helpers/createItem\";\n\nexport const createTask = (agm: Glue42Core.AGM.API, task?: Glue42Office.Outlook.TaskParams, options?: Glue42Office.Outlook.NewTaskOptions) =>\n    new Promise<void>((resolve, reject) => {\n        if (!isOutlookEnabled(agm)) {\n            reject(`The method \"newTask\" is not available`);\n            return;\n        }\n\n        createItem(agm, task, \"task\", options)\n            .then(() => resolve())\n            .catch(reject);\n    });\n","import { Glue42Core } from \"@glue42/core\";\n\nimport {Glue42Office} from \"../../../glue4office\";\nimport {isOutlookEnabled} from \"../helpers/index\";\nimport {CRMGetAttachmentMethodName, OutlookGetAttachmentMethodName} from \"../helpers/methodNames\";\nimport getAttachmentDictionary from \"../dictionaries/GetAttachmentDictionary\";\n\nexport const getAttachment = (agm: Glue42Core.AGM.API,\n                              emailIds: Glue42Office.Outlook.T42Id[],\n                              ids: Glue42Office.Outlook.T42Id[],\n                              callback?: (percent: number) => number): Promise<string> =>\n    new Promise((resolve, reject) => {\n        if (!isOutlookEnabled(agm)) {\n            reject(`The method \"getAttachments\" is not available`);\n            return;\n        }\n\n        const cookie: string = new Date().getTime().toString();\n\n        const successHandler = () => {\n            getAttachmentDictionary.add(cookie, {callback, resolve, reject});\n        };\n\n        const errorHandler = (err: { message: string }) => {\n            reject(err.message);\n            return;\n        };\n\n        const getAttachmentOptions = {\n            emailIds,\n            attachmentIds: ids,\n            callback: OutlookGetAttachmentMethodName,\n            cookie,\n        };\n\n        return agm.invoke(CRMGetAttachmentMethodName, getAttachmentOptions)\n            .then(() => successHandler())\n            .catch((err: any) => errorHandler(err));\n    });\n","import { Glue42Core } from \"@glue42/core\";\n\nimport {Glue42Office} from \"../../../glue4office\";\nimport {generateConversationId} from \"../helpers/index\";\nimport {SyncTrackCalendarItemMethodName, SyncUntrackCalendarItemMethodName} from \"../helpers/methodNames\";\nimport {validateCalendarEventParameters, validateId} from \"../helpers/validations\";\nimport trackItemDictionary from \"../dictionaries/TrackItemDictionary\";\n\nconst combineConversationIds = (event: Glue42Office.Outlook.T42Appointment | Glue42Office.Outlook.T42Meeting, conversationId: Glue42Office.Outlook.T42Id, isTrackEmail: boolean) => {\n    const conversationIds = trackItemDictionary.containsIds(event.ids) ? trackItemDictionary.get(event.ids) : [];\n\n    if (isTrackEmail) {\n        const newConversationIds = conversationId ? conversationId : generateConversationId();\n        conversationIds.push(newConversationIds);\n\n        if (!trackItemDictionary.containsIds(event.ids)) {\n            trackItemDictionary.add(event.ids, conversationIds);\n        }\n    }\n    return conversationIds;\n};\n\nexport const handleTrackingItems = (agm: Glue42Core.AGM.API,\n                                    action: string,\n                                    event: Glue42Office.Outlook.T42Appointment | Glue42Office.Outlook.T42Meeting,\n                                    conversationId?: Glue42Office.Outlook.T42Id): Promise<{\n                                        event: Glue42Office.Outlook.T42Appointment | Glue42Office.Outlook.T42Meeting,\n                                        conversationIds: Glue42Office.Outlook.T42Id[],\n                                    }> => {\n    return new Promise((resolve, reject) => {\n        validateCalendarEventParameters(agm, action, event);\n        const id = conversationId ? validateId(conversationId) : null;\n        const isTrackItem: boolean = action === \"track\";\n        const conversationIds = combineConversationIds(event, id, isTrackItem);\n\n        const successHandler = () => {\n            const response = {event, conversationIds};\n            resolve(response);\n\n            if (!isTrackItem) {\n                trackItemDictionary.remove(event.ids);\n                const untrackIds = event.ids.filter((ids: Glue42Office.Outlook.T42Id) => ids.systemName === (\"Outlook.ConversationId\"));\n                trackItemDictionary.add(event.ids, untrackIds);\n            }\n        };\n\n        const errorHandler = (err: { message: string }) => {\n            reject(err.message);\n            return;\n        };\n\n        const methodName = isTrackItem ? SyncTrackCalendarItemMethodName : SyncUntrackCalendarItemMethodName;\n        const params = {itemIds: event.ids, conversationIds};\n        return agm.invoke(methodName, params)\n            .then((res) => successHandler())\n            .catch((err) => errorHandler(err));\n    });\n};\n","import { Glue42Core } from \"@glue42/core\";\n\nimport {Glue42Office} from \"../../../glue4office\";\nimport {TaskImpl} from \"../items/TaskImplementation\";\nimport {EmailImpl} from \"../items/EmailImplementation\";\nimport {AttachmentImpl} from \"../items/AttachmentImplementation\";\n\nexport const itemFromJSON = (\n    item: Glue42Office.Outlook.T42Email | Glue42Office.Outlook.T42Task | Glue42Office.Outlook.T42Attachment,\n    agm: Glue42Core.AGM.API,\n    itemType: string): any => {\n    if (!item) {\n        throw new Error(`${itemType} is mandatory`);\n    }\n\n    if (!item.ids) {\n        throw new Error(`${itemType} ids property is mandatory`);\n    }\n\n    if (itemType === \"email\") {\n        return new EmailImpl((item as Glue42Office.Outlook.T42Email), agm);\n    } else if (itemType === \"task\") {\n        return new TaskImpl((item as Glue42Office.Outlook.T42Task), agm);\n    } else {\n        return new AttachmentImpl((item as Glue42Office.Outlook.T42Attachment), agm);\n    }\n};\n","import { Glue42Core } from \"@glue42/core\";\n\nimport {CallbackRegistry} from \"callback-registry\";\nimport {EmailImpl} from \"./items/EmailImplementation\";\nimport {TaskImpl} from \"./items/TaskImplementation\";\nimport {Glue42Office} from \"../../glue4office\";\nimport {concatChunkData, decodeData} from \"./helpers/index\";\nimport {TrackParams, UntrackParams} from \"./types\";\nimport {\n    DisplaySecureMailMethodName,\n    OnCancelMethodName,\n    OnEmailReceivedMethodName,\n    OnSendMethodName,\n    OnTaskCreatedMethodName,\n    OnTrackEmailMethodName,\n    OnTrackItemMethodName,\n    OnUntrackEmailMethodName,\n    OnUntrackItemMethodName,\n    OutlookGetAttachmentMethodName,\n    OutlookGetItemAsMsgMethodName,\n    SecureReplyMethodName,\n} from \"./helpers/methodNames\";\nimport createItemDictionary from \"./dictionaries/CreateItemDictionary\";\nimport getAttachmentDictionary from \"./dictionaries/GetAttachmentDictionary\";\nimport chunkDataDictionary from \"./dictionaries/ChunkDataDictionary\";\nimport getItemAsMsgDictionary from \"./dictionaries/GetItemAsMsgDictionary\";\nimport trackEmailDictionary from \"./dictionaries/TrackEmailDictionary\";\nimport trackItemDictionary from \"./dictionaries/TrackItemDictionary\";\nimport {type} from \"os\";\n\nconst registerOnEmailReceived = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\n    return agm.register(OnEmailReceivedMethodName,\n        (args: {email: Glue42Office.Outlook.Email}) => {\n            const email = new EmailImpl(args.email, agm);\n            callbacks.execute(\"onEmailReceived\", email);\n            return {email};\n        });\n};\n\nconst registerOnTaskCreated = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\n    return agm.register(OnTaskCreatedMethodName, (args: Glue42Office.Outlook.Task) => {\n        const task = new TaskImpl(args, agm);\n        callbacks.execute(\"onTaskCreated\", task);\n        return {task};\n    });\n};\n\nconst registerOnSendMethod = (agm: Glue42Core.AGM.API) => {\n    return agm.register(OnSendMethodName, (args: {cookie: string, email?: Glue42Office.Outlook.T42Email, task?: Glue42Office.Outlook.T42Task}) => {\n        const {cookie, email, task} = args;\n        if (!createItemDictionary.containsKey(cookie) ||\n            typeof createItemDictionary.get(cookie).onSent !== \"function\") {\n            return;\n        }\n\n        if (email && !task) {\n            createItemDictionary.get(cookie).onSent(new EmailImpl(email, agm));\n            return {cookie, email};\n        } else if (!email && task) {\n            createItemDictionary.get(cookie).onSent(new TaskImpl(task, agm));\n            return {cookie, task};\n        }\n        createItemDictionary.remove(cookie);\n     });\n};\n\nconst registerOnCancelMethod = (agm: Glue42Core.AGM.API) => {\n    return agm.register(OnCancelMethodName, (args: {cookie: string, itemID: string}) => {\n        const {cookie} = args;\n        if (!createItemDictionary.containsKey(cookie) ||\n            typeof createItemDictionary.get(cookie).onCanceled !== \"function\") {\n            return;\n        }\n\n        createItemDictionary.get(cookie).onCanceled();\n        createItemDictionary.remove(cookie);\n        return {cookie};\n    });\n};\n\nconst getChunkDataSuccessCallback = (methodCallbacksDictionary: {[key: string]: any}, cookie: string) => {\n    const attachmentData: string = concatChunkData(chunkDataDictionary.get(cookie));\n    if (methodCallbacksDictionary.containsKey(cookie)) {\n        methodCallbacksDictionary.get(cookie).resolve(decodeData(attachmentData));\n    }\n\n    chunkDataDictionary.remove(cookie);\n    methodCallbacksDictionary.remove(cookie);\n};\n\nconst getChunkDataErrorCallback =\n    (methodCallbacksDictionary: {[key: string]: any}, cookie: string, errorMessage: string) => {\n        if (methodCallbacksDictionary.containsKey(cookie)) {\n            methodCallbacksDictionary.get(cookie).reject(errorMessage);\n        }\n\n        chunkDataDictionary.remove(cookie);\n        methodCallbacksDictionary.remove(cookie);\n    };\n\nconst executeGetDataCallback = (percent: number, cookie: string) => {\n    if (percent <= 100 &&\n        getAttachmentDictionary.containsKey(cookie) &&\n        typeof getAttachmentDictionary.get(cookie).callback === \"function\") {\n            getAttachmentDictionary.get(cookie).callback(percent);\n    }\n};\n\nconst registerGetAttachment = (agm: Glue42Core.AGM.API) => {\n    let percent = 0;\n    return agm.register(OutlookGetAttachmentMethodName, (args: Glue42Office.Outlook.T42Attachment) => {\n        const {cookie, data, errorMessage, success, more, length, totalLength} = args;\n        chunkDataDictionary.add(cookie, data);\n\n        if (success) {\n            percent += (length / totalLength) * 100;\n            executeGetDataCallback(percent, cookie);\n            if (!more) {\n                if (percent < 100) {\n                    executeGetDataCallback(100, cookie);\n                }\n                percent = 0;\n                getChunkDataSuccessCallback(getAttachmentDictionary, cookie);\n            }\n        } else {\n            percent = 0;\n            getChunkDataErrorCallback(getAttachmentDictionary, cookie, errorMessage);\n        }\n        return {};\n    });\n};\n\nconst registerGetItemAsMsgMethod = (agm: Glue42Core.AGM.API) => {\n    return agm.register(OutlookGetItemAsMsgMethodName, (args: Glue42Office.Outlook.GetEmailAsMsgCallbackParams) => {\n        const {cookie, data, errorMessage, success, more} = args;\n        chunkDataDictionary.add(cookie, data);\n\n        if (success) {\n            if (!more) {\n                getChunkDataSuccessCallback(getItemAsMsgDictionary, cookie);\n            }\n        } else {\n            getChunkDataErrorCallback(getItemAsMsgDictionary, cookie, errorMessage);\n        }\n        return {};\n    });\n};\n\nexport const registerCRMTrackEmail = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\n    return agm.register(OnTrackEmailMethodName, (args: TrackParams) => {\n        const {conversationIds} = args;\n        const email = new EmailImpl(args.email, agm);\n        trackEmailDictionary.add(email.ids, conversationIds);\n        callbacks.execute(\"onEmailTracked\", {conversationIds, email});\n        return {};\n    });\n};\n\nexport const registerCRMUntrackEmail = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\n    return agm.register(OnUntrackEmailMethodName, (args: UntrackParams) => {\n        const {conversationIds, emailIds} = args;\n        callbacks.execute(\"onEmailUntracked\", {conversationIds, emailIds});\n        return {};\n    });\n};\n\nexport const registerCRMTrackItem = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\n    return agm.register(OnTrackItemMethodName, (args: TrackParams) => {\n        const {conversationIds, item} = args;\n        trackItemDictionary.add(item.ids, conversationIds);\n        callbacks.execute(\"onItemTracked\", {conversationIds, event: item});\n        return {conversationIds, event: item};\n    });\n};\n\nexport const registerCRMUntrackItem = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\n    return agm.register(OnUntrackItemMethodName, (args: UntrackParams) => {\n        const {conversationIds, itemIds} = args;\n        callbacks.execute(\"onItemUntracked\", {conversationIds, eventIds: itemIds});\n        return {conversationIds, eventIds: itemIds};\n    });\n};\n\nconst registerSecureReply = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\n    return agm.register(SecureReplyMethodName,\n        (args: {inReplyToMail: Glue42Office.Outlook.T42Email}) => {\n            const email = new EmailImpl(args.inReplyToMail, agm);\n            callbacks.execute(\"onSecureReply\", email);\n            return {email};\n        });\n};\n\nconst registerDisplaySecureEmail = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\n    return agm.register(DisplaySecureMailMethodName,\n        (args: {inReplyToMail: Glue42Office.Outlook.T42Email}) => {\n            const email = new EmailImpl(args.inReplyToMail, agm);\n            callbacks.execute(\"onDisplaySecureEmail\", email);\n            return {email};\n        });\n};\n\nexport const registerAgmMethods = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\n    registerOnEmailReceived(agm, callbacks);\n    registerOnTaskCreated(agm, callbacks);\n    registerOnSendMethod(agm);\n    registerOnCancelMethod(agm);\n    registerGetItemAsMsgMethod(agm);\n    registerGetAttachment(agm);\n    registerSecureReply(agm, callbacks);\n    registerDisplaySecureEmail(agm, callbacks);\n};\n","import { Glue42Core } from \"@glue42/core\";\r\n\r\nimport {CallbackRegistry} from \"callback-registry\";\r\n\r\nimport {AnonymousFunction} from \"./types\";\r\nimport {\r\n    OnSecureReplyCallback,\r\n    OnDisplaySecureEmailCallback,\r\n    OnAddinStatusChangedCallback,\r\n    TrackCalendarEventCallback,\r\n    TrackEmailCallback,\r\n    UntrackCalendarEventCallback,\r\n    UntrackEmailCallback,\r\n    OnEmailReceivedCallback,\r\n    OnTaskCreatedCallback,\r\n} from \"./types\";\r\nimport {isOutlookEnabled} from \"./helpers/index\";\r\nimport {\r\n    registerCRMTrackEmail, registerCRMTrackItem, registerCRMUntrackEmail, registerCRMUntrackItem,\r\n} from \"./registerAgmMethods\";\r\nimport {\r\n    CreateItemMethodName,\r\n    OnTrackEmailMethodName,\r\n    OnTrackItemMethodName,\r\n    OnUntrackEmailMethodName,\r\n    OnUntrackItemMethodName,\r\n} from \"./helpers/methodNames\";\r\n\r\nexport let connected: boolean = false;\r\n\r\nconst onOutlookEnabled = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\r\n    if (isOutlookEnabled(agm)) {\r\n        connected = true;\r\n    }\r\n    agm.methodAdded((m: {name: string}) => {\r\n        if (m.name === CreateItemMethodName) {\r\n            if (connected === false) {\r\n                connected = true;\r\n                callbacks.execute(\"onAddinStatusChanged\", {connected});\r\n            }\r\n        }\r\n    });\r\n};\r\n\r\nconst onOutlookDisabled = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\r\n    agm.methodRemoved((m: {name: string}) => {\r\n        if (m.name === CreateItemMethodName) {\r\n            connected = false;\r\n            callbacks.execute(\"onAddinStatusChanged\", {connected});\r\n        }\r\n    });\r\n};\r\n\r\nexport const registerEventListeners = (agm: Glue42Core.AGM.API, callbacks: CallbackRegistry) => {\r\n    onOutlookEnabled(agm, callbacks);\r\n    onOutlookDisabled(agm, callbacks);\r\n};\r\n\r\nexport const registerOnAddinStatusChanged = (agm: Glue42Core.AGM.API,\r\n                                             callback: OnAddinStatusChangedCallback,\r\n                                             callbacks: CallbackRegistry): AnonymousFunction => {\r\n    callback({connected});\r\n    return callbacks.add(\"onAddinStatusChanged\", callback);\r\n};\r\n\r\nexport const registerOnEmailReceived = (agm: Glue42Core.AGM.API,\r\n                                        callback: OnEmailReceivedCallback,\r\n                                        callbacks: CallbackRegistry): AnonymousFunction => {\r\n    return callbacks.add(\"onEmailReceived\", callback);\r\n};\r\n\r\nexport const registerOnTaskCreated = (agm: Glue42Core.AGM.API,\r\n                                      callback: OnTaskCreatedCallback,\r\n                                      callbacks: CallbackRegistry): AnonymousFunction => {\r\n    return callbacks.add(\"onTaskCreated\", callback);\r\n};\r\n\r\nconst unsubscribeFunction = (uns: () => void, agm: Glue42Core.AGM.API, methodName: string) => {\r\n    uns();\r\n    if (agm.methods({name: methodName}).length > 0) {\r\n        agm.unregister(methodName);\r\n    }\r\n};\r\n\r\nexport const registerTrackEmail = (agm: Glue42Core.AGM.API,\r\n                                   callback: TrackEmailCallback,\r\n                                   callbacks: CallbackRegistry): AnonymousFunction => {\r\n    if (agm.methods({name: OnTrackEmailMethodName}).length === 0) {\r\n        registerCRMTrackEmail(agm, callbacks);\r\n        const uns = callbacks.add(\"onEmailTracked\", callback);\r\n        return () => unsubscribeFunction(uns, agm, OnTrackEmailMethodName);\r\n    } else {\r\n        throw Error(\"Another client has already subscribed for tracking emails\");\r\n    }\r\n};\r\n\r\nexport const registerUntrackEmail = (agm: Glue42Core.AGM.API,\r\n                                     callback: UntrackEmailCallback,\r\n                                     callbacks: CallbackRegistry): AnonymousFunction => {\r\n    if (agm.methods({name: OnUntrackEmailMethodName}).length === 0) {\r\n        registerCRMUntrackEmail(agm, callbacks);\r\n        const uns = callbacks.add(\"onEmailUntracked\", callback);\r\n        return () => unsubscribeFunction(uns, agm, OnUntrackEmailMethodName);\r\n    } else {\r\n        throw Error(\"Another client has already subscribed for untracking emails\");\r\n    }\r\n};\r\n\r\nexport const registerTrackItem = (agm: Glue42Core.AGM.API,\r\n                                  callback: TrackCalendarEventCallback,\r\n                                  callbacks: CallbackRegistry): AnonymousFunction => {\r\n    if (agm.methods({name: OnTrackItemMethodName}).length === 0) {\r\n        registerCRMTrackItem(agm, callbacks);\r\n        const uns = callbacks.add(\"onItemTracked\", callback);\r\n        return () => unsubscribeFunction(uns, agm, OnTrackItemMethodName);\r\n    } else {\r\n        throw Error(\"Another client has already subscribed for tracking calendar events\");\r\n    }\r\n};\r\n\r\nexport const registerUntrackItem = (agm: Glue42Core.AGM.API,\r\n                                    callback: UntrackCalendarEventCallback,\r\n                                    callbacks: CallbackRegistry): AnonymousFunction => {\r\n    if (agm.methods({name: OnUntrackItemMethodName}).length === 0) {\r\n        registerCRMUntrackItem(agm, callbacks);\r\n        const uns = callbacks.add(\"onItemUntracked\", callback);\r\n        return () => unsubscribeFunction(uns, agm, OnUntrackItemMethodName);\r\n    } else {\r\n        throw Error(\"Another client has already subscribed for untracking calendar events\");\r\n    }\r\n};\r\n\r\nexport const registerSecureReply = (agm: Glue42Core.AGM.API,\r\n                                    callback: OnSecureReplyCallback,\r\n                                    callbacks: CallbackRegistry): AnonymousFunction => {\r\n    return callbacks.add(\"onSecureReply\", callback);\r\n};\r\n\r\nexport const registerDisplaySecureEmail = (agm: Glue42Core.AGM.API,\r\n                                           callback: OnDisplaySecureEmailCallback,\r\n                                           callbacks: CallbackRegistry): AnonymousFunction => {\r\n    return callbacks.add(\"onDisplaySecureEmail\", callback);\r\n};\r\n","import {\n    Glue42Office,\n} from \"../../glue4office\";\nimport { Glue42Core } from \"@glue42/core\";\n\nexport type OnAddinStatusChangedCallback = (args: { connected: boolean }) => any;\nexport type OnEmailReceivedCallback = (email: Glue42Office.Outlook.Email) => any;\nexport type OnTaskCreatedCallback = (task: Glue42Office.Outlook.Task) => any;\nexport type TrackEmailCallback = (args: { conversationIds: Glue42Office.Outlook.T42Id[], email: Glue42Office.Outlook.Email }) => any;\nexport type UntrackEmailCallback = (args: { conversationIds: Glue42Office.Outlook.T42Id[], emailIds: Glue42Office.Outlook.T42Id[] }) => any;\nexport type TrackCalendarEventCallback = (args: { conversationIds: Glue42Office.Outlook.T42Id[], event: Glue42Office.Outlook.T42Appointment | Glue42Office.Outlook.T42Meeting }) => any;\nexport type UntrackCalendarEventCallback = (args: { conversationIds: Glue42Office.Outlook.T42Id[], eventIds: Glue42Office.Outlook.T42Id[] }) => any;\nexport type OnSecureReplyCallback = (email: Glue42Office.Outlook.Email) => any;\nexport type OnDisplaySecureEmailCallback = (email: Glue42Office.Outlook.Email) => any;\nexport type AnonymousFunction = () => any;\n\nexport interface Config {\n    agm: Glue42Core.AGM.API;\n}\n\nexport interface CreateItemObject {\n    ItemType: string;\n    Cookie: string;\n    OnSendMethod: string;\n    OnCancelMethod: string;\n    AttachFiles?: string[];\n    PropertiesAsJSON?: string;\n    t42value?: Glue42Office.Outlook.EmailParams | Glue42Office.Outlook.TaskParams;\n}\n\nexport interface TrackParams {\n    callback: string;\n    conversationIds: Glue42Office.Outlook.T42Id[];\n    cookie: string;\n    forceNew: boolean;\n    email?: Glue42Office.Outlook.T42Email;\n    item?: Glue42Office.Outlook.T42Appointment | Glue42Office.Outlook.T42Meeting;\n}\n\nexport interface UntrackParams {\n    callback: string;\n    conversationIds: Glue42Office.Outlook.T42Id[];\n    cookie: string;\n    forceNew: boolean;\n    emailIds?: Glue42Office.Outlook.T42Id[];\n    itemIds?: Glue42Office.Outlook.T42Id[];\n}\n\nexport interface T42ValueEmail {\n    attachments?: string[] | Glue42Office.Outlook.AttachmentParams[];\n    bcc?: Glue42Office.Outlook.T42Contact[];\n    body?: string;\n    bodyHtml?: string;\n    cc?: Glue42Office.Outlook.T42Contact[];\n    cookie?: string;\n    onCancelCallback?: (args: { cookie: string, itemID: string }) => any;\n    onSendCallback?: (email: Glue42Office.Outlook.T42Email) => any;\n    subject?: string;\n    to?: Glue42Office.Outlook.T42Contact[];\n    [key: string]: any;\n}\n\nexport interface T42ValueTask {\n    attachments?: string[] | Glue42Office.Outlook.AttachmentParams[];\n    body?: string;\n    cookie?: string;\n    startDate?: Date | string | number;\n    dueDate?: Date | string | number;\n    onCancelCallback?: (args: { cookie: string, itemID: string }) => any;\n    onSaveCallback?: (task: Glue42Office.Outlook.T42Task) => any;\n    importance?: number;\n    reminderTime?: Date | string | number;\n    subject?: string;\n    [key: string]: any;\n}\n\nexport interface CreateLocalEmailParams {\n    email: T42ValueEmail;\n    location: {\n        parentItemIds?: Glue42Office.Outlook.T42Id[];\n        folderPath?: string;\n        defaultFolderIndex?: Glue42Office.Outlook.CommonOutlookFolder;\n    };\n    customProperties?: object;\n    [key: string]: any;\n}\n\nexport interface OlDefaultFolders {\n    $SentMail: number;\n    $Inbox: number;\n    [key: string]: any;\n}\n\nexport enum TaskPriority {\n    low = 0,\n    normal = 1,\n    high = 2,\n}\n\nexport interface KeyedCollection {\n    containsKey: (key: string) => boolean;\n    remove: (key: string) => void;\n}\n\nexport interface PromiseCallback {\n    resolve: (res: any) => void;\n    reject: (errMessage: string) => void;\n}\n\nexport interface CreateItem extends KeyedCollection {\n    add: (key: string, value: CreateItemCallbacks) => void;\n    get: (key: string) => CreateItemCallbacks;\n}\n\nexport interface CreateItemCallbacks {\n    onSent?: (item: Glue42Office.Outlook.Email | Glue42Office.Outlook.Task) => any;\n    onCanceled: () => any;\n}\n\nexport interface GetAttachment extends KeyedCollection {\n    add: (key: string, value: GetAttachmentCallback) => void;\n    get: (key: string) => GetAttachmentCallback;\n}\n\nexport interface GetAttachmentCallback extends PromiseCallback {\n    callback: (percent: number) => number;\n}\n\nexport interface ChunkData extends KeyedCollection {\n    add: (key: string, data: string) => void;\n    get: (key: string) => string[];\n}\n\nexport interface GetItemAsMsg extends KeyedCollection {\n    add: (key: string, data: PromiseCallback) => void;\n    get: (key: string) => PromiseCallback;\n}\n\nexport interface TrackItem {\n    containsIds: (ids: Glue42Office.Outlook.T42Id[]) => boolean;\n    add: (emailIds: Glue42Office.Outlook.T42Id[], ids: Glue42Office.Outlook.T42Id[]) => void;\n    remove: (ids: Glue42Office.Outlook.T42Id[]) => void;\n    get: (ids: Glue42Office.Outlook.T42Id[]) => Glue42Office.Outlook.T42Id[];\n}\n\nexport interface ChunkFileParams {\n    chunkFile: Glue42Office.Outlook.AttachmentParams;\n    chunkData: string;\n}\n","export const version = \"1.7.7\";\r\n","export const CloseMethodName = \"T42.WordEditor.Closed\";\nexport const EditHtmlMethodName = \"T42.Word.HtmlEdit\";\nexport const ReceiveHtmlMethodName = \"T42.Word.HtmlReceive\";\nexport const ReturnHtmlMethodName = \"T42.Word.ReturnHtml\";\nexport const OnReturnHtmlMethodName = \"T42.Word.OnReturnHtml\";\nexport const ChunkSize = 4000000;\n","import { CallbackRegistry, UnsubscribeFunction } from \"callback-registry\";\nimport { Glue42Office } from \"../../glue4office\";\nimport { DocumentEvents, HtmlReceiveInvocationResult, InternalDocumentApi } from \"./types\";\nimport { Glue42Core } from \"@glue42/core\";\nimport { ReturnHtmlMethodName, OnReturnHtmlMethodName } from \"./const\";\n\nconst CallbackFactory = require(\"callback-registry\");\n\nexport default (cookie: string, config: Glue42Office.Word.OpenDocumentConfig, agm: Glue42Core.AGM.API): InternalDocumentApi => {\n    const _registry: CallbackRegistry = CallbackFactory();\n\n    const name = config.name;\n    const data = config.data;\n    let _html = \"\";\n    let _docx = \"\";\n    let getHtmlPromise: any;\n\n    function onClose(callback: () => void): UnsubscribeFunction {\n        return _registry.add(\"on-closed\", callback);\n    }\n\n    function _close(): void {\n        _registry.execute(\"on-closed\");\n    }\n\n    function getHtml(callback: (html: string) => void): Promise<string> {\n        return new Promise((resolve, reject) => {\n            agm.invoke(ReturnHtmlMethodName, {\n                cookie,\n                callbackMethod: OnReturnHtmlMethodName,\n            });\n            getHtmlPromise = resolve;\n        });\n    }\n\n    function onChanged(callback: (html: string, docx?: string) => void): UnsubscribeFunction {\n        return _registry.add(\"on-changed\", callback);\n    }\n\n    function _combineChunks(newData: HtmlReceiveInvocationResult, cb: (html: string, docx: string) => void): void {\n        // We have all document in one chunk\n        if (newData.length === newData.totalLength && newData.lengthDocx === newData.totalLengthDocx) {\n            _html = newData.html;\n            _docx = newData.docx;\n            cb(_html, _docx);\n        } else {\n            // We have multiple chunks\n            if (newData.offset === 0) {\n                _html = \"\";\n            }\n            if (newData.offsetDocx === 0) {\n                _docx = \"\";\n            }\n\n            if (newData.html && newData.html.length > 0) {\n                _html = _html.substr(0, newData.offset) + newData.html +\n                    _html.substr(newData.offset + newData.length);\n            }\n            if (newData.docx && newData.docx.length > 0) {\n                _docx = _docx.substr(0, newData.offsetDocx) + newData.docx +\n                    _docx.substr(newData.offsetDocx + newData.lengthDocx);\n            }\n\n            const docxTotal = newData.totalLengthDocx || 0;\n\n            if ((newData.totalLength === _html.length) &&\n                (docxTotal === 0 || docxTotal === _docx.length)) {\n                // Execute when all chunks are received\n                cb(_html, _docx);\n            }\n        }\n    }\n\n    function _onHtml(newData: HtmlReceiveInvocationResult): void {\n        _combineChunks(newData, (html, docx) => {\n            getHtmlPromise(html);\n        });\n\n    }\n\n    function _onChanged(newData: HtmlReceiveInvocationResult): void {\n        _combineChunks(newData, (html, docx) => {\n            api.data = html;\n            _registry.execute(\"on-changed\", api.data, docx);\n        });\n    }\n\n    const api: Glue42Office.Word.DocumentApi = {\n        name,\n        data,\n\n        getHtml,\n        onClose,\n        onChanged,\n    };\n\n    const events: DocumentEvents = {\n        _onChanged,\n        _close,\n        _onHtml,\n    };\n\n    return {\n        documentApi: api,\n        documentEvents: events,\n    };\n};\n","\nimport { CallbackRegistry, UnsubscribeFunction } from \"callback-registry\";\nimport { Glue42Core } from \"@glue42/core\";\nimport { Glue42Office } from \"../../glue4office\";\nimport { CloseMethodName, EditHtmlMethodName, ReceiveHtmlMethodName, ChunkSize, OnReturnHtmlMethodName } from \"./const\";\nimport documentFactory from \"./document\";\nimport {\n    HtmlReceiveInvocationResult, InternalDocumentApi, InternalOpenDocumentConfig,\n    OnCloseInvocationResult,\n    Config,\n} from \"./types\";\nimport { mapOptions } from \"./utils\";\n\nconst CallbackFactory = require(\"callback-registry\");\n\nexport default (config: Config): Glue42Office.Word.API => {\n    const agm: Glue42Core.AGM.API = config.agm;\n    const _registry: CallbackRegistry = CallbackFactory();\n\n    let connected: boolean = false;\n    const documents: any = {};\n\n    function openDocument(options: Glue42Office.Word.OpenDocumentConfig): Promise<Glue42Office.Word.DocumentApi> {\n        return new Promise((resolve, reject) => {\n            const internalConfig: InternalOpenDocumentConfig = mapOptions(options);\n            const successHandler = (args: any): void => {\n                // Create a new document object and resolve the Promise\n                internalConfig.cookie = args.returned.sessionId;\n                const doc: InternalDocumentApi = documentFactory(internalConfig.cookie, options, agm);\n                documents[internalConfig.cookie] = doc;\n                resolve(doc.documentApi);\n            };\n\n            const errorHandler = (e: object): void => {\n                // tslint:disable-next-line:no-console\n                console.warn(e);\n                reject(e);\n            };\n\n            let offset = 0;\n            let chunks = 0;\n            const chunkedData: any = [];\n\n            while (offset < options.data.length) {\n                chunkedData.push(options.data.substr(offset, ChunkSize));\n                offset += ChunkSize;\n            }\n\n            function sendChunks(args?: any) {\n                const chunk = chunkedData.splice(0, 1);\n                if (chunk.length === 0) {\n                    successHandler(args);\n                    return;\n                }\n\n                internalConfig.sendDocx = true;\n\n                if (options.isDocx) {\n                    internalConfig.docx = chunk[0];\n                    internalConfig.lengthDocx = chunk[0].length;\n                    internalConfig.totalLengthDocx = options.data.length;\n                    internalConfig.offsetDocx = chunks * ChunkSize;\n                } else {\n                    internalConfig.html = chunk[0];\n                    internalConfig.length = chunk[0].length;\n                    internalConfig.totalLength = options.data.length;\n                    internalConfig.offset = chunks * ChunkSize;\n                }\n                invokeEditHtmlMethod(internalConfig).then(sendChunks).catch(errorHandler);\n                chunks++;\n            }\n            sendChunks();\n        });\n    }\n\n    // #region \"Internal functions\"\n    agm.methodAdded((method) => {\n        if (method.name === EditHtmlMethodName) {\n            if (connected === false) {\n                connected = true;\n                _registry.execute(\"onStatusChanged\", { connected });\n            }\n        }\n    });\n\n    agm.methodRemoved((method) => {\n        if (method.name === EditHtmlMethodName) {\n            connected = false;\n            _registry.execute(\"onStatusChanged\", { connected });\n        }\n    });\n\n    // OnDocumentChanged\n    agm.register(ReceiveHtmlMethodName, (args: HtmlReceiveInvocationResult, caller: Glue42Core.AGM.Instance) => {\n        const document: InternalDocumentApi = documents[args.cookie];\n        if (document) {\n            document.documentEvents._onChanged(args);\n        }\n\n        return undefined;\n    });\n\n    agm.register(OnReturnHtmlMethodName, (args: HtmlReceiveInvocationResult, caller: Glue42Core.AGM.Instance) => {\n        const document: InternalDocumentApi = documents[args.cookie];\n        if (document) {\n            document.documentEvents._onHtml(args);\n        }\n        return undefined;\n    });\n\n    // Closing method\n    agm.register({\n        name: CloseMethodName,\n        accepts: \"String documentName, String cookie\",\n    }, (args: OnCloseInvocationResult, caller: Glue42Core.AGM.Instance) => {\n        // Get cookie and delete the document and execute callback onClosed\n        const document: InternalDocumentApi = documents[args.cookie];\n        if (document) {\n            document.documentEvents._close();\n        }\n\n        delete documents[args.cookie];\n\n        return undefined;\n    });\n\n    function invokeEditHtmlMethod(options: InternalOpenDocumentConfig): Promise<object> {\n        return new Promise((resolve, reject) => {\n            if (!connected) {\n                reject(\"Microsoft Word with Tick42 Add-in is not running\");\n            } else {\n                agm.invoke(EditHtmlMethodName, options).then(resolve).catch(reject);\n            }\n        });\n    }\n    // #endregion \"Internal functions\"\n\n    function ready(): Promise<object> {\n        return new Promise((resolve, reject) => {\n            resolve(api);\n        });\n    }\n\n    function onAddinStatusChanged(callback: (args: { connected: boolean }) => void): UnsubscribeFunction {\n        if (agm.methods({ name: EditHtmlMethodName }).length > 0) {\n            connected = true;\n        }\n\n        callback({ connected });\n        return _registry.add(\"onStatusChanged\", callback);\n    }\n\n    const api: Glue42Office.Word.API = {\n        get all(): Glue42Office.Word.DocumentApi[] {\n            return Object.keys(documents).map((k) => {\n                return documents[k].documentApi;\n            });\n        },\n        openDocument,\n        ready,\n        onAddinStatusChanged,\n        get addinStatus() {\n            return connected;\n        },\n    };\n\n    return api;\n};\n","import { Glue42Office } from \"../../glue4office\";\nimport { CloseMethodName, ReceiveHtmlMethodName } from \"./const\";\nimport { InternalOpenDocumentConfig } from \"./types\";\n\nexport function mapOptions(data: Glue42Office.Word.OpenDocumentConfig): InternalOpenDocumentConfig {\n    const mappedOptions: InternalOpenDocumentConfig = {\n        displayName: \"\", // data.name,\n        documentName: data.name,\n        templateName: data.templateName,\n        onSaved: ReceiveHtmlMethodName,\n        onClosed:  CloseMethodName,\n    };\n    return mappedOptions;\n}\n"],"sourceRoot":""}